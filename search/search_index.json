{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to DJ Tools","text":"<p>DJ Tools started out as a set of scripts used to sync audio files to the cloud so I could share tracks with my friends. It's since grown into a Python library with many features for streamlining the processes around collecting, curating, and sharing a music collection.</p> <p>This library is DJ-platform agnostic. That being said, a subset of features (those under the <code>collection</code> package) depend on implementations for <code>Collection</code>, <code>Playlist</code>, and <code>Track</code> abstractions (see the references) for which there are currently only Rekordbox implementations. If you're interested in adding implementations for other DJ platforms, please read the Adding DJ Software Support to the Collections Package developer doc and create an issue.</p> <p>DJ Tools is tested on Ubuntu and Windows operating systems and Python versions 3.9 through 3.12.</p>"},{"location":"#where-to-start","title":"Where to start","text":"<p>Check out the Getting Started tutorial!</p>"},{"location":"#how-do-i","title":"How do I...?","text":"<p>Every capability of DJ Tools is demonstrated in the How-to Guides. Additionally, there are some guides for things external to DJ Tools such as setting up object storage and getting access to the Reddit and Spotify APIs.</p>"},{"location":"#tell-me-more","title":"Tell me more","text":"<p>You'll find exposition on relevant topics in Conceptual Guides such as Get to Know Your Rekordbox Collection, Tagging Guide, and The Importance of Standardization and Quality Control.</p>"},{"location":"#interested-in-contributing","title":"Interested in contributing?","text":""},{"location":"conceptual_guides/","title":"Conceptual Guides","text":"<ul> <li>Get to Know Your Rekordbox Collection</li> <li>Tagging Guide</li> <li>The Importance of Standardization and Quality Control</li> </ul>"},{"location":"conceptual_guides/file_standardization/","title":"Audio File Standardization &amp; Quality Control","text":""},{"location":"conceptual_guides/file_standardization/#audio-file-format","title":"Audio file format","text":"<p>The music files in your Collection should be in the MP3 format. There are a couple reasons for this:</p> <ol> <li>MP3 files are very compact meaning you can fit more music on your USB, pay less for cloud storage, and enjoy faster sync times</li> <li>Having smaller files also means faster loading times on CDJs / XDJs which are notoriously slow</li> <li>MP3 files have metadata fields called ID3 tags which couple information like track, title, artist, comment, genres, etc. with the file itself; other formats (AIFF or WAV) may include ID3 specifications</li> </ol> <p>It's true that MP3 is lossy, meaning it's possible for MP3 files to produce lower quality audio than, say, FLAC files, but research (see Nyquist\u2013Shannon sampling theorem) shows that even the most trained ears of audiophiles cannot distinguish any difference between lossless audio and 256 kbps MP3 audio.</p> <p>There are arguments that support using a sample rate higher than the theoretical minimum for human hearing (44.1 kHz); digital-to-analog conversion (as is performed in a speaker cone) is necessarily a non-linear system which can produce audible distortions from previously inaudible frequencies. However, if you use 320 kbps MP3s instead of FLACs on even the most advanced audio systems, nobody will be able to tell the difference.</p>"},{"location":"conceptual_guides/file_standardization/#filenames","title":"Filenames","text":"<p>The characters you use in the filenames added to the Beatcloud does matter; while Unix systems are very tolerant of filenames, Windows systems are comparably very sensitive. Windows explicitly lists these characters as forbidden: <code>&lt;</code>, <code>&gt;</code>, <code>:</code>, <code>\"</code>, <code>/</code>, <code>\\</code>, <code>|</code>, <code>?</code>, <code>*</code>, <code>%</code>, <code>?</code></p> <p>Futher more, files stored in S3 may not interact properly with the protocols that may be used to sync them if they contain particular characters. I cannot speak to character-related compatibility issues with other object-storage solutions.</p> <p>I'm advocating that the character set matched by this regex expression be the whitelist of characters for filenames:</p> <pre><code>In [2]: string = \"Track_Title (Artist2 Remix) ['Things' &amp; Stuff!] - Artist1, Artist2.mp3\"\n\nIn [3]: pattern = r\"[0-9 a-z A-Z _ ' &amp; \\( \\) \\[ \\] \\s \\- , . !]+\"\n\nIn [4]: re.match(pattern, string).group(0)\nOut[4]: \"Track_Title (Artist2 Remix) ['Things' &amp; Stuff!] - Artist1, Artist2.mp3\"\n</code></pre> <p>In general:</p> <ul> <li>Keep the filenames as close as possible to the <code>Title (Artist2 Remix) - Artist1, Artist2</code> format<ul> <li>If you use the format <code>Artist1, Artist2 - Title (Artist2 Remix)</code> instead, make sure you configure <code>artist_first</code> to be <code>true</code> (see Configuration for more detail)</li> </ul> </li> <li>Ensure there is only one instance of a hyphen with spaces on each side; title / artist splitting, which is needed for multiple features, will not work properly without this</li> <li>If the track is available on Spotify, try to match the fields as close as possible to how it appears there; e.g. if the title includes <code>(Radio Edit)</code> then you should name the track accordingly<ul> <li>All of the Spotify-based features of DJ Tools work by computing the Levenshtein distance between filenames and Spotify API query results, so deviating from these names can reduce the accuracy of those features</li> </ul> </li> <li>The exception to the above is when the track title contains accent marks, any of the explicitly listed characters disallowed by Windows, or any other weird / non-standard characters</li> </ul>"},{"location":"conceptual_guides/file_standardization/#standard-pre-processing","title":"Standard pre-processing","text":"<p>To ensure Collection consistency and successful operation of <code>DJ Tools</code>, the following properties should be maintained for all music files. Users of my Beatcloud instance must complete a minimum of (1), (2), and (3) prior to uploading. Since track title, artist names, and melodic key are objective, and populating these tags prior to uploading saves every other user from repeating these efforts, it is greatly appreciated if users also complete (4) and (5). It's advised that users complete (6) and (7) at some point so they can use the Build Playlists From Tags feature:</p> <ol> <li>MP3 file format</li> <li>Minimum 256 kbps bitrate</li> <li>Files named using convention: <code>Title (Artist2 Remix) - Artist1, Artist2</code><ul> <li>If you use the format <code>Artist1, Artist2 - Title (Artist2 Remix)</code> instead, make sure you configure <code>artist_first</code> to be <code>true</code> (see Configuration for more detail)</li> <li>All tracks in the Beatcloud must follow the same naming convention (my instance uses track title first)</li> </ul> </li> <li><code>Title</code> and <code>Artist</code> tags populated (e.g. software: Mp3tag or Picard)</li> <li><code>Key</code> tags populated (ideally using Mixed In Key)</li> <li><code>Genre</code> tags populated (separate multiple genres with a <code>/</code> character)</li> <li><code>Comment</code> tags populated with important information<ul> <li>Remove things like download links and other promotional content</li> <li>Note things that might trip you up while mixing like BPM changes</li> <li>Add notes about things like recognizable vocal samples, themed music samples, etc..</li> <li>Add <code>My Tags</code> tags (doing so should write to the <code>Comments</code> tag...see Rekordbox settings in the setup tutorial for more details)</li> </ul> </li> <li>Add <code>Year</code> and <code>Label</code> tags since Combine Playlists with Boolean Algebra works with these as string selectors</li> <li>Lock your beat grids after setting them to prevent accidental changes</li> </ol> <p>Mixed In Key is the most accurate key analysis software out there and is much better than Rekordbox's key analysis. Make sure you turn off <code>KEY</code> under <code>Preferences &gt; Analysis &gt; Track Analysis Setting</code> so as to not overwrite <code>Key</code> tags generated by MIK when importing tracks into Rekordbox.</p> <p></p>"},{"location":"conceptual_guides/rekordbox_collection/","title":"Get to Know Your Rekordbox Collection","text":"<p>In this guide, we'll be looking at one of the two ways your Rekordbox Collection can be represented.</p>"},{"location":"conceptual_guides/rekordbox_collection/#representations-of-your-collection","title":"Representations of your Collection","text":"<p>The native representation (for Rekordbox 6 at least) is an encrypted SQLite database stored in a <code>master.db</code> file and a cryptic hierarchy of binary files: </p> <p>While it's possible to decrypt this database and perform operations on it directly, this is not conducive to sharing with peers. For this reason, DJ Tools operates on a manually exported XML file: </p>"},{"location":"conceptual_guides/rekordbox_collection/#a-closer-look-at-the-rekordbox-xml-file","title":"A closer look at the Rekordbox XML file","text":"<p>As an example, we can look at the test XML packaged in the DJ Tools repo. It's been edited to be as minimal as possible: </p> <p>There are two primary sections in this XML; the first is the <code>COLLECTION</code> tree which houses a <code>TRACK</code> node for every track in your collection. The second section is a <code>PLAYLISTS</code> tree which contains sub-trees for all your nested folders with playlists in them. At the leaves of the tree are <code>TRACK</code> nodes which contain a single attribute, <code>Key</code>, which serves as a lookup for <code>TRACK</code> nodes in the <code>COLLECTION</code> tree via their <code>TrackID</code> attribute.</p> <p>The <code>TRACK</code> nodes in the <code>COLLECTION</code> tree contain every piece of information about your tracks: their beatgrid, hot cues, title, artist, genre, and comments tags, etc. Let's focus on one particular attribute of the <code>TRACK</code> node, the <code>Location</code>. This attribute is a string representing the path to the audio file. </p> <p>By convention, it's always prefixed with <code>file://localhost/</code> and suffixed with the absolute path to the audio file. For example, if you have an audio file located at <code>/Volumes/My_USB/Music/Favorites/best_song_ever.mp3</code>, then the <code>Location</code> attribute for its <code>TRACK</code> node will be <code>file://localhost/Volumes/My_USB/Music/Favorites/best_song_ever.mp3</code>.</p> <p>For Windows users, if you have a track located at <code>D:\\Music\\Favorites\\best_song_ever.mp3</code>, then the <code>Location</code> attribute for its <code>TRACK</code> node will be <code>file://localhost/D:/Music/Favorites/best_song_ever.mp3</code>. Take note that paths in the XML are always represented as posix paths using forwardslashes rather than backslashes.</p> <p>Also note that, upon inspecting your own XML export, the paths in the <code>Location</code> attribute will be escaped and look more like this:</p> <p><code>file://localhost/Volumes/AWEEEEZY/DJ%20Music/aweeeezy/Bass/2023-03-21/Catacombs%20(VIP%20Bootleg)%20-%20Ternion%20Sound,%20LOST.mp3</code></p>"},{"location":"conceptual_guides/rekordbox_collection/#how-dj-tools-uses-this-xml","title":"How DJ Tools uses this XML","text":"<p>All of the features of the rekordbox package of DJ Tools performs reads and writes on an exported XML file. The Shuffle Tracks in Playlists feature assigns new values to the <code>TrackNumber</code> attribute of the <code>TRACK</code> nodes appearing in the provided playlists. The Copy Tracks From Playlists feature uses the <code>Location</code> attribute to copy audio files to a new destination. The Build Playlists From Tags feature reads the <code>Genre</code> and <code>Comments</code> attributes to collect tracks and then manipulates the <code>PLAYLISTS</code> tree of the XML to automatically generate your desired playlist structure.</p> <p>Once you've run an operation that edits the XML, you must import those tracks and / or playlists to realize the changes. To do this, select the track(s), playlist(s), or folder(s) from <code>rekordbox XML</code> section of the tree view and choose \"Import To Collection\" or \"Import Playlist\"; this will overwrite any playlists, beatgrids, hot cues, tags, etc. so make sure you know what you're doing (first make a backup by exporting a fresh XML)!: </p> <p>This is the same method you use to import tracks from other user's XML files (see this guide for more details).</p>"},{"location":"conceptual_guides/tagging_guide/","title":"Tagging Guide","text":"<p>In this guide, I'll be offering opinions, tips, and best-practices for tagging your collection.</p> <p>Having indexed and re-indexed my collection of thousands of tracks several times already, there are a handful of things I wish I knew from the beginning that could have saved me a few passes through my library.</p> <p>I'll begin with three general tips that should be applicable regardless of what types of tagging you're doing. I'll then go over tips grouped by the more specific types of tags such as genres, ratings, and \"other\" tags.</p>"},{"location":"conceptual_guides/tagging_guide/#general-tips","title":"General Tips","text":""},{"location":"conceptual_guides/tagging_guide/#tip-1-know-what-metadata-fields-are-available-to-you","title":"Tip #1: Know what metadata fields are available to you","text":"<p>Before embarking on a potentially multi-month journey to index your collection, make sure you're aware of all the ways you can attach information to your tracks. The worst time to realize you could have been using a particular field to encode information is after you've finished applying a process to your entire collection.</p> <p>Look over each column and determine if you have a purpose (or repurpose) for that information. In, for example, the Rekordbox library view, all the available fields can have their visibility toggled by right-clicking on the column headers.</p> <p>Build a plan for what information is valuable to you both while preparing and executing mixes and keep this plan in mind while applying your processes. Remember that some information may not always be available to you. For example, I once applied a hot cue schema to all my tracks before realizing that older CDJs only have access to the first three hot cues. I then had to go through all my tracks and reorder the hot cues so the three most practical cue points filled the A, B, and C hot cue positions.</p> <p>Look through the full set of preferences for your library management software and make sure you're maximizing your ability to capture useful information. In Rekordbox, if you want <code>djtools</code> to be able to build playlists from your <code>My Tags</code> data, or if you want to be able to search <code>My Tag</code> data on CDJs, you must enable the setting <code>Add \"My Tags\" to the \"Comments\"</code>. Please see the setup guide for more info.</p> <p><code>NOTE:</code> You should be applying your findings from <code>Tip #1</code> while executing on <code>Tip #2</code> and <code>Tip #3</code>. By incubating on your plans for tagging while scanning through your collection, you may find ways to improve those plans before you even start tagging.</p>"},{"location":"conceptual_guides/tagging_guide/#tip-2-prune-your-library","title":"Tip #2: Prune your library","text":"<p>Attempting to apply all your tags to your entire collection in one shot may sound like a good plan, but it's likely going to lead to you needing to re-tag your collection for one reason or another. You also might find that some types of tagging processes are much easier to do after you've already completed another tagging process.</p> <p>Before tagging, I recommend doing a quick pass through your whole collection and copy tracks that you may want to consider deleting into a <code>DELETE</code> playlist. Even if you don't end up deleting anything, it can be a useful exercise to critically assess the value each track has. If you do end up deleting stuff, then you'll have an easier time applying tags.</p> <p>There are multiple reasons why you may want to mark a track for deletion:</p> <ul> <li>track duration is too short to be practical -- yeah it's dope, but are you really gonna mix that 40 second beat?</li> <li>track is well outside your mixing style -- I love Pink Floyd too, but you'll probably never mix Comfortably Numb into your DnB sets</li> <li>that low quality rip from YouTube may have seemed like a good addition while you were obsessed with having that track, but now it just sounds horrible</li> </ul>"},{"location":"conceptual_guides/tagging_guide/#tip-3-identify-golden-tracks","title":"Tip #3: Identify \"golden tracks\"","text":"<p>While doing this preliminary pruning scan, also copy exceptional tracks into a <code>Golden Tracks</code> playlist. Think of this playlist as a testbed where you can try out your schemas on a batch of diverse tracks that are practical and you enjoy mixing. Detecting a deficiency in your schemas early on in this playlist will save you a bunch of time. </p> <p>For your <code>Golden Tracks</code> playlist to be effective for this purpose, it must be representative of your library, meaning it should have enough samples from each of the different corners of your collection. I recommend adding songs that you either have an exceptional fondness of, are relatively unique in style and character, or you feel contribute significantly towards defining your mixing style. Don't confuse this as a <code>My Favorites</code> playlist -- your taste in music changes over time. The most critical property of <code>Golden Tracks</code> is that it's diverse! Ideally, the contents of the playlist will force you to increase the scope of your schemas.</p> <p>Of course, what your <code>Golden Tracks</code> playlist looks like depends on multiple factors such as the maturity, size, and diversity of your collection. If you have a massive collection comprised of many different styles, your <code>Golden Tracks</code> playlist should capture those styles and it might be a large playlist with hundreds of tracks. Conversely, if your have a small and very homogenous library, your <code>Golden Tracks</code> might as well be your entire library. But, if this is the case, you're probably not interested in tagging your collection anyway.</p>"},{"location":"conceptual_guides/tagging_guide/#specific-tagging-strategies","title":"Specific Tagging Strategies","text":""},{"location":"conceptual_guides/tagging_guide/#genre-tags","title":"Genre tags","text":""},{"location":"conceptual_guides/tagging_guide/#find-a-useful-middle-ground-regarding-the-specificity-of-your-genre-tags","title":"Find a useful middle-ground regarding the specificity of your genre tags","text":"<p>You don't want your genre tags to be too specific or else you risk them loosing their value. If you're able to describe many of your tracks with a single genre tag, your genres are too specific. You'll end up with a bunch of genre playlists that have three tracks in them causing you to waste a bunch of time during the mix moving through different playlists.</p> <p>On the other hand, if your genre tags are too broad, you'll have genre playlists with many tracks that don't belong near each other which will lead to you wasting time previewing tracks that don't fit in the mix.</p> <p>You will definitely have tracks that you feel you can't distinguish with the genres you have. Don't forget that you can use \"other\" tags too. Trying to describe all the variance in your tracks with only genre tags is a mistake! Genre tags should be used for establishing macro groups in your library, not for completely capturing all the characteristics of each and every track.</p> <p><code>NOTE:</code> If you're a Rekordbox user, for <code>djtools</code> to be able to build playlists using genre tags, tracks with multiple genres must have those tags separated by forward slashes.</p>"},{"location":"conceptual_guides/tagging_guide/#dont-let-perfect-get-in-the-way-of-good","title":"Don't let perfect get in the way of good","text":"<p>It's easy to feel discouraged when trying to determine what genres you should use in your collection. Remember, this is an iterative learning process and you will almost certainly discover as you go what to call tracks you've collected. Again, this is why you want to have a <code>Golden Tracks</code> playlist so you can try out your ideas before you commit to them completely.</p> <p>Inevitably you'll find you made judgement errors when tagging and will have to go back and fix them. I finished tagging the genres of my collection years ago and I'm still occasionally finding tracks in playlists that feel out of place. That's the beauty of the playlist builder in <code>djtools</code>! Whenever you find an out of place track, correcting it is as easy as editing the tags for the track before rebuilding your playlists.</p>"},{"location":"conceptual_guides/tagging_guide/#other-tags","title":"\"Other\" tags","text":"<p>\"Other\" tags are any custom tags that don't fall under a pre-defined field (like \"artist\", \"genre\", etc.). In Rekordbox, these are called <code>My Tags</code>. </p> <p><code>NOTE:</code> For Rekordbox users' <code>My Tags</code> to be readable by <code>djtools</code> they must enable <code>Add \"My Tags\" to the \"Comments\"</code>. Don't worry, these setting works retroactively, so you don't need to worry about wasted effort if you've already tagged tracks without this setting enabled. Please see the setup guide for more info.</p> <p>Because \"other\" tags are user-defined and highly subjective, there's not a lot I can say about how they should be designed in general, but I can offer some insight about the specific tags I'm using and my experience establishing these as my tags.</p> <p>The group of <code>My Tags</code> that I've found the most useful are my \"Vibes\" tags. As the name suggests, these describe the prominent vibes of a track. Every track in my collection can be described by at least one of these but are often described by some combination of them. Some of the most vibe-rich tracks in my collection are described by as many as 8 of these:</p> <ul> <li>Aggro, Atmospheric, Bounce, Dark, Deep, Gangsta, Groovy, Heavy, Hypnotic, Melancholy, Melodic, Rave, Strange, Uplifting</li> </ul> <p>In terms of my process for establishing the \"Vibes\" tags, I experienced issues both with having too many tags and also not having enough tags. I would recommend to anyone doing something similar to error on the side having too many tags. It's very easy to find tracks with tags you want to get rid of and re-tag that subset. Comparatively, it's very difficult to find the tracks that ought to have a new tag you're wanting to introduce after the fact. This likely will lead to the need to again go through your entire collection to determine if a new tag is applicable.</p>"},{"location":"conceptual_guides/tagging_guide/#ratings-as-energy-levels","title":"Ratings as Energy Levels","text":"<p><code>djtools</code> parses the rating field as integers from <code>0</code> through <code>5</code> and the playlist builder permits users to express these as numerical selectors. In effect, you can target sections of your library by their energy level. For example, you can make a folder of House tracks grouped by low, medium, and high energy levels:</p> <pre><code>    - name: House Energies\n    playlists:\n        - name: Low\n          tag_content: \"House &amp; [1-2]\"\n        - name: Medium\n          tag_content: \"House &amp; [3]\"\n        - name: High\n          tag_content: \"House &amp; [4-5]\"\n</code></pre> <p>On my first attempt at encoding energy levels for my tracks, I made the mistake of scaling the energy level using my entire collection. As a result, tracks in genres that have higher energy levels (think \"Brostep\" or \"Neurofunk\") would all be 4 or 5 stars while tracks in genres that have lower energy levels (think \"Ambient\" or \"Deep House\") would all have 1 or 2 stars.</p> <p>On my second attempt at encoding energy levels, I had much more success using the genre tags to normalize energy levels. So the average \"Deep House\" track has 3 stars and the average \"Brostep\" track also has 3 stars. This way, when mixing, I can use the context of what style of music I'm mixing to interpret the energy level relative to other tracks that are likely to be mixed together.</p>"},{"location":"conceptual_guides/tagging_guide/#footnotes","title":"Footnotes","text":"<p>I decided to cover genre, other, and rating tags here because they are the most useful fields for me.</p> <p>Keep the points made here in mind regardless of which fields you use for encoding information because tagging is inherently a time-consuming exercise and I believe these tips will help reduce wasted effort.</p> <p>Also, please consult the documentation on building tag playlists and Combiner playlists to better understand how <code>djtools</code> uses your tracks' tags to automatically build playlists. It may help you in determining what schemas you want to apply to your library.</p>"},{"location":"developer_docs/","title":"Developer Documentation","text":"<ul> <li>System Overview</li> <li>Adding DJ Software Support to the Collections Package</li> <li>Using the Collections API</li> <li>Adding Custom PlaylistFilters</li> </ul>"},{"location":"developer_docs/collections_api/","title":"Using the Collections API","text":"<p>Interacting with your collection is easy using the API provided by implementations of <code>Collection</code>, <code>Track</code>, and <code>Playlist</code>. For a complete description of the methods these classes provide, please see the references. What follows is more of a list of examples to demonstrate how quick and useful interactive collection manipulations can be. </p> <p>To load a collection, instantiate the class associated with the format of the serialized collection passed as a parameter:</p> <pre><code>collection = RekordboxCollection(\"/path/to/rekordbox.xml\")\n</code></pre> <p>After you're done working with your collection, you can serialize it back into a format that you can perhaps import from or use as input to other scripts:</p> <pre><code>output_xml = collection.serialize(\"test_rekordbox.xml\")\n</code></pre> <p>Once deserialized, you can manipulate the tracks and playlists in your collection in a variety of ways.</p> <p>For example, you can filter tracks to create new playlists.</p> <p>Below are a few snippets demonstrating how new playlists can be created that target tracks with non-integer BPMs, have BPMs that don't agree with beat grid data,  or are WAV files.</p> <pre><code>collection.add_playlist(\n    RekordboxPlaylist.new_playlist(\n        \"Non-integer BPMs\",\n        tracks={k: v for k, v in collection.get_tracks().items() if not v.get_bpm().is_integer()}\n    )\n)\n</code></pre> <pre><code>collection.add_playlist(\n    RekordboxPlaylist.new_playlist(\n        \"Goofy BPMs\",\n        tracks={\n            k: v for k, v in collection.get_tracks().items()\n            if v.get_bpm().is_integer() and\n            len(v._beat_grid) &gt; 0 and\n            abs(sum([float(x[\"Bpm\"]) for x in v._beat_grid]) / len(v._beat_grid) - v.get_bpm()) &gt; 1\n        }\n    )\n)\n</code></pre> <pre><code>collection.add_playlist(\n    RekordboxPlaylist.new_playlist(\n        \"wavs\",\n        tracks={\n            k: v for k, v in collection.get_tracks().items()\n            if str(v.get_location()).endswith(\".wav\")\n        }\n    )\n)\n</code></pre> <p>Apart from adding playlists, you can also create new collections with subsets of your collection's tracks.</p> <p>For example, you may have a script that operates on collections and you want to ensure that only techno tracks are operated upon. To do this you might have your collection only contain tracks where the word \"techno\" appears in their path:</p> <pre><code>collection.set_tracks(\n    tracks={\n        track_id: track for track_id, track in collection.get_tracks().items()\n        if \"techno\" in str(track.get_location().parent).lower()\n    }\n)\n</code></pre>"},{"location":"developer_docs/new_collections/","title":"Adding DJ Software Support to the Collections Package","text":""},{"location":"developer_docs/new_collections/#contents","title":"Contents","text":"<ul> <li>Overview</li> <li>Collections</li> <li>Tracks</li> <li>Playlists</li> <li>Appendix: Rekordbox as an example<ul> <li>RekordboxCollection</li> <li>RekordboxTrack</li> <li>RekordboxPlaylist</li> </ul> </li> </ul>"},{"location":"developer_docs/new_collections/#overview","title":"Overview","text":"<p>The <code>collection</code> package is designed to work with any serialized DJ collection that contains all the information about tracks and playlists. Each of these three components, <code>Collection</code>, <code>Playlist</code>, and <code>Track</code>, has an interface with which <code>djtools</code> uses to implement these features.</p> <p>In order to extend <code>djtools</code> so that these features can be used for other DJ platforms (Denon, Serato, Traktor, Virtual DJ, etc.), these three components must be subclassed to implement several abstract methods. </p>"},{"location":"developer_docs/new_collections/#collections","title":"Collections","text":"<p>Every <code>Collection</code> subclass must implement an <code>__init__</code> that accepts a <code>pathlib.Path</code> (or a <code>str</code> if you decorate it with <code>@make_path</code>). The <code>__init__</code> must deserialize the <code>Track</code> and <code>Playlist</code> data under the <code>Path</code> to create a <code>Collection</code> object.</p> <p>The other method a <code>Collection</code> must implement is <code>serialize</code> which will write the <code>Collection</code> data in whatever format is native for that DJ platform and return the <code>Path</code> to it.</p> <p>Subclasses of <code>Collection</code> inherit a few methods necessary to execute on the <code>djtools</code> feature set:</p>"},{"location":"developer_docs/new_collections/#appending-a-playlist-object-to-the-root-playlist","title":"Appending a <code>Playlist</code> object to the root <code>Playlist</code>:","text":""},{"location":"developer_docs/new_collections/#getting-the-root-playlist-or-if-a-name-is-provided-the-list-of-playlist-objects-with-matching-names-supports-fuzzy-matching-with-the-glob-parameter","title":"Getting the root <code>Playlist</code> or, if a <code>name</code> is provided, the list of <code>Playlist</code> objects with matching names (supports fuzzy matching with the <code>glob</code> parameter):","text":""},{"location":"developer_docs/new_collections/#getting-the-dictionary-mapping-track-ids-to-track-objects","title":"Getting the dictionary mapping track IDs to <code>Track</code> objects:","text":""},{"location":"developer_docs/new_collections/#set-the-dictionary-mapping-track-ids-to-track-objects","title":"Set the dictionary mapping track IDs to <code>Track</code> objects:","text":""},{"location":"developer_docs/new_collections/#get-a-dictionary-with-the-sorted-set-of-genre-tags-and-non-genre-tags","title":"Get a dictionary with the sorted set of genre tags and non-genre tags:","text":""},{"location":"developer_docs/new_collections/#tracks","title":"Tracks","text":"<p>Subclasses of the <code>Track</code> class have 16 abstract methods to be implemented, but 14 of those methods are simple getters or setters. The two primary abstract methods are, again, <code>__init__</code> and <code>serialize</code>.</p> <p>The requirements for a <code>Track</code> subclass' initialization are only that it parses from the input object the dozen or so attributes that the other abstract methods either get or set:</p> <p>A <code>Track</code> subclass must implement a <code>serialize</code> which returns an exact match of the input object used with <code>__init__</code>. In other words, it must be the case that <code>input == Track(input).serialize()</code>:</p> <p>Let's not enumerate the many getter and setters of the <code>Track</code> object here, but you can check them out for yourself:</p>"},{"location":"developer_docs/new_collections/#playlists","title":"Playlists","text":"<p>A subclass of the <code>Playlist</code> class must implement five abstract methods for working with a recursive playlist structure. Like the other components of a collection, the <code>Playlist</code> class also requires an <code>__init__</code> and <code>serialize</code> implementation.</p> <p>The <code>__init__</code> method must take an input that's either a playlist folder or a playlist that contains tracks:</p> <p>As with <code>Track</code>, <code>Playlist</code> subclasses must implement a <code>serialize</code> which returns an exact match of the input object used with <code>__init__</code>. In other words, it must be the case that <code>input == Playlist(input).serialize()</code>:</p> <p>The other abstract methods that must be implemented are:</p> <p>The <code>get_name</code> and the <code>is_folder</code> methods are a simple getter and condition check:</p> <p>A class method called <code>new_playlist</code> which can create a <code>Playlist</code> object from either a list of <code>Playlist</code> objects or a dictionary of <code>Track</code> objects:</p>"},{"location":"developer_docs/new_collections/#appendix","title":"Appendix","text":""},{"location":"developer_docs/new_collections/#rekordbox-as-an-example","title":"Rekordbox as an example","text":""},{"location":"developer_docs/new_collections/#rekordboxcollection","title":"RekordboxCollection","text":"<p>Rekordbox supports exporting a collection to an XML file which contains two primary sections: a COLLECTION tag with TRACK tags, and a PLAYLISTS tag with NODE tags with either more NODE tags or TRACK tags that have a key referencing the COLLECTION TRACKS. A minimal example XML can be seen in the test data.</p> <p>The <code>RekordboxCollection</code> implements <code>__init__</code> by parsing the XML with BeautifulSoup, deserializing the tracks as a dictionary of <code>RekordboxTrack</code> objects, and deserializing the playlists into the root node of a <code>RekordboxPlaylist</code> tree:</p> <p>The <code>serialize</code> method of <code>RekordboxCollection</code> builds a new XML document, populates the COLLECTION tag by serializing the values of the <code>RekordboxTrack</code> dictionary, and then populates the PLAYLISTS tag by iterating the root <code>RekordboxPlaylist</code> and serializing its children:</p>"},{"location":"developer_docs/new_collections/#rekordboxtrack","title":"RekordboxTrack","text":"<p>A track in an XML contains all the information about tracks except for what playlists they belong to. This information is stored directly in the attributes of the TRACK tag with the exception of the beat grid and hot cue data which are represented as sub-tags TEMPO and POSITION_MARK, respectively.</p> <p>The <code>RekordboxTrack</code> implements <code>__init__</code> by enumerating the attributes of the input Track tag and deserializing the string values as types that are more useful in Python, such as <code>datetime</code> objects, <code>lists</code>, <code>sets</code>, and numerical values:</p> <p>The <code>serialize</code> method of <code>RekordboxTrack</code> builds a new XML tag for a TRACK and populates the attributes of that tag using the <code>RekordboxTrack</code> members. Because Rekordbox serializes TRACK tags inside of the PLAYLISTS differently, this method accepts a parameter to indicate that the <code>RekordboxTrack</code> should serialize containing only its ID:</p>"},{"location":"developer_docs/new_collections/#rekordboxplaylist","title":"RekordboxPlaylist","text":"<p>A playlist in an XML is a NODE tag which is a recursive structure that contains other NODE tags. The leaves of this tree are NODE tags which contain only TRACK tags with just a single attribute, KEY, which maps to the TrackID attribute of the TRACK tags under the COLLECTION tag.</p> <p>NODE tags also have attributes for the Name and Type (folder or not) and either a Count or an Entries attribute which has the number of playlists or number of tracks, respectively.</p> <p>The <code>__init__</code> method deserializes a NODE tag by either recursively deserializing its children NODE tags (if it's a folder) or else creating a dictionary of tracks from <code>RekordboxCollection</code> object's tracks passed as a parameter:</p> <p>The <code>new_playlist</code> method creates a new Node tag and deserializes it as a <code>RekordboxPlaylist</code> before setting its members with either a <code>RekordboxTrack</code> dictionary or a list of <code>RekordboxPlaylist</code> objects:</p> <p>The <code>serialize</code> method of <code>RekordboxPlaylist</code> builds a new XML tag for a NODE and populates the attributes and sub-tags recursively:</p>"},{"location":"developer_docs/playlist_filters/","title":"PlaylistFilters","text":"<p>When creating playlists, the <code>playlist_builder</code> calls <code>filter_tag_playlists</code> with a configurable list of <code>PlaylistFilter</code> implementations:</p> Source code in <code>src/djtools/collection/helpers.py</code> <pre><code>def filter_tag_playlists(\n    playlist: Playlist, playlist_filters: List[PlaylistFilter]\n) -&gt; None:\n    \"\"\"Applies a list of PlaylistFilter implementations to the playlist.\n\n    If the PlaylistFilter implementations' is_filter_playlist method evaluates\n    to True, then the filter_track method is applied to each track in the\n    playlist. The playlist's tracks are set to remove the tracks that have been\n    filtered out.\n\n    Args:\n        playlist: Playlist to potentially have its tracks filtered.\n        playlist_filters: A list of PlaylistFilter implementations used to\n            filter playlist tracks.\n    \"\"\"\n    # This is a folder so filter its playlists.\n    if playlist.is_folder():\n        for _playlist in playlist:\n            filter_tag_playlists(_playlist, playlist_filters)\n        return\n\n    # Apply each PlaylistFilter to this playlist.\n    for playlist_filter in playlist_filters:\n        if not playlist_filter.is_filter_playlist(playlist):\n            continue\n        playlist.set_tracks(\n            tracks={\n                track_id: track\n                for track_id, track in playlist.get_tracks().items()\n                if playlist_filter.filter_track(track)\n            },\n        )\n</code></pre> <p>These <code>PlaylistFilters</code> inject custom behavior into the <code>playlist_builder</code>. In general, this is done by scanning through a playlist structure and looking for a playlist, or playlists, that match some description and then filter for tracks that match another description.</p> Source code in <code>src/djtools/collection/playlist_filters.py</code> <pre><code>class PlaylistFilter(ABC):\n    \"This class defines an interface for filtering tracks from playlists.\"\n\n    @abstractmethod\n    def filter_track(self, track: Track) -&gt; bool:\n        \"\"\"Returns True if this track should remain in the playlist.\n\n        Args:\n            track: Track object to apply filter to.\n\n        Returns:\n            Whether or not this track should be included in the playlist.\n        \"\"\"\n\n    @abstractmethod\n    def is_filter_playlist(self, playlist: Playlist) -&gt; bool:\n        \"\"\"Returns True if this playlist should be filtered.\n\n        Args:\n            playlist: Playlist object to potentially filter.\n\n        Returns:\n            Whether or not to filter this playlist.\n        \"\"\"\n</code></pre> <p><code>PlaylistFilter</code> subclasses must implement two methods:</p> <ul> <li><code>is_filter_playlist</code>: returns <code>True</code> if a given <code>Playlist</code> should have the filter applied to its tracks</li> <li><code>filter_track</code>: returns <code>True</code> if a track should remain in the playlist after applying the filter.</li> </ul> <p>Once a <code>PlaylistFilter</code> is implemented, it must be added to the list of supported <code>collection_playlist_filters</code>:</p> Source code in <code>src/djtools/collection/config.py</code> <pre><code>class CollectionConfig(BaseConfigFormatter):\n    \"\"\"Configuration object for the collection package.\"\"\"\n\n    collection_path: Optional[Path] = None\n    collection_playlist_filters: List[PlaylistFilters] = []\n    collection_playlists: bool = False\n    collection_playlists_remainder: PlaylistRemainder = (\n        PlaylistRemainder.FOLDER\n    )\n    copy_playlists: List[str] = []\n    copy_playlists_destination: Optional[Path] = None\n    minimum_combiner_playlist_tracks: Optional[PositiveInt] = None\n    minimum_tag_playlist_tracks: Optional[PositiveInt] = None\n    platform: RegisteredPlatforms = RegisteredPlatforms.REKORDBOX\n    shuffle_playlists: List[str] = []\n    playlist_config: Optional[\"PlaylistConfig\"] = None\n\n    def __init__(self, *args, **kwargs):\n        \"\"\"Constructor.\n\n        Raises:\n            RuntimeError: Using the collection package requires a valid\n                collection_path.\n            RuntimeError: Failed to render collection_playlist.yaml from\n                template.\n            RuntimeError: collection_path must be a valid collection path.\n            RuntimeError: collection_playlists.yaml must be a valid YAML file.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n\n        if any(\n            [\n                self.collection_playlists,\n                self.copy_playlists,\n                self.shuffle_playlists,\n            ]\n        ) and (not self.collection_path or not self.collection_path.exists()):\n            raise RuntimeError(\n                \"Using the collection package requires the config option \"\n                \"collection_path to be a valid collection path\"\n            )\n\n        if self.collection_playlists:\n            config_path = Path(__file__).parent.parent / \"configs\"\n            env = Environment(\n                loader=FileSystemLoader(config_path / \"playlist_templates\")\n            )\n            playlist_template = None\n            playlist_template_name = \"collection_playlists.j2\"\n            playlist_config_path = config_path / \"collection_playlists.yaml\"\n\n            try:\n                playlist_template = env.get_template(playlist_template_name)\n            except TemplateNotFound:\n                pass\n\n            if playlist_template:\n                try:\n                    playlist_config = playlist_template.render()\n                except Exception as exc:\n                    raise RuntimeError(\n                        f\"Failed to render {playlist_template_name}: {exc}\"\n                    ) from exc\n\n                if playlist_config_path.exists():\n                    logger.warning(\n                        f\"Both {playlist_template_name} and \"\n                        f\"{playlist_config_path.name} exist. Overwriting \"\n                        f\"{playlist_config_path.name} with the rendered \"\n                        \"template\"\n                    )\n\n                with open(\n                    playlist_config_path, mode=\"w\", encoding=\"utf-8\"\n                ) as _file:\n                    _file.write(playlist_config)\n\n            if not playlist_config_path.exists():\n                raise RuntimeError(\n                    \"collection_playlists.yaml must exist to use the \"\n                    \"collection_playlists feature\"\n                )\n\n            try:\n                with open(\n                    playlist_config_path, mode=\"r\", encoding=\"utf-8\"\n                ) as _file:\n                    self.playlist_config = PlaylistConfig(\n                        **yaml.load(_file, Loader=yaml.FullLoader) or {}\n                    )\n            except ValidationError as exc:\n                raise RuntimeError(\n                    \"collection_playlists.yaml must be a valid YAML to use \"\n                    \"the collection_playlists feature\"\n                ) from exc\n</code></pre>"},{"location":"developer_docs/playlist_filters/#playlistfilter-implementations","title":"PlaylistFilter Implementations","text":"<p>The <code>playlist_filters</code> module contains the following set of <code>PlaylistFilter</code> implementations: - <code>HipHopFilter</code> - <code>MinimalDeepTechFilter</code> - <code>TransitionTrackFilter</code> - <code>ComplexTrackFilter</code></p>"},{"location":"developer_docs/playlist_filters/#hiphopfilter","title":"HipHopFilter","text":"<ul> <li>Checks to see if a playlist named 'Hip Hop' is a child of a playlist named 'Bass'</li> <li>If it is, then tracks in that playlist must have a genre tag besides 'Hip Hop' and 'R&amp;B'</li> <li>If it is not, then tracks in that playlist must have only genre tags 'Hip Hop' and 'R&amp;B'</li> </ul>"},{"location":"developer_docs/playlist_filters/#minimaldeeptechfilter","title":"MinimalDeepTechFilter","text":"<ul> <li>Checks to see if a playlist named 'Minimal Deep Tech' is a child of a playlist named 'Techno' or 'House'</li> <li>If it's a child of a 'Techno' playlist, then at least one other genre tag must contain the substring 'techno' (case insensitive)</li> <li>If it's a child of a 'House' playlist, then at least one other genre tag must contain the substring 'house'</li> </ul>"},{"location":"developer_docs/playlist_filters/#complextrackfilter","title":"ComplexTrackFilter","text":"<ul> <li>Checks to see if the playlist, or a parent playlist, contains the substring 'complex' </li> <li>Filters tracks that contain fewer than a set number of tags (only includes \"other\" tags, does not include genre tags)</li> <li>When instantiated, <code>ComplexTrackFilter</code> takes optional arguments for the <code>minimum_tags_for_complex_track</code> as well as the list of <code>exclude_tags</code> which may not count towards the total number of tags</li> </ul>"},{"location":"developer_docs/playlist_filters/#transitiontrackfilter","title":"TransitionTrackFilter","text":"<ul> <li>Checks to see if the playlist, or a parent playlist, contains the substring 'transition' </li> <li>Checks to see if the playlist contains one, and only one, of the substrings 'genre' or 'tempo'</li> <li>Filters tracks that contain a special annotation in their comments field</li> <li>The expected annotation must match the following syntax <code>[ token1 / token2]</code> where a <code>token</code> must be strings if it's a 'genre' transition playlist or numbers if it's a 'tempo' transition playlist</li> </ul>"},{"location":"developer_docs/system_overview/","title":"System Overview","text":""},{"location":"developer_docs/system_overview/#contents","title":"Contents","text":"<ul> <li>djtools as a CLI</li> <li>djtools as a Library</li> <li>CI</li> </ul>"},{"location":"developer_docs/system_overview/#djtools-as-a-cli","title":"djtools as a CLI","text":"<p><code>djtools</code> is a set of packages that provide functional interfaces to streamline tasks.</p> <p>Although there are parts of <code>djtools</code>, like the collection package, that are designed to operate interactively, <code>djtools</code> is primarily intended to be used as a CLI.</p> <p>In a nutshell, the main function of <code>djtools</code> builds  a configuration, iterates through the top-level operations exported by each package, and executes those operations as determined by the configuration.</p> <p>When building the configuration, <code>djtools</code> first looks for a config.yaml in the configs folder from which to load the configuration objects. If no config file is found, default values defined in the Pydantic models are used. If CLI arguments are provided, they override the corresponding configuration options:</p> Source code in <code>src/djtools/configs/helpers.py</code> <pre><code>@make_path\ndef build_config(\n    config_file: Path = Path(__file__).parent / \"config.yaml\",\n) -&gt; BaseConfig:\n    \"\"\"This function loads configurations for the library.\n\n    Configurations are loaded from config.yaml. If command-line arguments are\n    provided, these override the configuration options set in config.yaml.\n\n    Args:\n        config_file: Optional path to a config.yaml.\n\n    Raises:\n        RuntimeError: config.yaml must be a valid YAML.\n\n    Returns:\n        Global configuration object.\n    \"\"\"\n    # Create a default config if one doesn't already exist.\n    if not config_file.exists():\n        with open(config_file, mode=\"w\", encoding=\"utf-8\") as _file:\n            yaml.dump(BaseConfig().model_dump(), _file)\n\n    # Load the config.\n    try:\n        with open(config_file, mode=\"r\", encoding=\"utf-8\") as _file:\n            config_data = yaml.load(_file, Loader=yaml.FullLoader) or {}\n        config = BaseConfig(**config_data)\n    except Exception as exc:\n        msg = f\"Error reading config file {config_file}: {exc}\"\n        logger.critical(msg)\n        raise ConfigLoadFailure(msg) from exc\n\n    entry_frame_filename = inspect.stack()[-1][1]\n    valid_filenames = (\n        str(Path(\"bin\") / \"djtools\"),  # Unix djtools.\n        str(Path(\"bin\") / \"pytest\"),  # Unix pytest.\n        str(Path(\"lib\") / \"runpy.py\"),  # Windows Python&lt;=3.10.\n        \"&lt;frozen runpy&gt;\",  # Windows Python&gt;=3.11.\n    )\n\n    # Only get CLI arguments if calling djtools as a CLI.\n    if entry_frame_filename.endswith(valid_filenames):\n        cli_args = {\n            k: v for k, v in _arg_parse().items() if v or isinstance(v, list)\n        }\n        logger.info(f\"Args: {cli_args}\")\n        config = _update_config_with_cli_args(config, cli_args)\n\n    return config\n</code></pre> <p>At the end of config building, a <code>BaseConfig</code> object containing the union of the package configs' options is returned. The top-level operations exported by the different <code>djtools</code> packages all take a <code>BaseConfig</code> object as an argument.</p>"},{"location":"developer_docs/system_overview/#djtools-as-a-library","title":"djtools as a Library","text":"<p>The <code>djtools</code> library is organized into 5 packages:</p> <ul> <li><code>configs</code></li> <li><code>collection</code></li> <li><code>spotify</code></li> <li><code>sync</code></li> <li><code>utils</code></li> </ul> <p>Each of the packages <code>collection</code>, <code>spotify</code>, <code>sync</code>, and <code>utils</code> export the module functions that implement the top-level features of <code>djtools</code>.</p> <p>Additionally, the <code>configs</code> package exports <code>build_config</code> which generates the <code>BaseConfig</code> object that must be passed into all of the other exported functions.</p> <p>The exception are the <code>*Collection</code>, <code>*Playlist</code>, and <code>*Track</code> classes exported from the <code>collection</code> package. These are exported as a convenience for interactive collection manipulation in a Python interpreter.</p> <p>Note that, while <code>build_config</code> accepts an optional path to a <code>config.yaml</code>, features that interact with the other YAML configs (<code>collection_playlists.yaml</code> and <code>spotify_playlists.yaml</code>) still reference those config paths relative to the source.</p>"},{"location":"developer_docs/system_overview/#ci","title":"CI","text":"<p>There are several GitHub Actions bound to the lifecycle of <code>djtools</code>.</p> <p>The pytest-coverage and pylint workflows are triggered on pull request events. Passing both of these workflows is a check for merges into release branches or <code>main</code>. A pass rate of 100% is required.</p> <p>On pushes to <code>release/**</code> branches, changes to <code>pyproject.toml</code> or <code>.py</code> files trigger the release-dev workflow which performs a pre-release version bump and wheel release. Changes to <code>.md</code> files trigger the deploy-dev-docs workflow which copies files to a shadow repository and deploys docs on that repo's GitHub Pages.</p> <p>On pushes to <code>main</code>, the release-prod and deploy-prod-docs workflows are triggered which perform essentially the same steps as the equivalent dev workflows except the version is finalized instead of bumped and the docs are deployed on the main repository's GitHub Pages. </p>"},{"location":"how_to_guides/","title":"How-to Guides","text":""},{"location":"how_to_guides/#collection","title":"Collection","text":"<ul> <li>Build Playlists From Tags</li> <li>Combine Playlists With Boolean Algebra</li> <li>Copy Tracks From Playlists</li> <li>Shuffle Tracks in Playlists</li> </ul>"},{"location":"how_to_guides/#spotify","title":"Spotify","text":"<ul> <li>Setup Reddit &amp; Spotify API Access</li> <li>Create Spotify Playlists From Other Users' Uploads</li> <li>Create Spotify Playlists From Reddit Posts</li> </ul>"},{"location":"how_to_guides/#sync","title":"Sync","text":"<ul> <li>Setup Object Storage For Syncing Files</li> <li>Sync Files with the Beatcloud</li> <li>Sync Tracks From Spotify Playlists</li> </ul>"},{"location":"how_to_guides/#utils","title":"Utils","text":"<ul> <li>Check the Beatcloud for Tracks in Spotify Playlists or Local Directories</li> <li>Extract Audio Files From URLs</li> <li>Process Recorded Files Using Spotify Playlists</li> <li>Standardize Audio Files</li> </ul>"},{"location":"how_to_guides/check_beatcloud/","title":"Check the Beatcloud for Tracks in Spotify Playlists or Local Directories","text":"<p>In this guide you will learn how to compare the contents of one or more Spotify playlists and / or one or more local directories with the contents of the Beatcloud in order to identify redundancies.</p>"},{"location":"how_to_guides/check_beatcloud/#prerequisites","title":"Prerequisites","text":"<ul> <li>Setup Object Storage For Syncing Files</li> <li>Setup API access for Spotify and Reddit</li> </ul>"},{"location":"how_to_guides/check_beatcloud/#why-check-the-beatcloud-against-spotify-playlists-and-or-local-directories","title":"Why check the Beatcloud against Spotify playlists and / or local directories?","text":"<p>When managing a shared collection of tracks across multiple users, it can become difficult to ensure that the same tracks aren't being added to the Beatcloud again and again.</p> <p>Some users, such as myself, use Spotify playlists to discover new tracks and incubate on them to determine if they're worth incorporating into my collection. I can save myself the effort of considering tracks if I can determine ahead of time that they already exist in the Beatcloud.</p> <p>Once tracks are acquired, it may be necessary to compare a location on my computer containing those tracks with the Beatcloud to be sure they don't exist prior to running <code>--upload-music</code>.</p>"},{"location":"how_to_guides/check_beatcloud/#how-its-done","title":"How it's done","text":"<ol> <li>If using the <code>check_tracks_spotify_playlists</code> option, ensure that the playlist names configured for that option exist as <code>playlist name: playlist ID</code> mappings in <code>spotify_playlists.yaml</code><ul> <li>you'll have to add these manually (grab the playlist ID from the URL when opening the playlist in the browser or from the link copied when sharing a playlist in the app)</li> <li>playlist names don't necessarily have to match the actual name of the playlist...they're just used to lookup the IDs when configuring <code>utils</code> options</li> </ul> </li> <li>Configure <code>check_tracks_spotify_playlists</code> and / or <code>local_dirs</code> to contain the playlist names and / or absolute paths, respectively, to the tracks you want to compare with the Beatcloud</li> <li>If your files are stored in the Beatcloud using the format <code>Artist1, Artist2 - Title (Artist2 Remix)</code> instead of the default <code>Title (Artist2 Remix) - Artist1, Artist2</code>, make sure you set <code>artist_first</code> to <code>true</code> (see Configuration for more detail)<ul> <li>Note that you can temporarily set <code>artist_first</code> to <code>true</code> when running with <code>local_dirs</code>, even if your Beatcloud tracks are not stored in the <code>artist_first</code> format, in order to compare against local tracks that do adhere to the <code>artist_first</code> format</li> </ul> </li> <li>Run the command <code>djtools --check-tracks</code></li> </ol>"},{"location":"how_to_guides/check_beatcloud/#example","title":"Example","text":"<p>To begin, make sure the Spotify playlists you're targeting with this feature have entries in <code>spotify_playlists.yaml</code>:</p> <pre><code>Maybe Download: 7zh4Lru54fGrBUwgOU1G6f\nTodays Beats: 5R90HSqiP6oIY8jPFgki4h\n</code></pre> <p>Configure <code>check_tracks_spotify_playlists</code> and <code>local_dirs</code> to so they point to the playlists and local directories you want to use for comparison:</p> <pre><code>check_tracks_spotify_playlists:\n    - Todays Beats\n    - Maybe Download\nlocal_dirs:\n    - /Users/aweeeezy/Downloads/New Music\n</code></pre> <p>After running the command, I can determine by the console output that I have no overlapping tracks between my local directory and the Beatcloud, but I do have a track in my \"Today's Beats\" Spotify playlist that matches 100% with \"Zodd's Hunger - Noer the Boy\" in my Beatcloud instance:</p> <pre><code>check_tracks\nGot 7 track from Spotify playlist \"Maybe Download\"\nGot 9 tracks from Spotify playlist \"Todays Beats\"\nGot 16 tracks from Spotify in total\nGot 22 files under local directories\nGot 4025 tracks from the beatcloud\nMatching new and Beatcloud tracks: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 132726/132726 [00:00&lt;00:00, 751116.76it/s]\nSpotify Playlist Tracks / Beatcloud Matches: 1\nTodays Beats:\n   100: Zodd's Hunger - Noer the Boy | Zodd's Hunger - Noer the Boy\nMatching new and Beatcloud tracks: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 88484/88484 [00:00&lt;00:00, 882570.40it/s]\nLocal Directory Tracks / Beatcloud Matches: 0\n</code></pre>"},{"location":"how_to_guides/collection_playlists/","title":"Build Playlists From Tags","text":"<p>In this guide you will learn how to automatically build playlists based off of the information encoded in the various tag attributes of the tracks in your Collection.</p>"},{"location":"how_to_guides/collection_playlists/#prerequisites","title":"Prerequisites","text":"<ul> <li>Rekordbox settings</li> <li>Get to Know Your Rekordbox Collection</li> </ul>"},{"location":"how_to_guides/collection_playlists/#why-build-playlists-from-tags","title":"Why build playlists from tags?","text":"<p>It's not uncommon, while mixing, to navigate playlists that contain tracks similar to the one currently playing. For most users, these playlists are painstakingly constructed to capture these similarities. For the wiser user, this process is made a little bit easier by extensive use of tagging.</p> <p>If a user diligently tags their Collection using, say, the <code>Genre</code> tag, they then have the ability to search individual genres and create playlists based on the results of those searches. Unfortunately, this strategy has several shortcomings:</p> <ul> <li>The manual process of moving tracks into playlists can be both time consuming and error prone</li> <li>Having a change of heart with respect to the genre that a particular track belongs to means that that track must be removed from some existing playlist(s) and added to some different playlist(s)</li> <li>Searching, for example, \"Techno\" will show not only tracks that contain the word \"techno\" in their <code>Genre</code> tag but also any track that has any mention of the word \"techno\" associated with it (like a dubstep track whose title is \"This track is not techno\")</li> </ul> <p>The collection_playlists feature solves all of these issues! It allows the wisest of users to configure a YAML file with a specification of arbitrary folders and playlists. The playlists' names match the tags that exist in your Collection.</p>"},{"location":"how_to_guides/collection_playlists/#how-its-done","title":"How it's done","text":"<ol> <li>Configure your desired playlist structure(s) for <code>tags</code></li> <li>Run the command <code>--collection-playlists</code></li> <li>Import the <code>PLAYLIST_BUILDER</code> folder from the generated collection</li> </ol>"},{"location":"how_to_guides/collection_playlists/#example","title":"Example","text":"<p>Let's start by examining the pre-packaged YAML file collection_playlists.yaml: </p> <p>You can ignore the <code>combiner</code> part of the YAML for now. Although it's similar to the <code>tags</code> section, it's covered in the Combine Playlists With Boolean Algebra how-to guide.</p> <p>The configuration above specifies a set of <code>name</code> folders with lists of playlists and / or folders inside of them. The leaves of this playlist tree are the actual playlists themselves named after the tag that the playlist will contain tracks for. Note that you can reference the same tag multiple times.</p> <p>While not pictured above, the <code>playlist_builder</code> supports configuring the names of playlists if you'd like them to be something other than the tag used to create them. For example, users may provide a map containing the <code>tag_content</code> field, which specifies the tag to use, and an optional <code>name</code> field to override the actual name of the playlist. Note that if <code>name</code> is not provided, <code>tag_content</code> will be used as the playlist name. Here's an example of overriding the name of a Hard Techno playlist to be \"Techno that is hard\":</p> <pre><code>    - tag_content: Hard Techno\n      name: Techno that is hard\n</code></pre> <p>Another config option that's not shown in the picture above is <code>enable_aggregation</code>. Every folder with this option set to <code>true</code> will create an implicit playlist called <code>All &lt;folder name&gt;</code> which aggregates the tracks from all the playlists within that folder. For example, my <code>Techno</code> folder will have a playlist called <code>All Techno</code> which contains the union of tracks between <code>Hard Techno</code> and <code>Minimal Deep Tech</code>.</p> <p>You may only have one tag for each playlist. If you're interested in creating playlists that combine multiple tags, check out the Combiner how-to guide.</p> <p>Any tags in your Collection that are not included in the <code>collection_playlists.yaml</code> configuration file will automatically be added to either a <code>Unused Tags</code> playlist or an <code>Unused Tags</code> folder with a playlist for each tag (you can configure this behavior using <code>collection_playlists_remainder</code>).</p> <p>If there are tags for which you're not interested in creating an <code>Unused Tags</code> playlist(s) for, simply add a new folder to the tree call <code>_ignore</code> and list the tags underneath of it.</p> <p>During operation of the <code>playlist_builder</code>, after the <code>tag</code> playlists are constructed, optional <code>PlaylistFilters</code> are applied to enable special filtering. In general, each <code>PlaylistFilter</code> calls a <code>is_filter_playlist</code> method which returns <code>True</code> if the playlist should have filtering logic applied to it. For each track in the playlist, the <code>PlaylistFilter</code> method <code>filter_track</code> is called with the track and returns <code>True</code> if the track should remain in the playlist.</p> <p>You may configure which, if any, <code>PlaylistFilters</code> you want applied using the <code>collection_playlist_filters</code> option. Check the references for the current set of implemented <code>PlaylistFilters</code>.</p> <p>Finally, you may configure the option <code>minimum_tag_playlist_tracks</code> to any positive integer in order to place a lower bound on the number of tracks that must exist in a tag playlist in order for the playlist to be created.</p> <p>Once you've finalized your playlist configuration, run the following command to build the playlists:</p> <p><code>djtools --collection-playlists</code></p> <p>Now you can import the <code>PLAYLIST_BUILDER</code> folder to load these playlists into your Collection: </p>"},{"location":"how_to_guides/combiner_playlists/","title":"Combine Playlists with Boolean Algebra","text":"<p>In this guide you will learn how to automatically build playlists based off of powerful boolean algebra expressions that apply set operations to tags, playlists, and other selections of your Collection.</p>"},{"location":"how_to_guides/combiner_playlists/#prerequisites","title":"Prerequisites","text":"<ul> <li>Rekordbox settings</li> <li>Get to Know Your Rekordbox Collection</li> <li>A light review of set theory</li> </ul>"},{"location":"how_to_guides/combiner_playlists/#why-combine-playlists-with-boolean-algebra","title":"Why combine playlists with boolean algebra?","text":"<p>It may not be commonly known, but Rekordbox already has a very elementary version of this functionality called the \"Track Filter\": </p> <p>There are many shortcomings with the Track Filter which make it far inferior to the Combiner:</p> <ol> <li>Portability<ul> <li>can only be used on a laptop running Rekordbox (not available on XDJs, CDJs, etc.)</li> <li>can only be used with the master database on a laptop (friends plugging in their devices lose access to this feature)</li> </ul> </li> <li>Operands<ul> <li>only works on <code>My Tags</code>, color, rating, key, and a maximum of 6% range from a single BPM value</li> </ul> </li> <li>Operators<ul> <li>can only apply <code>AND</code> and <code>OR</code> logic</li> <li>can only apply logic to <code>My Tags</code></li> <li>can only apply one of these logic operators per grouping of <code>My Tags</code></li> </ul> </li> </ol> <p>The <code>Combiner</code> solves all these issues in the following ways:</p> <ol> <li>Portability<ul> <li>generates regular playlists which can be exported to a device for use on any system</li> </ul> </li> <li>Operands<ul> <li>works on any tag data that <code>djtools</code> knows of (e.g. genres, <code>My Tags</code>, etc.)</li> <li>includes numerical selector syntax to choose arbitrary rating, BPM, and year values as well as arbitrary ranges of those values</li> <li>includes string selector syntax to choose playlists in your Collection as well as artists, comments, dates added, keys, and record labels</li> <li>any of the string selectors (except for <code>date</code>) support wildcard globbing with the <code>*</code> character</li> </ul> </li> <li>Operators<ul> <li>adds a <code>NOT</code> operator to take the set difference</li> <li>allows you to apply logic operators to any of the operands, not just <code>My Tags</code></li> <li>allows you to construct arbitrarily complex expressions using parentheses to control the order of operations</li> </ul> </li> </ol>"},{"location":"how_to_guides/combiner_playlists/#syntax","title":"Syntax","text":"<ul> <li>logical operators (\"AND\", \"OR\", \"NOT\"):<ul> <li><code>&amp;</code></li> <li><code>|</code></li> <li><code>~</code></li> </ul> </li> <li>string selectors (not case-sensitive):<ul> <li><code>{artist:*Eprom*}</code></li> <li><code>{comment:*hollaback*}</code></li> <li><code>{date:2022}</code></li> <li><code>{date:&gt;2021-10-05}</code></li> <li><code>{date:&lt;=2020-05}</code></li> <li><code>{date:1y}</code></li> <li><code>{date:&gt;=3m}</code></li> <li><code>{date:&lt;10w5d}</code></li> <li><code>{key:7A}</code></li> <li><code>{label:duploc}</code></li> <li><code>{playlist: Deep House}</code></li> </ul> </li> <li>numerical selectors:<ul> <li><code>[0]</code></li> <li><code>[3-5]</code></li> <li><code>[80]</code></li> <li><code>[130-150]</code></li> <li><code>[1973]</code></li> <li><code>[2013-2023]</code></li> </ul> </li> <li>grouping:<ul> <li><code>(</code></li> <li><code>)</code></li> </ul> </li> </ul>"},{"location":"how_to_guides/combiner_playlists/#date-string-selectors-can-take-two-forms","title":"Date string selectors can take two forms:","text":"<ol> <li>ISO format date strings e.g. <code>2024-06-22</code>, <code>2024-06</code>, <code>2024</code></li> <li><code>ymwd</code> (year, month, week, day) format timedelta strings e.g. <code>1y</code>, <code>3m2w</code>, <code>5d</code></li> </ol> <p>Here's how playlists can be built using the different date string selector types using the examples from above. - <code>{date:2022}</code>: tracks added in the year 2022 - <code>{date:&gt;2021-10-05}</code>: track added after October 5th, 2021 - <code>{date:&lt;=2020-05}</code>: tracks added on or before May, 2020 - <code>{date:1y}</code>: tracks added exactly 1 year ago today - <code>{date:&gt;=3m}</code>: tracks added within the last 3 months - <code>{date:&lt;10w5d}</code>: tracks at least 75 days old</p>"},{"location":"how_to_guides/combiner_playlists/#lets-look-at-an-example-playlist-to-see-how-the-syntax-works","title":"Let's look at an example playlist to see how the syntax works.","text":"<p>Suppose we want a playlist with tracks that all have the following properties:</p> <ul> <li>from the years 2000 to 2023</li> <li>and have a rating of 5</li> <li>and with BPMs in the range 130 to 150</li> </ul> <p>The expression will look this:</p> <pre><code>[2000-2023] &amp; [5] &amp; [130-150]\n</code></pre> <p>Now let's say we want a playlist with tracks that have any one of the following properties:</p> <ul> <li>have a genre tag called \"Jungle\"</li> <li>or have another tag called \"Dark\"</li> <li>or come from a playlist called \"New Years 1999\"</li> <li>or come from the record label \"Dispatch\"</li> </ul> <p>The playlist for this set of tracks is expressed like this:</p> <pre><code>Jungle | Dark | {playlist: New Years 1999} | {label: Dispatch}\n</code></pre> <p>Now let's say we want to create a playlist using the other supported string selectors. We're also going to demonstrate the set difference operator <code>~</code> which will remove matching tracks from the resulting playlist. This subset of tracks will all have the following properties:</p> <ul> <li>have at least one of the artists as \"Eprom\"</li> <li>and have been added to the collection after 2010</li> <li>and have the words \"absolute banger\" in the comments</li> <li>and not have a major musical key (using Camelot notation)</li> </ul> <p>The playlist for these tracks is written like this:</p> <pre><code>{artist: *Eprom*} &amp; {date:&gt;2010} &amp; {comment:*absolute banger*} ~ {key:*A}\n</code></pre> <p>Finally, let's see how we can create one master playlist from all three of these sub-expressions using groupings to ensure the proper order of operations:</p> <pre><code>([2000-2023] &amp; [5] &amp; [130-150]) |\n(Jungle | Dark | {playlist: New Years 1999} | {label: Dispatch}) |\n({artist: *Eprom*} &amp; {date:&gt;2010} &amp; {comment:*absolute banger*} ~ {key:*A})\n</code></pre> <p>I hope you see how powerful the <code>Combiner</code> can become when used with a well indexed collection!</p>"},{"location":"how_to_guides/combiner_playlists/#templating","title":"Templating","text":"<p>Once the potential of these Combiner playlists is realized, you might find your <code>collection_playlists.yaml</code> starting to become unwieldy with many nested folders of repetitive expressions. For this reason, <code>djtools</code> supports templating out your playlist config's substructures using Jinja. <code>djtools</code> looks for a Jinja template located at <code>configs/playlist_templates/collection_playlists.j2</code> and uses it to build a <code>collection_playlist.yaml</code> at runtime. With templating, I've replaced manually maintaining a 2,300 line <code>collection_playlists.yaml</code> file with a 300 line <code>collection_playlists.j2</code>!</p> <p>Here's an example of my <code>configs</code> directory:</p> <pre><code>.\n\u251c\u2500\u2500 collection_playlists.yaml\n\u251c\u2500\u2500 config.yaml\n\u251c\u2500\u2500 playlist_templates\n\u2502   \u251c\u2500\u2500 collection_playlists.j2\n\u2502   \u2514\u2500\u2500 macros.j2\n\u2514\u2500\u2500 spotify_playlists.yaml\n</code></pre> <p>I've decided to keep the patterns I commonly use in my playlists in the <code>macros.j2</code> file and import them into my <code>collection_playlists.js2</code>. Here's what my <code>macros.j2</code> looks like:</p> <pre><code>{%- macro Vibes(var, name='') %}\n{%- set vibes = [\n  \"Aggro\", \"Atmospheric\", \"Bounce\", \"Dark\", \"Deep\", \"Gangsta\", \"Groovy\",\n  \"Heavy\", \"Hypnotic\", \"Melancholy\", \"Melodic\", \"Rave\", \"Strange\", \"Uplifting\"\n] -%}\n\nname: {{ name if name else var }}\nplaylists:\n  {%- for vibe in vibes %}\n  - name: {{ vibe }}\n    tag_content: \"{{ var }} &amp; {{ vibe }}\"\n  {%- endfor %}\n{%- endmacro %}\n\n{%- macro Genres(var, name='') %}\n{%- set genres = [\n    {\"name\": \"140ish Bass\", \"tag\": \"([130-150] &amp; {playlist:All Bass})\"},\n    {\"name\": \"4/4\", \"tag\": \"({playlist:All House} | {playlist:All Techno} | {playlist:All Trance} | {playlist:Midtempo})\"},\n    {\"name\": \"Breakbeat &amp; Garage\", \"tag\": \"({playlist:All Breakbeat} | {playlist:All Garage})\"},\n    {\"name\": \"DnB\", \"tag\": \"{playlist:All DnB}\"},\n    {\"name\": \"Hip Hop Beats (slow)\", \"tag\": \"([6-119] &amp; {playlist:All Hip Hop Beats})\"},\n    {\"name\": \"Hip Hop Beats (fast)\", \"tag\": \"([120-999] &amp; {playlist:All Hip Hop Beats})\"},\n    {\"name\": \"Other Bass\", \"tag\": \"({playlist:All Bass} ~ [130-150] ~ {playlist:All DnB} ~ {playlist:All Hip Hop Beats})\"},\n    {\"name\": \"Everything Else\", \"tag\": \"({playlist:All Bass} | {playlist:All Breakbeat} | {playlist:All Garage} | {playlist:All House} | {playlist:Midtempo} | {playlist:All Techno} | {playlist:All Trance})\"}\n] -%}\n\nname: {{ name if name else var }}\nplaylists:\n  {%- for genre in genres %}\n  - name: {{ genre.name }}\n    tag_content: \"{{ var }} &amp; {{ genre.tag }}\"\n  {%- endfor %}\n{%- endmacro %}% \n</code></pre> <p>To demonstrate how I'm using macros, I'm including a sample of my <code>collection_playlists.j2</code> -- note the use of the <code>|indent</code> filter to ensure the macros indent the content filled by the macros in order to produce valid YAML:</p> <pre><code>{%- import 'macros.j2' as macros -%}\n\ncombiner:\n  name: Combinations\n  playlists:\n    - name: Genre Vibes\n      playlists:\n        - name: DnB\n          playlists:\n            - {{ macros.Vibes(\"All DnB\")|indent(14) }}\n            - {{ macros.Vibes(\"Darkstep\")|indent(14) }}\n            - {{ macros.Vibes(\"Halftime\")|indent(14) }}\n            - {{ macros.Vibes(\"Jungle\")|indent(14) }}\n            - {{ macros.Vibes(\"Liquid Funk\")|indent(14) }}\n            - {{ macros.Vibes(\"Minimal DnB\")|indent(14) }}\n            - {{ macros.Vibes(\"Neurofunk\")|indent(14) }}\n            - {{ macros.Vibes(\"Techstep\")|indent(14) }}\n        - name: Techno\n          playlists:\n            - {{ macros.Vibes(\"All Techno\")|indent(14) }}\n            - {{ macros.Vibes(\"Pure Techno\")|indent(14) }}\n            - {{ macros.Vibes(\"Acid Techno\")|indent(14) }}\n            - {{ macros.Vibes(\"Hard Techno\")|indent(14) }}\n            - {{ macros.Vibes(\"Hardstyle\")|indent(14) }}\n            - {{ macros.Vibes(\"Industrial Techno\")|indent(14) }}\n            - {{ macros.Vibes(\"Melodic Techno\")|indent(14) }}\n            - {{ macros.Vibes(\"Minimal Deep Tech\")|indent(14) }}\n            - {{ macros.Vibes(\"Minimal Techno\")|indent(14) }}\n            - {{ macros.Vibes(\"Psytechno\")|indent(14) }}\n            - {{ macros.Vibes(\"Techno\")|indent(14) }}\n            - {{ macros.Vibes(\"Tech Trance\")|indent(14) }}\n    - name: Vibes\n      playlists:\n        - {{ macros.Genres(\"Aggro\")|indent(10) }}\n        - {{ macros.Genres(\"Atmospheric\")|indent(10) }}\n        - {{ macros.Genres(\"Bounce\")|indent(10) }}\n        - {{ macros.Genres(\"Dark\")|indent(10) }}\n        - {{ macros.Genres(\"Deep\")|indent(10) }}\n        - {{ macros.Genres(\"Gangsta\")|indent(10) }}\n        - {{ macros.Genres(\"Groovy\")|indent(10) }}\n        - {{ macros.Genres(\"Heavy\")|indent(10) }}\n        - {{ macros.Genres(\"Hypnotic\")|indent(10) }}\n        - {{ macros.Genres(\"Melancholy\")|indent(10) }}\n        - {{ macros.Genres(\"Melodic\")|indent(10) }}\n        - {{ macros.Genres(\"Rave\")|indent(10) }}\n        - {{ macros.Genres(\"Strange\")|indent(10) }}\n        - {{ macros.Genres(\"Uplifting\")|indent(10) }}\n</code></pre>"},{"location":"how_to_guides/combiner_playlists/#how-its-done","title":"How it's done","text":"<ol> <li>Configure your desired playlists for the <code>Combiner</code> by constructing a boolean algebra expression with the syntax noted above</li> <li>Run the command <code>--collection-playlists</code></li> <li>Import the <code>PLAYLIST_BUILDER</code> folder from the generated collection</li> </ol>"},{"location":"how_to_guides/combiner_playlists/#example","title":"Example","text":"<p>As is done in the Build Playlists From Tags how-to guide, we'll start by looking at some simple expressions configured in the pre-packaged collection_playlists.yaml, but this time we'll focus only on the <code>combiner</code> section:</p> <p>Note that the examples below are trivial ones designed to get 100% code coverage in unit tests.</p> <p></p> <p>The <code>combiner</code> configuration specifies a set of <code>name</code> folders with lists of playlists and / or folders inside of them. The leaves of this playlist tree are the actual playlists themselves whose names are boolean algebra expressions that use the syntax noted above to describe how different tags and selectors are to be combined to produce the final playlist of tracks. Valid expressions must contain at least two operands and must have one less operator than there are operands. </p> <p>Note that, as with the tag playlists, you may provide an override for these playlist names. This can be really helpful since combiner playlists can otherwise have very long names. Here's an example of configuring a playlist name override:</p> <pre><code>    - tag_content: \"Dubstep &amp; {date:&lt;2022} &amp; [5]\"\n      name: Pre 2022 High Energy Dubstep\n</code></pre> <p>Also note that combiner playlists, like tag playlists, support:</p> <ol> <li><code>PlaylistFilters</code></li> <li><code>enable_aggregation</code></li> <li>minimum track requirements, except use the option <code>minimum_combiner_playlist_tracks</code> instead</li> </ol> <p>Once you've finalized your playlist configuration, run the following command to build the playlists:</p> <p><code>djtools --collection-playlists</code></p> <p>Now you can import the <code>PLAYLIST_BUILDER</code> folder to load these playlists into your Collection: </p>"},{"location":"how_to_guides/copy_playlists/","title":"Copy Tracks From Playlists","text":"<p>In this guide you will learn how to copy tracks from your playlists to a new location.</p>"},{"location":"how_to_guides/copy_playlists/#prerequisites","title":"Prerequisites","text":"<ul> <li>Rekordbox settings</li> <li>Get to Know Your Rekordbox Collection</li> </ul>"},{"location":"how_to_guides/copy_playlists/#why-copy-playlists","title":"Why copy playlists?","text":"<p>Have you ever compiled a playlist for an event and wanted to make a backup USB that has specifically this playlist on it? Have you ever wanted to share a playlist with a wedding DJ you've hired or with a friend you're planning a back-to-back with?</p> <p>For users who keep their music collection separate from their USB devices, achieving this is as simple as exporting to the new device; but what if your USB is your master database as well?</p> <p>In these types of situations, you'd normally have to trace the location of the audio files for each track in your playlist(s) and copy them to the new USB. Furthermore, if you wanted the new Collection on the target USB to have the same hot cues, tags, etc., you'd have to process those tracks again on the new USB to carry that information over.</p> <p>Wouldn't it be nice if you make your playlists, run a command, and get a new USB with all those audio files automatically copied to it AND a generated collection that you can import from to retrieve all the track data present in your existing Collection? That's exactly what the copy_playlists feature does!</p>"},{"location":"how_to_guides/copy_playlists/#how-its-done","title":"How it's done","text":"<ol> <li>Choose the playlist or playlists whose tracks you'd like to copy</li> <li>Determine the destination where you want all those tracks to be copied</li> <li>Run the command <code>--copy-playlists</code> with the name(s) of the playlist(s) provided (if spaces are present in the name, you must enclose the name with quotes) and the desired destination path provided with the <code>--copy-playlists-destination</code> option</li> <li>Import the playlists from the generated collection</li> </ol>"},{"location":"how_to_guides/copy_playlists/#example","title":"Example","text":"<p>In the image below, you can see that the \"Tech Trance\" playlist has it's tracks located across a variety of paths under <code>/Volumes/AWEEEEZY/DJ Music/aweeeezy/Techno/</code>: </p> <p>Next, I run the command:</p> <p><code>djtools --copy-playlists \"Tech Trance\" --copy-playlists-destination ~/Desktop/new_track_location</code></p> <p>Now I can view the <code>location</code> of the tracks in the \"Tech Trance\" playlist in the generated collection and see that they point to the <code>new_track_location</code> directory on my desktop: </p>"},{"location":"how_to_guides/extract_from_url/","title":"Extract Audio Files From URLs","text":"<p>In this guide you will learn how to extract audio files from URLs.</p>"},{"location":"how_to_guides/extract_from_url/#why-extract-audio-files-from-urls","title":"Why extract audio files from URLs?","text":"<p>Sometimes you need a sample for your collection that cannot be obtained any other way than by extracting the audio embedded in a webpage.</p> <p>This feature is a simple wrapper around the <code>youtube-dl</code> package.</p>"},{"location":"how_to_guides/extract_from_url/#how-its-done","title":"How it's done","text":"<ol> <li>Run the command <code>djtools --url-download &lt;URL&gt; --url-download-destination &lt;PATH&gt;</code></li> </ol>"},{"location":"how_to_guides/process_recordings/","title":"Process Recorded Files Using Spotify Playlists","text":"<p>In this guide you will learn how to automate splitting a recorded file into individual tracks using a Spotify playlist. These tracks will be normalized and exported with a configured bitrate and file format with tags pre-populated.</p>"},{"location":"how_to_guides/process_recordings/#prerequisites","title":"Prerequisites","text":"<ul> <li>Installing FFmpeg</li> </ul>"},{"location":"how_to_guides/process_recordings/#why-process-recorded-files","title":"Why process recorded files","text":"<p>Manually splitting a recorded audio file into individual tracks is both time consuming and error prone. Users may forget to apply amplitude normalization or mistype the filenames which are inputs to downstream processes like extracting title and artist tags. Users may also forget to export files with an acceptable file format or bit rate which can degrade the quality of your collection.</p>"},{"location":"how_to_guides/process_recordings/#how-its-done","title":"How it's done","text":"<ol> <li>Configure <code>recording_file</code> to point to your recorded audio file</li> <li>Configure <code>recording_playlist</code> to a valid Spotify playlist name present in your <code>spotify_playlists.yaml</code></li> <li>Configure <code>audio_bitrate</code>, <code>audio_format</code>, and <code>audio_headroom</code> to the desired values (defaults are <code>320k</code>, <code>mp3</code>, and <code>0.0</code> respectively)</li> <li>Configure <code>audio_destination</code> to point to where you want the files to export to</li> <li>Run the command <code>--process-recording</code></li> </ol>"},{"location":"how_to_guides/reddit_spotify_api_access/","title":"Setup Spotify &amp; Reddit API Access","text":"<p>In this guide you will learn how to setup authorization to the Spotify and Reddit APIs in order to use the following features:</p> <ul> <li>Checking for track overlap between the Beatcloud and Spotify playlists</li> <li>Creating Spotify playlists from Reddit submissions</li> <li>Creating Spotify playlists from other Beatcloud users' uploads</li> <li>Syncing tracks from a Spotify playlist</li> </ul>"},{"location":"how_to_guides/reddit_spotify_api_access/#how-its-done","title":"How it's done","text":"<ol> <li>Setup access to the Spotify API by following their official documentation</li> <li>Setup access to the Reddit API (only needed if Creating Spotify Playlists From Reddit Submissions) -- take a look at reddit.com/wiki/api or follow PRAW's Quick Start guide</li> <li>Populate the following list of config options:<ul> <li><code>reddit_client_id</code></li> <li><code>reddit_client_secret</code></li> <li><code>reddit_user_agent</code></li> <li><code>spotify_client_id</code></li> <li><code>spotify_client_secret</code></li> <li><code>spotify_redirect_uri</code></li> <li><code>spotify_username</code></li> </ul> </li> </ol>"},{"location":"how_to_guides/setup_object_storage/","title":"Setup Object Storage For Syncing Files","text":"<p>In this guide you will learn how to setup access to an AWS S3 API compliant object store service. Once this access has been setup, you will be able to sync files with the Beatcloud.</p>"},{"location":"how_to_guides/setup_object_storage/#why-sync-files-in-the-first-place","title":"Why sync files in the first place?","text":"<p>There are two primary reasons to sync your files to the cloud:</p> <ol> <li>Creating a reliable backup for your files</li> <li>Enabling remote sharing of your collection with other DJs</li> </ol>"},{"location":"how_to_guides/setup_object_storage/#how-its-done","title":"How it's done","text":"<ol> <li> <p>It should be the case that <code>awscli</code> was installed alongside DJ Tools; check that it works by running <code>aws</code></p> <ul> <li>In the event that you cannot run the <code>aws</code> command, you'll have to install it manually:<ul> <li>Mac installation: <code>brew install awscli</code></li> <li>Linux installation: <code>sudo apt-get install awscli</code></li> <li>Windows installation [official instructions]: download installer OR run: \u00a0\u00a0\u00a0<code>msiexec.exe /i https://awscli.amazonaws.com/AWSCLIV2.msi</code></li> </ul> </li> </ul> </li> <li> <p>Create and setup an account for AWS S3 (you could use any AWS S3 API compliant cloud storage solution, e.g. MinIO, but I've not tested anything else)</p> </li> <li> <p>Setup a profile (so as to not conflict with pre-existing or future profiles) for your keys:</p> <p> <code>aws configure --profile DJ</code></p> </li> <li> <p>Enter the <code>access_key</code> and <code>secret_key</code> (default values for the rest of the configuration is fine)</p> </li> <li>Set the configuration option <code>aws_profile</code> in <code>config.yaml</code> to match this profile name</li> </ol>"},{"location":"how_to_guides/shuffle_playlists/","title":"Shuffle tracks in playlists","text":"<p>In this guide you will learn how to shuffle your collection's playlists.</p>"},{"location":"how_to_guides/shuffle_playlists/#prerequisites","title":"Prerequisites","text":"<ul> <li>Rekordbox settings</li> <li>Get to Know Your Rekordbox Collection</li> </ul>"},{"location":"how_to_guides/shuffle_playlists/#why-shuffle-playlists","title":"Why shuffle playlists?","text":"<p>I find the absence of a shuffle feature for your Rekordbox playlists to be pretty strange. I have playlists, like event sets, that don't make any sense to shuffle. However, the majority of my mixing is done in an ad hoc manner, using genre-based playlists generated by the Build Playlists From Tags feature.</p> <p>I noticed that I kept mixing the same pairs of songs together because they catch my eye the same way each time I scan the playlists from top to bottom. It's true that any of the columns can be sorted, but there's only so much variation that can be introduced from this. For this reason, I implemented the shuffle_playlists feature.</p>"},{"location":"how_to_guides/shuffle_playlists/#how-its-done","title":"How it's done","text":"<ol> <li>Choose the playlist or playlists whose tracks you'd like shuffled</li> <li>Run the command <code>--shuffle-playlists</code> with the name(s) of the playlist(s) provided (if spaces are present in the name, you must enclose the name with quotes)</li> <li>Import either the <code>SHUFFLE</code> playlist or else all of the tracks within it from the generated collection</li> <li>Make sure you have the <code>Track Number</code> column enabled in Rekordbox and sort by it to realize the shuffling</li> </ol> <p><code>NOTE</code>: if you have multiple playlists with the same name, all of those playlists will have their tracks shuffled!</p>"},{"location":"how_to_guides/shuffle_playlists/#example","title":"Example","text":"<p>In the image below, you can see that the first 20 tracks of my \"Jungle\" playlist have track numbers in the set <code>{1, 2, 3}</code>: </p> <p>Next, I run the command:</p> <p><code>djtools --shuffle-playlists Jungle</code></p> <p>Now I can import the tracks from the <code>SHUFFLE</code> playlist in the generated collection: </p> <p>Once importing the tracks is complete, I can now view the \"Jungle\" playlist and see that the <code>Track Number</code> attributes have been overwritten, enabling an emulation of playlist shuffling via sorting of this column: </p>"},{"location":"how_to_guides/spotify_playlist_from_reddit/","title":"Create Spotify Playlists From Reddit Posts","text":"<p>In this guide you will learn how to automatically build Spotify playlists based on the titles of submissions made to subreddits.</p> <p>Note that the efficacy of this tool is dependent on whether or not submissions are links to Spotify tracks and, if not, how strictly submission titles conform to a standard of <code>artist name - track title</code> or <code>track title - artist name</code>. See the note at the bottom regarding the potential for subreddit-specific title parsers.</p>"},{"location":"how_to_guides/spotify_playlist_from_reddit/#prerequisites","title":"Prerequisites","text":"<ul> <li>Setup API access for Spotify and Reddit</li> </ul>"},{"location":"how_to_guides/spotify_playlist_from_reddit/#why-create-spotify-playlists-from-reddit-posts","title":"Why create Spotify playlists from Reddit posts?","text":"<p>The idea to create a Reddit --&gt; Spotify track scraper came from the r/Techno playlist. I found this one to be a great way to gain exposure to new music and wanted to emulate it across other subreddits.</p>"},{"location":"how_to_guides/spotify_playlist_from_reddit/#how-its-done","title":"How it's done","text":"<ol> <li>Configure the <code>spotify_playlist_subreddits</code> option (see the Configuration tutorial for more details)</li> <li>Run the command <code>djtools --spotify-playlists</code></li> <li>[optional] Setup a crontab to run this, for e.g., every morning at 8am</li> </ol>"},{"location":"how_to_guides/spotify_playlist_from_reddit/#example","title":"Example","text":"<p>In the example below, you can see a portion of <code>config.yaml</code> which shows all of the options relating to the <code>--spotify-playlists</code> feature. </p> <p>The <code>spotify_playlist_subreddits</code> option is where you configure the subreddits from which you'd like to build Spotify playlists from. It accepts a list of <code>SubredditConfig</code> objects. The minimum attribute set required for each of the <code>SubredditConfig</code> objects is the <code>name</code> attribute which is a case-insenstive exact match of the subreddit. The other attributes are as follows:</p> <ul> <li><code>limit</code> [default=<code>50</code>]: the maximum number of tracks allowed in the playlist before the least recently added tracks are removed</li> <li><code>period</code> [default=<code>week</code>]: the interval for which to pull Reddit submissions over <code>{all, day, hour, month, week, year}</code></li> <li><code>type</code>: [default=<code>hot</code>]: the sorting filter to apply for the subreddit <code>{controversial, hot, new, rising, top}</code></li> </ul> <p>Each of the above (<code>name</code> not included) has an associated <code>SPOTIFY_PLAYLIST_DEFAULT_*</code> option which will be applied in the absence of specification for any individual <code>SubredditConfig</code> object.</p> <p>The remaining <code>--spotify-playlists</code> related options are as follows:</p> <ul> <li><code>SPOTIFY_PLAYLIST_FUZZ_RATO</code> [default=<code>70</code>]: the minimum required Levenshtein similarity between the parsed submission title and the <code>track title - artist name</code> of a Spotify search results for it to be added to the playlist</li> <li><code>spotify_playlist_post_limit</code>[default=<code>100</code>]: the maximum number of submissions results from a subreddit query</li> <li><code>spotify_playlists</code> [default=<code>false</code>]: the flag to trigger the execution of this feature</li> </ul> <p>Once your options are configured as desired, you can run the following command to populate the playlists:</p> <p><code>djtools --spotify-playlists</code></p> <p>Note that only one result (the one with the highest Levenshtein similarity that is greater than or equal to <code>spotify_playlist_fuzz_ratio</code>) will be added to the playlist for each submission.</p> <p>Also note that a naive submission title parser is used unanimously for all subreddits. In the future, it would be helpful if an abstract interface for submission title parsing was defined and implementations could be sub-classed and configured inside the individual <code>SubredditConfig</code> objects.</p>"},{"location":"how_to_guides/spotify_playlist_from_upload/","title":"Create Spotify Playlists From Other Users' Uploads","text":"<p>In this guide you will learn how to automatically build Spotify playlists based on the Discord webhook output triggered by a user's music upload.</p> <p>Note that the addition of tracks to a Spotify playlist is done in a best effort manner. If users upload tracks that either (a) do not exist on Spotify or (b) have filenames that do not adhere to the suggested standard, they will not be found when searching Spotify.</p>"},{"location":"how_to_guides/spotify_playlist_from_upload/#prerequisites","title":"Prerequisites","text":"<ul> <li>Setup Object Storage For Syncing Files</li> <li>Setup API access for Spotify and Reddit</li> <li>Setup a Discord server and generate a webhook for a channel on that server</li> <li>A user must have uploaded music triggering the webhook to post a message to your Discord server</li> </ul>"},{"location":"how_to_guides/spotify_playlist_from_upload/#why-create-spotify-playlists-from-other-users-uploads","title":"Why create Spotify playlists from other users' uploads?","text":"<p>You're probably using DJ Tools to manage a shared track collection with friends who have a similar taste in music. Despite this, we all have our own style and don't necessarily want to indiscriminately sync every track that every other user syncs to the Beatcloud.</p> <p>The purpose of this feature is to allow you to build a Spotify playlist from the tracks a user uploads so that they can be previewed and filtered for compatibility with your mixing style. Once this playlist has been filtered down a bit, you can then run the <code>--download-spotify-playlist</code> option to sync just the tracks that remain in the playlist.</p>"},{"location":"how_to_guides/spotify_playlist_from_upload/#how-its-done","title":"How it's done","text":"<ol> <li>Ensure that other users of your Beatcloud instance have the <code>discord_url</code> option set to this webhook URL; otherwise you won't<ul> <li>be alerted when they upload music</li> <li>have the fancy formatted text output that's required to use this feature</li> </ul> </li> <li>Once another user runs the upload music command, a message containing a file tree of their upload results will be posted to your server</li> <li>Copy the complete text from that message to your system clipboard</li> <li>Run the command <code>djtools --spotify-playlist-from-upload</code></li> </ol>"},{"location":"how_to_guides/spotify_playlist_from_upload/#example","title":"Example","text":"<p>In the image below, I'm copying the Discord webhook output from one of my own uploads: </p> <p>The top-level directory in the file tree should correspond with a username; it's this value that's used to name the playlist <code>&lt;Username&gt; Uploads</code>. In this example, a playlist called <code>Aweeeezy Uploads</code> will be created since the top-level directory is <code>aweeeezy</code>.</p> <p>With the webhook output copied to my clipboard I now run the following command:</p> <p><code>djtools --spotify-playlist-from-upload</code></p> <p>As you can see in the output below, all of the tracks from the upload were able to be found on Spotify:</p> <pre><code>Matched 2094 - TMSV to 2094 - TMSV\nMatched Conscious - Pathwey, Murkury, Grime Theory to Conscious - Pathwey, Murkury, Grime Theory\nMatched Drips - Philip D Kick, Om Unit to Drips - Philip D Kick, Om Unit\nMatched Hella Sideways - Posij to Hella Sideways - Posij\nMatched Immortal - Hamdi to Immortal - Hamdi\nMatched Isotoxal - Paradox to Isotoxal - Paradox\nMatched Mantra - Coco Bryce to Mantra - Coco Bryce\nMatched Noxious - LYNY to Noxious - LYNY\nMatched Skanka - sumthin sumthin Remix - Hamdi, sumthin sumthin to Skanka (sumthin sumthin Remix) - Hamdi, sumthin sumthin\nMatched Vapours - Fada to Vapours - Fada\nMatched Zodd's Hunger - Noer the Boy to Zodd's Hunger - Noer the Boy\nMatched bendy. - pheel. to bendy. - pheel.\nMatched In the Presence - Orphx to In the Presence - Orphx\nMatched M\u00e9chant - Bad Brahmin to Mechant - Bad Brahmin\nMatched Vital Force - Chl\u00e4r to Vital Force - Chlar\n15 new tracks added\n\"Aweeeezy Uploads\": https://open.spotify.com/playlist/1hsPD6IpuTzJLkXwxlpxTF\n</code></pre> <p>Finally, the below image shows the automatically generated playlist: </p>"},{"location":"how_to_guides/standardize_audio/","title":"Standardize Audio Files","text":"<p>In this guid you will learn how to standardize audio files prior to uploading them to the Beatcloud.</p>"},{"location":"how_to_guides/standardize_audio/#prerequisites","title":"Prerequisites","text":"<ul> <li>Installing FFmpeg</li> </ul>"},{"location":"how_to_guides/standardize_audio/#why-standardize-audio-files","title":"Why standardize audio files?","text":"<p>Users may want to keep their Beatcloud footprint smaller by formatting all their tracks as mp3 files while also ensuring the quality of their audio files is top-notch (see the file standardization conceptual guide).</p> <p>Users may also want to normalize their audio files' peak amplitude to some target headroom so that they don't have to worry about adjusting the gain while mixing.</p>"},{"location":"how_to_guides/standardize_audio/#how-its-done","title":"How it's done","text":"<ol> <li>Configure the directory or directories containing your audio files with <code>local_dirs</code></li> <li>Configure <code>audio_bitrate</code>, <code>audio_format</code>, and <code>audio_headroom</code> to the desired values (defaults are <code>320k</code>, <code>mp3</code>, and <code>0.0</code> respectively)</li> <li>Run the command <code>--normalize-audio</code></li> </ol>"},{"location":"how_to_guides/sync_beatcloud/","title":"Sync Files with the Beatcloud","text":"<p>In this guide you will learn how to sync audio and database files with the Beatcloud.</p>"},{"location":"how_to_guides/sync_beatcloud/#prerequisites","title":"Prerequisites","text":"<ul> <li>Setup object storage for syncing files</li> <li>Configure the <code>sync</code> options</li> </ul>"},{"location":"how_to_guides/sync_beatcloud/#why-sync-files-with-the-beatcloud","title":"Why sync files with the Beatcloud?","text":"<p>Syncing your audio files gives you a reliable backup of your tracks and allows you share them with your DJ friends.</p> <p>Syncing your database files also improves reliability since you may lose, damage, or corrupt your database. Additionally, you may want to allow other users to import tracks using your tags, beatgrids, hot cues, etc. contained within that database file.</p>"},{"location":"how_to_guides/sync_beatcloud/#how-its-done","title":"How it's done","text":"<p><code>Note</code>: if you want to first preview which files will be uploaded or downloaded by the <code>--upload-music</code> or <code>--download-music</code> commands, you can append the flag <code>--dryrun</code>.</p>"},{"location":"how_to_guides/sync_beatcloud/#uploading-music","title":"Uploading music","text":"<ol> <li>Move new audio files to the desired location under <code>&lt;usb_path&gt;/DJ Music/</code><ul> <li>Note that it is required that you put all your music files under this path</li> <li>It's highly recommended that the top-level folders under <code>DJ Music</code> are usernames so that the Create Spotify playlists from other users' uploads feature works as expected</li> <li>It's also highly recommended that folders under <code>DJ Music</code> follow the convention <code>&lt;username&gt;/&lt;broad genre&gt;/&lt;date&gt;/</code> to improve the organization and usability of the Beatcloud; for example:<ul> <li>I may decide I dislike Bob's taste in Techno so I would configure the <code>download_exclude_dirs</code> option to be <code>[\"bob/Techno\"]</code></li> <li>I may decide I only want all of Sally's music and Bob's music uploaded on <code>2023-04-04</code> so I would configure the <code>download_include_dirs</code> option to be <code>[\"sally\", \"bob/*/2023-04-04\"]</code></li> <li>As you can see, having a structured music collection gives users a high degree of flexibility when it comes to syncing others' tracks; it also pairs well with other features like Create Spotify Playlists From Other Users' Uploads and Sync Tracks From Spotify Playlists</li> </ul> </li> </ul> </li> <li>Configure <code>upload_include_dirs</code> or <code>upload_exclude_dirs</code> (only one may be specified at a time) to include or exclude specific paths</li> <li>[Optional] If you want to notify a Discord server of your uploaded files, make sure you first setup a Discord webhook<ul> <li>This is required for the Create Spotify playlists from other users' uploads feature to work</li> </ul> </li> <li>Run the command <code>djtools --upload-music</code></li> </ol>"},{"location":"how_to_guides/sync_beatcloud/#downloading-music","title":"Downloading music","text":"<ol> <li>The same points above about including and excluding paths apply to <code>download_include_dirs</code> and <code>download_exclude_dirs</code>.</li> <li>Run the command <code>djtools --download-music</code></li> </ol>"},{"location":"how_to_guides/sync_beatcloud/#uploading-collection","title":"Uploading collection","text":"<ol> <li>Export an up-to-date copy of your collection (e.g. create a Rekordbox XML)</li> <li>Ensure the <code>collection_path</code> option points to this collection</li> <li>Run the command <code>djtools --upload-collection</code></li> </ol>"},{"location":"how_to_guides/sync_beatcloud/#downloading-collection","title":"Downloading collection","text":"<ol> <li>Set the <code>import_user</code> option to the username of another user in your Beatcloud<ul> <li>This username must exist as a directory in the Beatcloud under <code>&lt;bucket_url&gt;/collections</code> (it will if this user has ever run <code>--upload-collection</code>)</li> </ul> </li> <li>Run the command <code>djtools --download-collection</code></li> </ol> <p><code>Note</code>: you can set <code>import_user</code> to your own <code>user</code> value to retrieve a backup of your collection.</p>"},{"location":"how_to_guides/sync_spotify/","title":"Sync Tracks From Spotify Playlists","text":"<p>In this guide you will learn how to limit the tracks you sync to your USB by providing a Spotify playlist with only the desired tracks in it.</p>"},{"location":"how_to_guides/sync_spotify/#prerequisites","title":"Prerequisites","text":"<ul> <li>Setup object storage for syncing files</li> <li>Configure the <code>sync</code> options</li> <li>Have a playlist generated by Create Spotify Playlists From Other Users' Uploads</li> </ul>"},{"location":"how_to_guides/sync_spotify/#why-sync-tracks-from-a-spotify-playlist","title":"Why sync tracks from a Spotify playlist?","text":"<p>You're probably using DJ Tools to manage a shared track collection with friends who have a similar taste in music. Despite this, we all have our own style and don't necessarily want to indiscriminately sync every track that every other user syncs to the Beatcloud.</p> <p>The purpose of this feature is to allow you to limit the tracks you sync to your <code>usb_path</code> by providing a Spotify playlists with only the desired tracks in it. It's intended that this playlist was created using the sister feature create Spotify playlist from other users' uploads, though there's nothing strictly preventing you from using any playlist that's registered in <code>spotify_playlists.yaml</code>.</p>"},{"location":"how_to_guides/sync_spotify/#how-its-done","title":"How it's done","text":"<ol> <li>Run the command <code>djtools --download-spotify-playlist &lt;playlist name&gt;</code><ul> <li>Note that <code>&lt;playlist name&gt;</code> must be a registered Spotify playlist in <code>spotify_playlists.yaml</code></li> <li>If <code>&lt;playlist name&gt;</code> is the playlist generated by the create Spotify playlist from other users' uploads feature, as is intended, then <code>&lt;playlist name&gt;</code> will automatically have been inserted into <code>spotify_playlists.yaml</code></li> </ul> </li> </ol>"},{"location":"reference/collection/","title":"Collection","text":"<p>The <code>collection</code> package contains modules:</p> <ul> <li><code>base_collection</code>: abstraction for Collection</li> <li><code>base_playlist</code>: abstraction for Playlist</li> <li><code>base_track</code>: abstraction for Track</li> <li><code>config</code>: the configuration object for the <code>collection</code> package</li> <li><code>copy_playlists</code>: copies audio files for tracks within a set of     playlists to a new location and writes a new collection with these     updated paths</li> <li><code>helpers</code>: contains helper classes and functions for the other modules of     this package</li> <li><code>playlist_builder</code>: constructs playlists using tags in a Collection and a     defined playlist structure in     <code>collection_playlists.yaml</code></li> <li><code>playlist_filters</code>: abstractions and implementations for playlist filters</li> <li><code>playlists</code>: abstractions and implementations for playlists</li> <li><code>rekordbox_collection</code>: implementation of Collection for Rekordbox</li> <li><code>rekordbox_playlist</code>: implementation of Playlist for Rekordbox</li> <li><code>rekordbox_track</code>: implementation of Track for Rekordbox</li> <li><code>shuffle_playlists</code>: writes sequential numbers to tags of shuffled tracks     in playlists to emulate playlist shuffling</li> <li><code>tracks</code>: abstractions and implementations for tracks</li> </ul>"},{"location":"reference/collection/#djtools.collection.RekordboxCollection","title":"<code>RekordboxCollection</code>","text":"<p>               Bases: <code>Collection</code></p> <p>Collection implementation for usage with Rekordbox.</p> Source code in <code>src/djtools/collection/rekordbox_collection.py</code> <pre><code>class RekordboxCollection(Collection):\n    \"Collection implementation for usage with Rekordbox.\"\n\n    @make_path\n    def __init__(self, path: Path):\n        \"\"\"Deserializes a Collection from an XML file.\n\n        Args:\n            path: Path to a serialized collection.\n        \"\"\"\n        super().__init__(path=path)\n        self._path = path\n\n        # Parse the XML as a BeautifulSoup document.\n        with open(self._path, mode=\"r\", encoding=\"utf-8\") as _file:\n            self._collection = BeautifulSoup(_file.read(), \"xml\")\n\n        # Create a dict of tracks.\n        self._tracks = {\n            track[\"TrackID\"]: RekordboxTrack(track)\n            for track in self._collection.find_all(\"TRACK\")\n            if track.get(\"Location\")\n        }\n\n        # Instantiate the Playlist(s) in this collection.\n        self._playlists = RekordboxPlaylist(\n            self._collection.find(\"NODE\", {\"Name\": \"ROOT\", \"Type\": \"0\"}),\n            tracks=self._tracks,\n        )\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Produce a string representation of this Collection.\n\n        Returns:\n            Collection represented as a string.\n        \"\"\"\n        # Eventual repr string to return.\n        string = \"{}({}\\n)\"\n        # Body to the repr string to fill out with Collection content.\n        body = \"\"\n\n        # Dunder methods aren't represented. Public members (i.e methods)\n        # aren't represented either.\n        repr_attrs = {\n            key[1:]: value\n            for key, value in self.__dict__.items()\n            if not (\n                key.startswith(f\"_{type(self).__name__}\")\n                or not key.startswith(\"_\")\n                or key == \"_collection\"\n            )\n        }\n\n        # Build a representation of this Collection.\n        for key, value in repr_attrs.items():\n            # Skip representing this collection's playlists and tracks.\n            # Defer representation of the playlists attribute until the end.\n            if key in [\"playlists\", \"tracks\"]:\n                continue\n\n            # Represent string values with surrounding double quotes.\n            if isinstance(value, (Path, str)):\n                value = f'\"{value}\"'\n\n            # Append the attribute's name and value to the representation.\n            body += f\"\\n{' ' * 4}{key}={value},\"\n\n        # Represent the tracks attribute as the number of tracks.\n        body += f\"\\n{' ' * 4}tracks={len(repr_attrs['tracks'])},\"\n\n        # Represent the playlists attribute as the total number of playlists.\n        stack = list(repr_attrs[\"playlists\"])\n        playlist_count = 0\n        while stack:\n            playlist = stack.pop()\n            try:\n                stack.extend(playlist.get_playlists())\n            except RuntimeError:\n                playlist_count += 1\n        body += f\"\\n{' ' * 4}playlists={playlist_count},\"\n\n        return string.format(type(self).__name__, body)\n\n    @make_path\n    def serialize(self, *args, path: Optional[Path] = None, **kwargs) -&gt; Path:\n        \"\"\"Serializes this Collection as an XML file.\n\n        Args:\n            path: Path to output serialized collection to.\n\n        Returns:\n            Path to the serialized collection XML file.\n        \"\"\"\n        # BeautifulSoup document.\n        doc = BeautifulSoup(\"\", features=\"xml\")\n\n        # Tag that contains all the playlist data.\n        root_tag_name = \"DJ_PLAYLISTS\"\n\n        # Retrieve this root tag from the existing document, rather than\n        # building it from scratch, in case the attributes ever change.\n        root_tag = bs4.Tag(\n            name=root_tag_name,\n            attrs=self._collection.find(root_tag_name).attrs,\n        )\n\n        # Similarly, we want to reference the existing attribute data on the\n        # product Tag.\n        root_tag.extend(\n            [bs4.NavigableString(\"\\n\"), copy(self._collection.find(\"PRODUCT\"))]\n        )\n\n        # Build the collection Tag and serialize each track into it before\n        # adding the collection Tag to the root.\n        collection_tag = bs4.Tag(\n            name=\"COLLECTION\", attrs={\"Entries\": str(len(self._tracks))}\n        )\n        for track in self._tracks.values():\n            collection_tag.extend(\n                [bs4.NavigableString(\"\\n\"), track.serialize()]\n            )\n        collection_tag.append(bs4.NavigableString(\"\\n\"))\n        root_tag.extend([bs4.NavigableString(\"\\n\"), collection_tag])\n\n        # Build the playlists Tag and serialize each Playlist into it before\n        # adding the playlist Tag to the root.\n        playlists_tag = bs4.Tag(name=\"PLAYLISTS\")\n        playlists_root_tag = bs4.Tag(\n            name=\"NODE\",\n            attrs={\"Type\": \"0\", \"Name\": \"ROOT\", \"Count\": len(self._playlists)},\n        )\n        for playlist in self._playlists:\n            playlists_root_tag.extend(\n                [bs4.NavigableString(\"\\n\"), playlist.serialize()]\n            )\n        playlists_root_tag.append(bs4.NavigableString(\"\\n\"))\n        playlists_tag.extend(\n            [\n                bs4.NavigableString(\"\\n\"),\n                playlists_root_tag,\n                bs4.NavigableString(\"\\n\"),\n            ]\n        )\n        root_tag.extend(\n            [\n                bs4.NavigableString(\"\\n\"),\n                playlists_tag,\n                bs4.NavigableString(\"\\n\"),\n            ]\n        )\n        doc.append(root_tag)\n\n        # If no new path is provided, use the original.\n        if not path:\n            path = self._path\n\n        # Write the serialized Collection to a new file.\n        with open(path, mode=\"w\", encoding=\"utf-8\") as _file:\n            _file.write(\n                doc.prettify(\n                    # UnsortedAttributes formatter ensures attributes are\n                    # serialized in the same order as the original XML file.\n                    formatter=UnsortedAttributes(\n                        indent=2,\n                        # CustomSubstitution is used to substitute an expanded\n                        # character set in the serialized XML file.\n                        entity_substitution=CustomSubstitution.substitute_xml,\n                    )\n                )\n            )\n\n        return path\n\n    @classmethod\n    def validate(cls, input_xml: Path, output_xml: Path):\n        \"\"\"Validate the serialized Collection matches the original.\n\n        Args:\n            input_xml: Path to an XML containing the original collection.\n            output_xml: Path to an XML containing the serialized collection.\n\n        Raises:\n            AssertionError: A serialized Collection must exactly match the\n                original XML used to deserialize from.\n        \"\"\"\n        # Read the original and serialized collection XML files as\n        # strings.\n        with open(input_xml, mode=\"r\", encoding=\"utf-8\") as _file:\n            input_xml_string = _file.read()\n        with open(output_xml, mode=\"r\", encoding=\"utf-8\") as _file:\n            output_xml_string = _file.read()\n\n        # Rekordbox capitalizes \"UTF-8\" in the file declaration while\n        # BeautifulSoup does not.\n        xml_declaration = input_xml_string[:38]\n        output_xml_string = xml_declaration + output_xml_string[38:]\n\n        # Replace multiple occurrences of whitespace with a single whitespace.\n        whitespace = re.compile(r\"/\\s{2,}/g\")\n        input_xml_string = re.sub(whitespace, input_xml_string, \" \")\n        output_xml_string = re.sub(whitespace, output_xml_string, \" \")\n\n        assert (\n            input_xml_string == output_xml_string\n        ), \"Failed RekordboxCollection validation!\"\n</code></pre>"},{"location":"reference/collection/#djtools.collection.RekordboxCollection.__init__","title":"<code>__init__(path)</code>","text":"<p>Deserializes a Collection from an XML file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>Path to a serialized collection.</p> required Source code in <code>src/djtools/collection/rekordbox_collection.py</code> <pre><code>@make_path\ndef __init__(self, path: Path):\n    \"\"\"Deserializes a Collection from an XML file.\n\n    Args:\n        path: Path to a serialized collection.\n    \"\"\"\n    super().__init__(path=path)\n    self._path = path\n\n    # Parse the XML as a BeautifulSoup document.\n    with open(self._path, mode=\"r\", encoding=\"utf-8\") as _file:\n        self._collection = BeautifulSoup(_file.read(), \"xml\")\n\n    # Create a dict of tracks.\n    self._tracks = {\n        track[\"TrackID\"]: RekordboxTrack(track)\n        for track in self._collection.find_all(\"TRACK\")\n        if track.get(\"Location\")\n    }\n\n    # Instantiate the Playlist(s) in this collection.\n    self._playlists = RekordboxPlaylist(\n        self._collection.find(\"NODE\", {\"Name\": \"ROOT\", \"Type\": \"0\"}),\n        tracks=self._tracks,\n    )\n</code></pre>"},{"location":"reference/collection/#djtools.collection.RekordboxCollection.__repr__","title":"<code>__repr__()</code>","text":"<p>Produce a string representation of this Collection.</p> <p>Returns:</p> Type Description <code>str</code> <p>Collection represented as a string.</p> Source code in <code>src/djtools/collection/rekordbox_collection.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Produce a string representation of this Collection.\n\n    Returns:\n        Collection represented as a string.\n    \"\"\"\n    # Eventual repr string to return.\n    string = \"{}({}\\n)\"\n    # Body to the repr string to fill out with Collection content.\n    body = \"\"\n\n    # Dunder methods aren't represented. Public members (i.e methods)\n    # aren't represented either.\n    repr_attrs = {\n        key[1:]: value\n        for key, value in self.__dict__.items()\n        if not (\n            key.startswith(f\"_{type(self).__name__}\")\n            or not key.startswith(\"_\")\n            or key == \"_collection\"\n        )\n    }\n\n    # Build a representation of this Collection.\n    for key, value in repr_attrs.items():\n        # Skip representing this collection's playlists and tracks.\n        # Defer representation of the playlists attribute until the end.\n        if key in [\"playlists\", \"tracks\"]:\n            continue\n\n        # Represent string values with surrounding double quotes.\n        if isinstance(value, (Path, str)):\n            value = f'\"{value}\"'\n\n        # Append the attribute's name and value to the representation.\n        body += f\"\\n{' ' * 4}{key}={value},\"\n\n    # Represent the tracks attribute as the number of tracks.\n    body += f\"\\n{' ' * 4}tracks={len(repr_attrs['tracks'])},\"\n\n    # Represent the playlists attribute as the total number of playlists.\n    stack = list(repr_attrs[\"playlists\"])\n    playlist_count = 0\n    while stack:\n        playlist = stack.pop()\n        try:\n            stack.extend(playlist.get_playlists())\n        except RuntimeError:\n            playlist_count += 1\n    body += f\"\\n{' ' * 4}playlists={playlist_count},\"\n\n    return string.format(type(self).__name__, body)\n</code></pre>"},{"location":"reference/collection/#djtools.collection.RekordboxCollection.serialize","title":"<code>serialize(*args, path=None, **kwargs)</code>","text":"<p>Serializes this Collection as an XML file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Optional[Path]</code> <p>Path to output serialized collection to.</p> <code>None</code> <p>Returns:</p> Type Description <code>Path</code> <p>Path to the serialized collection XML file.</p> Source code in <code>src/djtools/collection/rekordbox_collection.py</code> <pre><code>@make_path\ndef serialize(self, *args, path: Optional[Path] = None, **kwargs) -&gt; Path:\n    \"\"\"Serializes this Collection as an XML file.\n\n    Args:\n        path: Path to output serialized collection to.\n\n    Returns:\n        Path to the serialized collection XML file.\n    \"\"\"\n    # BeautifulSoup document.\n    doc = BeautifulSoup(\"\", features=\"xml\")\n\n    # Tag that contains all the playlist data.\n    root_tag_name = \"DJ_PLAYLISTS\"\n\n    # Retrieve this root tag from the existing document, rather than\n    # building it from scratch, in case the attributes ever change.\n    root_tag = bs4.Tag(\n        name=root_tag_name,\n        attrs=self._collection.find(root_tag_name).attrs,\n    )\n\n    # Similarly, we want to reference the existing attribute data on the\n    # product Tag.\n    root_tag.extend(\n        [bs4.NavigableString(\"\\n\"), copy(self._collection.find(\"PRODUCT\"))]\n    )\n\n    # Build the collection Tag and serialize each track into it before\n    # adding the collection Tag to the root.\n    collection_tag = bs4.Tag(\n        name=\"COLLECTION\", attrs={\"Entries\": str(len(self._tracks))}\n    )\n    for track in self._tracks.values():\n        collection_tag.extend(\n            [bs4.NavigableString(\"\\n\"), track.serialize()]\n        )\n    collection_tag.append(bs4.NavigableString(\"\\n\"))\n    root_tag.extend([bs4.NavigableString(\"\\n\"), collection_tag])\n\n    # Build the playlists Tag and serialize each Playlist into it before\n    # adding the playlist Tag to the root.\n    playlists_tag = bs4.Tag(name=\"PLAYLISTS\")\n    playlists_root_tag = bs4.Tag(\n        name=\"NODE\",\n        attrs={\"Type\": \"0\", \"Name\": \"ROOT\", \"Count\": len(self._playlists)},\n    )\n    for playlist in self._playlists:\n        playlists_root_tag.extend(\n            [bs4.NavigableString(\"\\n\"), playlist.serialize()]\n        )\n    playlists_root_tag.append(bs4.NavigableString(\"\\n\"))\n    playlists_tag.extend(\n        [\n            bs4.NavigableString(\"\\n\"),\n            playlists_root_tag,\n            bs4.NavigableString(\"\\n\"),\n        ]\n    )\n    root_tag.extend(\n        [\n            bs4.NavigableString(\"\\n\"),\n            playlists_tag,\n            bs4.NavigableString(\"\\n\"),\n        ]\n    )\n    doc.append(root_tag)\n\n    # If no new path is provided, use the original.\n    if not path:\n        path = self._path\n\n    # Write the serialized Collection to a new file.\n    with open(path, mode=\"w\", encoding=\"utf-8\") as _file:\n        _file.write(\n            doc.prettify(\n                # UnsortedAttributes formatter ensures attributes are\n                # serialized in the same order as the original XML file.\n                formatter=UnsortedAttributes(\n                    indent=2,\n                    # CustomSubstitution is used to substitute an expanded\n                    # character set in the serialized XML file.\n                    entity_substitution=CustomSubstitution.substitute_xml,\n                )\n            )\n        )\n\n    return path\n</code></pre>"},{"location":"reference/collection/#djtools.collection.RekordboxCollection.validate","title":"<code>validate(input_xml, output_xml)</code>  <code>classmethod</code>","text":"<p>Validate the serialized Collection matches the original.</p> <p>Parameters:</p> Name Type Description Default <code>input_xml</code> <code>Path</code> <p>Path to an XML containing the original collection.</p> required <code>output_xml</code> <code>Path</code> <p>Path to an XML containing the serialized collection.</p> required <p>Raises:</p> Type Description <code>AssertionError</code> <p>A serialized Collection must exactly match the original XML used to deserialize from.</p> Source code in <code>src/djtools/collection/rekordbox_collection.py</code> <pre><code>@classmethod\ndef validate(cls, input_xml: Path, output_xml: Path):\n    \"\"\"Validate the serialized Collection matches the original.\n\n    Args:\n        input_xml: Path to an XML containing the original collection.\n        output_xml: Path to an XML containing the serialized collection.\n\n    Raises:\n        AssertionError: A serialized Collection must exactly match the\n            original XML used to deserialize from.\n    \"\"\"\n    # Read the original and serialized collection XML files as\n    # strings.\n    with open(input_xml, mode=\"r\", encoding=\"utf-8\") as _file:\n        input_xml_string = _file.read()\n    with open(output_xml, mode=\"r\", encoding=\"utf-8\") as _file:\n        output_xml_string = _file.read()\n\n    # Rekordbox capitalizes \"UTF-8\" in the file declaration while\n    # BeautifulSoup does not.\n    xml_declaration = input_xml_string[:38]\n    output_xml_string = xml_declaration + output_xml_string[38:]\n\n    # Replace multiple occurrences of whitespace with a single whitespace.\n    whitespace = re.compile(r\"/\\s{2,}/g\")\n    input_xml_string = re.sub(whitespace, input_xml_string, \" \")\n    output_xml_string = re.sub(whitespace, output_xml_string, \" \")\n\n    assert (\n        input_xml_string == output_xml_string\n    ), \"Failed RekordboxCollection validation!\"\n</code></pre>"},{"location":"reference/collection/#djtools.collection.RekordboxPlaylist","title":"<code>RekordboxPlaylist</code>","text":"<p>               Bases: <code>Playlist</code></p> <p>Playlist implementation for usage with Rekordbox.</p> Source code in <code>src/djtools/collection/rekordbox_playlist.py</code> <pre><code>class RekordboxPlaylist(Playlist):\n    \"Playlist implementation for usage with Rekordbox.\"\n\n    def __init__(\n        self,\n        playlist: bs4.element.Tag,\n        *args,\n        tracks: Dict[str, RekordboxTrack] = None,\n        playlist_tracks: Optional[Dict[str, RekordboxTrack]] = None,\n        parent: Optional[\"RekordboxPlaylist\"] = None,\n        **kwargs,\n    ):\n        \"\"\"Deserialize a Playlist from a BeautifulSoup NODE Tag.\n\n        Args:\n            playlist: BeautifulSoup Tag representing a playlist.\n            tracks: All the tracks in this collection.\n            playlist_tracks: Tracks to set when initializing with new_playlist.\n            parent: The folder this playlist is in.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        self._tracks = None\n        self._playlists = None\n        self._parent = parent\n        tracks = tracks or {}\n\n        # Set this object's attributes with the NODE Tag's attributes.\n        for key, value in playlist.attrs.items():\n            setattr(self, f\"_{key}\", value)\n\n        # Recursively instantiate sub-playlists.\n        if self.is_folder():\n            self._playlists = [\n                RekordboxPlaylist(playlist, tracks=tracks, parent=self)\n                for playlist in filter(\n                    lambda x: isinstance(x, bs4.element.Tag), playlist.children\n                )\n            ]\n        # Deserialize tracks from a leaf node playlist.\n        else:\n            # Filter the children elements for Tags and get the key attribute.\n            if not playlist_tracks:\n                playlist_tracks = [\n                    track.get(\"Key\")\n                    for track in filter(\n                        lambda x: isinstance(x, bs4.element.Tag),\n                        playlist.children,\n                    )\n                ]\n            # Create a dict of tracks.\n            self._tracks = {\n                track_id: tracks[track_id] for track_id in playlist_tracks\n            }\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Produces a string representation of this playlist.\n\n        Returns:\n            Playlist represented as a string.\n        \"\"\"\n        # Eventual repr string to return.\n        string = \"{}{}({}{})\"\n        # Body of the repr string to fill out with playlist contents.\n        body = \"\"\n        # Get the repr recursion depth to determine the degree of indentation.\n        depth = (\n            len(\n                [\n                    frame\n                    for frame in inspect.stack()\n                    if frame[3] == \"__repr__\"\n                    and Path(frame[1]).name == \"rekordbox_playlist.py\"\n                ]\n            )\n            - 1\n        )\n        # These variables are used to control indentation level.\n        extra = 1 if depth else 0\n        padding = f\"{' ' * 4 * (depth + extra)}\"\n\n        # Dunder members aren't represented. Public members (i.e. methods)\n        # aren't represented either.\n        repr_attrs = {\n            key[1:]: value\n            for key, value in self.__dict__.items()\n            if not (\n                key.startswith(f\"_{type(self).__name__}\")\n                or not key.startswith(\"_\")\n                or key == \"_parent\"\n                or key == \"_aggregate\"\n            )\n        }\n\n        # Build a representation of this playlist.\n        for key, value in repr_attrs.items():\n            # Skip representing this playlist's tracks.\n            # Defer representation of the playlists attribute until the end.\n            if key in [\"playlists\", \"tracks\"]:\n                continue\n\n            # Represent string values with surrounding double quotes.\n            if isinstance(value, str):\n                value = f'\"{value}\"'\n\n            # Append the attribute's name and value to the representation.\n            body += f\"{key}={value}, \"\n\n        # Truncate the final attributes trailing \", \".\n        if not repr_attrs[\"playlists\"]:\n            body = body[:-2]\n        else:\n            body = body[:-1]\n\n        # Now represent the playlist attribute as an indented list of\n        # sub-playlists.\n        for key, value in repr_attrs.items():\n            if key != \"playlists\" or value is None:\n                continue\n            body += f\"\\n{padding + ' ' * 4 * (depth or 1)}{key}=[\"\n            for val in value:\n                body += f\"\\n{' ' * 4 * depth}{repr(val)},\"\n            # Truncate final comma.\n            body = body[:-1]\n            body += f\"\\n{padding + ' ' * 4 * (depth or 1)}],\"\n\n        # Truncate final comma.\n        if repr_attrs[\"playlists\"]:\n            body = body[:-1]\n\n        return string.format(\n            padding if depth else \"\",\n            type(self).__name__,\n            body,\n            f\"\\n{padding}{' ' * 4 * (depth - 1)}\" if self._playlists else \"\",\n        )\n\n    def __str__(self) -&gt; str:\n        \"\"\"Produce a string representation of this playlist.\n\n        Returns:\n            Playlist represented as a string.\n        \"\"\"\n        return str(self.serialize())\n\n    def get_name(self) -&gt; str:\n        \"\"\"Returns the name of this playlist.\n\n        Returns:\n            The name of this playlist.\n        \"\"\"\n        return self._Name  # pylint: disable=no-member\n\n    def is_folder(self) -&gt; bool:\n        \"\"\"Returns whether this playlist is a folder or a playlist of tracks.\n\n        Returns:\n            Boolean representing whether this is a folder or not.\n        \"\"\"\n        return self._Type == \"0\"  # pylint: disable=no-member\n\n    @classmethod\n    def new_playlist(\n        cls,\n        name: str,\n        playlists: Optional[List[\"RekordboxPlaylist\"]] = None,\n        tracks: Optional[Dict[str, RekordboxTrack]] = None,\n        enable_aggregation: Optional[bool] = None,\n    ) -&gt; \"RekordboxPlaylist\":\n        \"\"\"Creates a new playlist.\n\n        Args:\n            name: The name of the Playlist to be created.\n            playlists: A list of Playlists to add to this Playlist.\n            tracks: A dict of Tracks to add to this Playlist.\n            enable_aggregation: Whether or not this playlist has an aggregation\n                playlist.\n\n        Raises:\n            RuntimeError: You must provide either a list of Playlists or a list\n                of Tracks.\n            RuntimeError: You must not provide both a list of Playlists and a\n                list of Tracks.\n\n        Returns:\n            A new playlist.\n        \"\"\"\n        if playlists is None and tracks is None:\n            raise RuntimeError(\n                \"You must provide either a list of RekordboxPlaylists or a \"\n                \"list of RekordboxTracks\"\n            )\n        if playlists is not None and tracks is not None:\n            raise RuntimeError(\n                \"You must not provide both a list of RekordboxPlaylists and a \"\n                \"list of RekordboxTracks\"\n            )\n        playlist_tag = bs4.Tag(\n            name=\"NODE\",\n            attrs=(\n                {\"Name\": name, \"Type\": \"0\", \"Count\": len(playlists)}\n                if playlists is not None\n                else {\n                    \"Name\": name,\n                    \"Type\": \"1\",\n                    \"KeyType\": \"0\",\n                    \"Entries\": len(tracks),\n                }\n            ),\n        )\n        playlist = RekordboxPlaylist(\n            playlist_tag,\n            tracks=tracks,\n            playlist_tracks=(tracks or {}).keys(),\n            enable_aggregation=enable_aggregation,\n        )\n        playlist._playlists = playlists\n\n        return playlist\n\n    def serialize(self, *args, **kwargs) -&gt; bs4.element.Tag:\n        \"\"\"Serializes this playlist as a BeautifulSoup NODE Tag.\n\n        Returns:\n            BeautifulSoup Tag representing this playlist.\n        \"\"\"\n        # BeautifulSoup Tag to populate with attributes of this playlist.\n        playlist_tag = bs4.Tag(name=\"NODE\", can_be_empty_element=True)\n\n        # Dunder members aren't serialized. Public members (i.e. methods)\n        # aren't serialized either.\n        serialize_attrs = {\n            key[1:]: value\n            for key, value in self.__dict__.items()\n            if not (\n                key.startswith(f\"_{type(self).__name__}\")\n                or not key.startswith(\"_\")\n                or key == \"_parent\"\n                or key == \"_aggregate\"\n            )\n        }\n\n        # Serialize attributes into a NODE Tag.\n        for key, value in serialize_attrs.items():\n            # Playlists and tracks are serialized as nested Tag objects.\n            if key in [\"playlists\", \"tracks\"]:\n                if not value:\n                    continue\n\n                # Iterate and serialize nested playlists.\n                if self.is_folder():\n                    for val in value:\n                        playlist_tag.extend(\n                            [bs4.NavigableString(\"\\n\"), val.serialize()]\n                        )\n                # Iterate and serialize tracks.\n                else:\n                    for val in value.values():\n                        playlist_tag.extend(\n                            [\n                                bs4.NavigableString(\"\\n\"),\n                                val.serialize(playlist=True),\n                            ]\n                        )\n\n                # Append a final newline character.\n                playlist_tag.append(bs4.NavigableString(\"\\n\"))\n                continue\n\n            # Otherwise the data is serialized as NODE Tag attributes.\n            playlist_tag[key] = value\n\n        # Update the Count or Entries attribute.\n        playlist_tag[\"Count\" if self.is_folder() else \"Entries\"] = str(\n            len(self)\n        )\n\n        return playlist_tag\n</code></pre>"},{"location":"reference/collection/#djtools.collection.RekordboxPlaylist.__init__","title":"<code>__init__(playlist, *args, tracks=None, playlist_tracks=None, parent=None, **kwargs)</code>","text":"<p>Deserialize a Playlist from a BeautifulSoup NODE Tag.</p> <p>Parameters:</p> Name Type Description Default <code>playlist</code> <code>Tag</code> <p>BeautifulSoup Tag representing a playlist.</p> required <code>tracks</code> <code>Dict[str, RekordboxTrack]</code> <p>All the tracks in this collection.</p> <code>None</code> <code>playlist_tracks</code> <code>Optional[Dict[str, RekordboxTrack]]</code> <p>Tracks to set when initializing with new_playlist.</p> <code>None</code> <code>parent</code> <code>Optional[RekordboxPlaylist]</code> <p>The folder this playlist is in.</p> <code>None</code> Source code in <code>src/djtools/collection/rekordbox_playlist.py</code> <pre><code>def __init__(\n    self,\n    playlist: bs4.element.Tag,\n    *args,\n    tracks: Dict[str, RekordboxTrack] = None,\n    playlist_tracks: Optional[Dict[str, RekordboxTrack]] = None,\n    parent: Optional[\"RekordboxPlaylist\"] = None,\n    **kwargs,\n):\n    \"\"\"Deserialize a Playlist from a BeautifulSoup NODE Tag.\n\n    Args:\n        playlist: BeautifulSoup Tag representing a playlist.\n        tracks: All the tracks in this collection.\n        playlist_tracks: Tracks to set when initializing with new_playlist.\n        parent: The folder this playlist is in.\n    \"\"\"\n    super().__init__(*args, **kwargs)\n    self._tracks = None\n    self._playlists = None\n    self._parent = parent\n    tracks = tracks or {}\n\n    # Set this object's attributes with the NODE Tag's attributes.\n    for key, value in playlist.attrs.items():\n        setattr(self, f\"_{key}\", value)\n\n    # Recursively instantiate sub-playlists.\n    if self.is_folder():\n        self._playlists = [\n            RekordboxPlaylist(playlist, tracks=tracks, parent=self)\n            for playlist in filter(\n                lambda x: isinstance(x, bs4.element.Tag), playlist.children\n            )\n        ]\n    # Deserialize tracks from a leaf node playlist.\n    else:\n        # Filter the children elements for Tags and get the key attribute.\n        if not playlist_tracks:\n            playlist_tracks = [\n                track.get(\"Key\")\n                for track in filter(\n                    lambda x: isinstance(x, bs4.element.Tag),\n                    playlist.children,\n                )\n            ]\n        # Create a dict of tracks.\n        self._tracks = {\n            track_id: tracks[track_id] for track_id in playlist_tracks\n        }\n</code></pre>"},{"location":"reference/collection/#djtools.collection.RekordboxPlaylist.__repr__","title":"<code>__repr__()</code>","text":"<p>Produces a string representation of this playlist.</p> <p>Returns:</p> Type Description <code>str</code> <p>Playlist represented as a string.</p> Source code in <code>src/djtools/collection/rekordbox_playlist.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Produces a string representation of this playlist.\n\n    Returns:\n        Playlist represented as a string.\n    \"\"\"\n    # Eventual repr string to return.\n    string = \"{}{}({}{})\"\n    # Body of the repr string to fill out with playlist contents.\n    body = \"\"\n    # Get the repr recursion depth to determine the degree of indentation.\n    depth = (\n        len(\n            [\n                frame\n                for frame in inspect.stack()\n                if frame[3] == \"__repr__\"\n                and Path(frame[1]).name == \"rekordbox_playlist.py\"\n            ]\n        )\n        - 1\n    )\n    # These variables are used to control indentation level.\n    extra = 1 if depth else 0\n    padding = f\"{' ' * 4 * (depth + extra)}\"\n\n    # Dunder members aren't represented. Public members (i.e. methods)\n    # aren't represented either.\n    repr_attrs = {\n        key[1:]: value\n        for key, value in self.__dict__.items()\n        if not (\n            key.startswith(f\"_{type(self).__name__}\")\n            or not key.startswith(\"_\")\n            or key == \"_parent\"\n            or key == \"_aggregate\"\n        )\n    }\n\n    # Build a representation of this playlist.\n    for key, value in repr_attrs.items():\n        # Skip representing this playlist's tracks.\n        # Defer representation of the playlists attribute until the end.\n        if key in [\"playlists\", \"tracks\"]:\n            continue\n\n        # Represent string values with surrounding double quotes.\n        if isinstance(value, str):\n            value = f'\"{value}\"'\n\n        # Append the attribute's name and value to the representation.\n        body += f\"{key}={value}, \"\n\n    # Truncate the final attributes trailing \", \".\n    if not repr_attrs[\"playlists\"]:\n        body = body[:-2]\n    else:\n        body = body[:-1]\n\n    # Now represent the playlist attribute as an indented list of\n    # sub-playlists.\n    for key, value in repr_attrs.items():\n        if key != \"playlists\" or value is None:\n            continue\n        body += f\"\\n{padding + ' ' * 4 * (depth or 1)}{key}=[\"\n        for val in value:\n            body += f\"\\n{' ' * 4 * depth}{repr(val)},\"\n        # Truncate final comma.\n        body = body[:-1]\n        body += f\"\\n{padding + ' ' * 4 * (depth or 1)}],\"\n\n    # Truncate final comma.\n    if repr_attrs[\"playlists\"]:\n        body = body[:-1]\n\n    return string.format(\n        padding if depth else \"\",\n        type(self).__name__,\n        body,\n        f\"\\n{padding}{' ' * 4 * (depth - 1)}\" if self._playlists else \"\",\n    )\n</code></pre>"},{"location":"reference/collection/#djtools.collection.RekordboxPlaylist.__str__","title":"<code>__str__()</code>","text":"<p>Produce a string representation of this playlist.</p> <p>Returns:</p> Type Description <code>str</code> <p>Playlist represented as a string.</p> Source code in <code>src/djtools/collection/rekordbox_playlist.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Produce a string representation of this playlist.\n\n    Returns:\n        Playlist represented as a string.\n    \"\"\"\n    return str(self.serialize())\n</code></pre>"},{"location":"reference/collection/#djtools.collection.RekordboxPlaylist.get_name","title":"<code>get_name()</code>","text":"<p>Returns the name of this playlist.</p> <p>Returns:</p> Type Description <code>str</code> <p>The name of this playlist.</p> Source code in <code>src/djtools/collection/rekordbox_playlist.py</code> <pre><code>def get_name(self) -&gt; str:\n    \"\"\"Returns the name of this playlist.\n\n    Returns:\n        The name of this playlist.\n    \"\"\"\n    return self._Name  # pylint: disable=no-member\n</code></pre>"},{"location":"reference/collection/#djtools.collection.RekordboxPlaylist.is_folder","title":"<code>is_folder()</code>","text":"<p>Returns whether this playlist is a folder or a playlist of tracks.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Boolean representing whether this is a folder or not.</p> Source code in <code>src/djtools/collection/rekordbox_playlist.py</code> <pre><code>def is_folder(self) -&gt; bool:\n    \"\"\"Returns whether this playlist is a folder or a playlist of tracks.\n\n    Returns:\n        Boolean representing whether this is a folder or not.\n    \"\"\"\n    return self._Type == \"0\"  # pylint: disable=no-member\n</code></pre>"},{"location":"reference/collection/#djtools.collection.RekordboxPlaylist.new_playlist","title":"<code>new_playlist(name, playlists=None, tracks=None, enable_aggregation=None)</code>  <code>classmethod</code>","text":"<p>Creates a new playlist.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the Playlist to be created.</p> required <code>playlists</code> <code>Optional[List[RekordboxPlaylist]]</code> <p>A list of Playlists to add to this Playlist.</p> <code>None</code> <code>tracks</code> <code>Optional[Dict[str, RekordboxTrack]]</code> <p>A dict of Tracks to add to this Playlist.</p> <code>None</code> <code>enable_aggregation</code> <code>Optional[bool]</code> <p>Whether or not this playlist has an aggregation playlist.</p> <code>None</code> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>You must provide either a list of Playlists or a list of Tracks.</p> <code>RuntimeError</code> <p>You must not provide both a list of Playlists and a list of Tracks.</p> <p>Returns:</p> Type Description <code>RekordboxPlaylist</code> <p>A new playlist.</p> Source code in <code>src/djtools/collection/rekordbox_playlist.py</code> <pre><code>@classmethod\ndef new_playlist(\n    cls,\n    name: str,\n    playlists: Optional[List[\"RekordboxPlaylist\"]] = None,\n    tracks: Optional[Dict[str, RekordboxTrack]] = None,\n    enable_aggregation: Optional[bool] = None,\n) -&gt; \"RekordboxPlaylist\":\n    \"\"\"Creates a new playlist.\n\n    Args:\n        name: The name of the Playlist to be created.\n        playlists: A list of Playlists to add to this Playlist.\n        tracks: A dict of Tracks to add to this Playlist.\n        enable_aggregation: Whether or not this playlist has an aggregation\n            playlist.\n\n    Raises:\n        RuntimeError: You must provide either a list of Playlists or a list\n            of Tracks.\n        RuntimeError: You must not provide both a list of Playlists and a\n            list of Tracks.\n\n    Returns:\n        A new playlist.\n    \"\"\"\n    if playlists is None and tracks is None:\n        raise RuntimeError(\n            \"You must provide either a list of RekordboxPlaylists or a \"\n            \"list of RekordboxTracks\"\n        )\n    if playlists is not None and tracks is not None:\n        raise RuntimeError(\n            \"You must not provide both a list of RekordboxPlaylists and a \"\n            \"list of RekordboxTracks\"\n        )\n    playlist_tag = bs4.Tag(\n        name=\"NODE\",\n        attrs=(\n            {\"Name\": name, \"Type\": \"0\", \"Count\": len(playlists)}\n            if playlists is not None\n            else {\n                \"Name\": name,\n                \"Type\": \"1\",\n                \"KeyType\": \"0\",\n                \"Entries\": len(tracks),\n            }\n        ),\n    )\n    playlist = RekordboxPlaylist(\n        playlist_tag,\n        tracks=tracks,\n        playlist_tracks=(tracks or {}).keys(),\n        enable_aggregation=enable_aggregation,\n    )\n    playlist._playlists = playlists\n\n    return playlist\n</code></pre>"},{"location":"reference/collection/#djtools.collection.RekordboxPlaylist.serialize","title":"<code>serialize(*args, **kwargs)</code>","text":"<p>Serializes this playlist as a BeautifulSoup NODE Tag.</p> <p>Returns:</p> Type Description <code>Tag</code> <p>BeautifulSoup Tag representing this playlist.</p> Source code in <code>src/djtools/collection/rekordbox_playlist.py</code> <pre><code>def serialize(self, *args, **kwargs) -&gt; bs4.element.Tag:\n    \"\"\"Serializes this playlist as a BeautifulSoup NODE Tag.\n\n    Returns:\n        BeautifulSoup Tag representing this playlist.\n    \"\"\"\n    # BeautifulSoup Tag to populate with attributes of this playlist.\n    playlist_tag = bs4.Tag(name=\"NODE\", can_be_empty_element=True)\n\n    # Dunder members aren't serialized. Public members (i.e. methods)\n    # aren't serialized either.\n    serialize_attrs = {\n        key[1:]: value\n        for key, value in self.__dict__.items()\n        if not (\n            key.startswith(f\"_{type(self).__name__}\")\n            or not key.startswith(\"_\")\n            or key == \"_parent\"\n            or key == \"_aggregate\"\n        )\n    }\n\n    # Serialize attributes into a NODE Tag.\n    for key, value in serialize_attrs.items():\n        # Playlists and tracks are serialized as nested Tag objects.\n        if key in [\"playlists\", \"tracks\"]:\n            if not value:\n                continue\n\n            # Iterate and serialize nested playlists.\n            if self.is_folder():\n                for val in value:\n                    playlist_tag.extend(\n                        [bs4.NavigableString(\"\\n\"), val.serialize()]\n                    )\n            # Iterate and serialize tracks.\n            else:\n                for val in value.values():\n                    playlist_tag.extend(\n                        [\n                            bs4.NavigableString(\"\\n\"),\n                            val.serialize(playlist=True),\n                        ]\n                    )\n\n            # Append a final newline character.\n            playlist_tag.append(bs4.NavigableString(\"\\n\"))\n            continue\n\n        # Otherwise the data is serialized as NODE Tag attributes.\n        playlist_tag[key] = value\n\n    # Update the Count or Entries attribute.\n    playlist_tag[\"Count\" if self.is_folder() else \"Entries\"] = str(\n        len(self)\n    )\n\n    return playlist_tag\n</code></pre>"},{"location":"reference/collection/#djtools.collection.RekordboxTrack","title":"<code>RekordboxTrack</code>","text":"<p>               Bases: <code>Track</code></p> <p>Track implementation for usage with Rekordbox.</p> Source code in <code>src/djtools/collection/rekordbox_track.py</code> <pre><code>class RekordboxTrack(Track):\n    \"Track implementation for usage with Rekordbox.\"\n\n    def __init__(self, track: bs4.element.Tag):\n        \"\"\"Deserialize a track from a BeautifulSoup TRACK Tag.\n\n        Args:\n            track: BeautifulSoup Tag representing a track.\n        \"\"\"\n        # Prefix of the path to the audio file corresponding to this track.\n        super().__init__()\n        self.__location_prefix = (\n            \"file://localhost\" if os.name == \"posix\" else \"file://localhost/\"\n        )\n\n        # Set class attributes from TRACK Tag attributes.\n        for key, value in track.attrs.items():\n            if key in [\n                \"BitRate\",\n                \"DiscNumber\",\n                \"PlayCount\",\n                \"SampleRate\",\n                \"Size\",\n                \"TotalTime\",\n                \"TrackNumber\",\n            ]:\n                value = int(value)\n            if key == \"AverageBpm\":\n                value = float(value)\n            if key == \"DateAdded\":\n                # We need to keep the original date added string because\n                # Rekordbox doesn't format date strings consistently i.e.\n                # ensuring perfect serialization symmetry is not possible\n                # without this.\n                self.__original_date_added = value\n                value = datetime.strptime(value, \"%Y-%m-%d\")\n            if key == \"Genre\":\n                value = [x.strip() for x in value.split(\"/\")]\n            if key == \"Location\":\n                value = Path(unquote(value).split(self.__location_prefix)[-1])\n            if key == \"Rating\":\n                value = {\n                    \"0\": 0,\n                    \"51\": 1,\n                    \"102\": 2,\n                    \"153\": 3,\n                    \"204\": 4,\n                    \"255\": 5,\n                }.get(value)\n            setattr(self, f\"_{key}\", value)\n\n        # Parse MyTag data from Comments attribute.\n        my_tags = re.search(r\"(?&lt;=\\/\\*).*(?=\\*\\/)\", self._Comments)\n        self._MyTags = (  # pylint: disable=invalid-name\n            [x.strip() for x in my_tags.group().split(\"/\")] if my_tags else []\n        )\n\n        # Merge Genre and MyTag data into a new attribute.\n        self._Tags = self._Genre + self._MyTags  # pylint: disable=invalid-name\n\n        # Parse TEMPO Tags as the beat grid attribute.\n        self._beat_grid = track.find_all(\"TEMPO\")\n        if self._beat_grid:\n            self._beat_grid = [point.attrs for point in self._beat_grid]\n\n        # Parse POSITION_MARK Tags as the hot cues attribute.\n        self._hot_cues = track.find_all(\"POSITION_MARK\")\n        if self._hot_cues:\n            self._hot_cues = [hot_cue.attrs for hot_cue in self._hot_cues]\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Produces a string representation of this track.\n\n        Returns:\n            Track represented as a string.\n        \"\"\"\n        # Enforce a maximum width for a Track representation.\n        max_width = 79\n        # Eventual repr string to return.\n        string = \"{}(\\n{}\\n)\"\n        # Body of the repr string to fill out with track contents.\n        body = \" \" * 4\n\n        # Dunder members aren't represented. Public members (i.e. methods)\n        # aren't represented either.\n        repr_attrs = {\n            key[1:]: value\n            for key, value in self.__dict__.items()\n            if not (\n                key.startswith(f\"_{type(self).__name__}\")\n                or not key.startswith(\"_\")\n            )\n        }\n\n        # Build a representation of this track.\n        for key, value in repr_attrs.items():\n            # Prettify output by enforcing `max_width`.\n            if len(body.split(\"\\n\", maxsplit=-1)[-1]) &gt; max_width:\n                body += f\"\\n{' ' * 4}\"\n\n            # Rather than display each beat grid or hot cue attribute, simply\n            # represent as the number of those attributes.\n            if key in [\"beat_grid\", \"hot_cues\"]:\n                value = len(value)\n\n            # Represent string values with surrounding double quotes.\n            if isinstance(value, str):\n                value = f'\"{value}\"'\n\n            # Truncate the HH:MM:SS part of the datetime.\n            if isinstance(value, datetime):\n                value = f'\"{value.strftime(\"%Y-%m-%d\")}\"'\n\n            # Append the attribute's name and value to the representation.\n            body += f\"{key}={value}, \"\n\n        # Truncate final comma and space.\n        body = body[:-2]\n\n        return string.format(type(self).__name__, body)\n\n    def __str__(self) -&gt; str:\n        \"\"\"Produces a string representation of this track.\n\n        Returns:\n            Track represented as a string.\n        \"\"\"\n        return str(self.serialize())\n\n    def get_artists(self) -&gt; str:\n        \"\"\"Gets the track artists.\n\n        Returns:\n            A string representing the track's artists.\n        \"\"\"\n        return self._Artist\n\n    def get_bpm(self) -&gt; float:\n        \"\"\"Gets the track BPM.\n\n        Returns:\n            A float representing BPM.\n        \"\"\"\n        return self._AverageBpm\n\n    def get_comments(self) -&gt; str:\n        \"\"\"Gets the track comments.\n\n        Returns:\n            A string representing the track's comments.\n        \"\"\"\n        return self._Comments\n\n    def get_date_added(self) -&gt; str:\n        \"\"\"Gets the track's date added.\n\n        Returns:\n            A datetime representing the track's date added.\n        \"\"\"\n        return self._DateAdded\n\n    def get_genre_tags(self) -&gt; List[str]:\n        \"\"\"Gets the genre tags of the track.\n\n        Returns:\n            A list of the track's genre tags.\n        \"\"\"\n        return self._Genre\n\n    def get_id(self) -&gt; str:\n        \"\"\"Get the track ID.\n\n        Returns:\n            The ID of this track.\n        \"\"\"\n        return self._TrackID\n\n    def get_key(self) -&gt; Any:\n        \"\"\"Gets the track key.\n\n        Returns:\n            The key of this track.\n        \"\"\"\n        return self._Tonality\n\n    def get_label(self) -&gt; Any:\n        \"\"\"Gets the track label.\n\n        Returns:\n            The label of this track.\n        \"\"\"\n        return self._Label\n\n    def get_location(self) -&gt; Path:\n        \"\"\"Gets the location of the track.\n\n        Returns:\n            The Path for the location of the track.\n        \"\"\"\n        return self._Location\n\n    def get_rating(self) -&gt; int:\n        \"\"\"Gets the rating of the track.\n\n        Returns:\n            The rating of the track.\n        \"\"\"\n        return self._Rating\n\n    def get_tags(self) -&gt; List[str]:\n        \"\"\"Gets the tags of the track.\n\n        Returns:\n            A set of the track's tags.\n        \"\"\"\n        return self._Tags\n\n    def get_year(self) -&gt; str:\n        \"\"\"Gets the year of the track.\n\n        Returns:\n            The year of the track.\n        \"\"\"\n        return self._Year\n\n    def serialize(\n        self, *args, playlist: bool = False, **kwargs\n    ) -&gt; bs4.element.Tag:\n        \"\"\"Serializes this track as a BeautifulSoup TRACK Tag.\n\n        Args:\n            playlist: Whether or not to serialize this track as a member of a\n                playlist.\n\n        Raises:\n            ValueError: The DateAdded attribute must serialize into its\n                original format.\n\n        Returns:\n            BeautifulSoup Tag representing this track.\n        \"\"\"\n        # BeautifulSoup Tag to populate with attributes of this track.\n        track_tag = bs4.Tag(name=\"TRACK\", can_be_empty_element=True)\n\n        # TRACK Tags in playlists are serialized differently from top-level\n        # TRACK Tags.\n        if playlist:\n            track_tag[\"Key\"] = self.get_id()\n\n            return track_tag\n\n        # Dunder members aren't serialized. Public members (i.e. methods)\n        # aren't serialized either.\n        serialize_attrs = {\n            key[1:]: value\n            for key, value in self.__dict__.items()\n            if not (\n                key.startswith(f\"_{type(self).__name__}\")\n                or not key.startswith(\"_\")\n                or key in [\"_MyTags\", \"_Tags\"]\n            )\n        }\n\n        # Serialize attributes into a TRACK Tag.\n        for key, value in serialize_attrs.items():\n            # Beat grid and hot cue data is serialized as TEMPO and\n            # POSITION_MARK Tags, respectively.\n            if key in [\"beat_grid\", \"hot_cues\"]:\n                for val in value:\n                    tag = bs4.Tag(\n                        name=\"POSITION_MARK\" if key == \"hot_cues\" else \"TEMPO\",\n                        can_be_empty_element=True,\n                    )\n                    tag.attrs = val\n                    track_tag.extend([bs4.NavigableString(\"\\n\"), tag])\n                continue\n\n            # Cast integers back into a string.\n            if key in [\n                \"BitRate\",\n                \"DiscNumber\",\n                \"PlayCount\",\n                \"SampleRate\",\n                \"Size\",\n                \"TotalTime\",\n                \"TrackNumber\",\n            ]:\n                value = str(value)\n\n            # Increase BPM precision to make serialization 100% symmetrical.\n            if key == \"AverageBpm\":\n                value = f\"{value:0,.2f}\"\n\n            # Truncate the HH:MM:SS part of the datetime.\n            if isinstance(value, datetime):\n                # Rekordbox doesn't consistently format dates with or without\n                # leading zeros on the month and day portion of the date\n                # string, so we have to try all three of these formats to see\n                # if the resulting formatting matches the original one.\n                date_formats = [\n                    \"%Y-%m-%d\",\n                    (\"%Y-%-m-%d\" if os.name == \"posix\" else \"%Y-%#m-%d\"),\n                    (\"%Y-%-m-%-d\" if os.name == \"posix\" else \"%Y-%#m-%#d\"),\n                ]\n                for date_format in date_formats:\n                    attempt = value.strftime(date_format)\n                    if attempt == self.__original_date_added:\n                        break\n                value = attempt\n\n                if value != self.__original_date_added:\n                    raise ValueError(  # pragma: no cover\n                        f\"Failed to serialize the datetime {value} into its \"\n                        f\"original format {self.__original_date_added}\"\n                    )\n\n            # Re-join genre tags with forward slashes.\n            if key == \"Genre\":\n                value = \" / \".join(value)\n\n            # Re-insert the location prefix and quote the path.\n            if key == \"Location\":\n                track_path = quote(value.as_posix(), safe=\"/,()!+=#;$:\")\n                value = f\"{self.__location_prefix}{track_path}\"\n                value = re.sub(\n                    r\"%[0-9A-Z]{2}\", lambda x: x.group(0).lower(), value\n                )\n\n            # Reverse the rating value to the range recognized by Rekordbox.\n            if key == \"Rating\":\n                value = {\n                    0: \"0\",\n                    1: \"51\",\n                    2: \"102\",\n                    3: \"153\",\n                    4: \"204\",\n                    5: \"255\",\n                }.get(value)\n\n            # Otherwise the data is serialized as TRACK Tag attributes.\n            track_tag[key] = value\n\n        # If this TRACK Tag has children, append a final newline character.\n        if len(track_tag) &gt; 1:\n            track_tag.append(bs4.NavigableString(\"\\n\"))\n\n        return track_tag\n\n    @make_path\n    def set_location(self, location: Path):\n        \"\"\"Sets the path of the track to location.\n\n        Args:\n            location: New location of the track.\n        \"\"\"\n        self._Location = location  # pylint: disable=attribute-defined-outside-init,invalid-name\n\n    def set_track_number(self, number: int):\n        \"\"\"Sets the track number of a track.\n\n        Args:\n            number: Number to set for TrackNumber.\n        \"\"\"\n        self._TrackNumber = number  # pylint: disable=attribute-defined-outside-init,invalid-name\n</code></pre>"},{"location":"reference/collection/#djtools.collection.RekordboxTrack.__init__","title":"<code>__init__(track)</code>","text":"<p>Deserialize a track from a BeautifulSoup TRACK Tag.</p> <p>Parameters:</p> Name Type Description Default <code>track</code> <code>Tag</code> <p>BeautifulSoup Tag representing a track.</p> required Source code in <code>src/djtools/collection/rekordbox_track.py</code> <pre><code>def __init__(self, track: bs4.element.Tag):\n    \"\"\"Deserialize a track from a BeautifulSoup TRACK Tag.\n\n    Args:\n        track: BeautifulSoup Tag representing a track.\n    \"\"\"\n    # Prefix of the path to the audio file corresponding to this track.\n    super().__init__()\n    self.__location_prefix = (\n        \"file://localhost\" if os.name == \"posix\" else \"file://localhost/\"\n    )\n\n    # Set class attributes from TRACK Tag attributes.\n    for key, value in track.attrs.items():\n        if key in [\n            \"BitRate\",\n            \"DiscNumber\",\n            \"PlayCount\",\n            \"SampleRate\",\n            \"Size\",\n            \"TotalTime\",\n            \"TrackNumber\",\n        ]:\n            value = int(value)\n        if key == \"AverageBpm\":\n            value = float(value)\n        if key == \"DateAdded\":\n            # We need to keep the original date added string because\n            # Rekordbox doesn't format date strings consistently i.e.\n            # ensuring perfect serialization symmetry is not possible\n            # without this.\n            self.__original_date_added = value\n            value = datetime.strptime(value, \"%Y-%m-%d\")\n        if key == \"Genre\":\n            value = [x.strip() for x in value.split(\"/\")]\n        if key == \"Location\":\n            value = Path(unquote(value).split(self.__location_prefix)[-1])\n        if key == \"Rating\":\n            value = {\n                \"0\": 0,\n                \"51\": 1,\n                \"102\": 2,\n                \"153\": 3,\n                \"204\": 4,\n                \"255\": 5,\n            }.get(value)\n        setattr(self, f\"_{key}\", value)\n\n    # Parse MyTag data from Comments attribute.\n    my_tags = re.search(r\"(?&lt;=\\/\\*).*(?=\\*\\/)\", self._Comments)\n    self._MyTags = (  # pylint: disable=invalid-name\n        [x.strip() for x in my_tags.group().split(\"/\")] if my_tags else []\n    )\n\n    # Merge Genre and MyTag data into a new attribute.\n    self._Tags = self._Genre + self._MyTags  # pylint: disable=invalid-name\n\n    # Parse TEMPO Tags as the beat grid attribute.\n    self._beat_grid = track.find_all(\"TEMPO\")\n    if self._beat_grid:\n        self._beat_grid = [point.attrs for point in self._beat_grid]\n\n    # Parse POSITION_MARK Tags as the hot cues attribute.\n    self._hot_cues = track.find_all(\"POSITION_MARK\")\n    if self._hot_cues:\n        self._hot_cues = [hot_cue.attrs for hot_cue in self._hot_cues]\n</code></pre>"},{"location":"reference/collection/#djtools.collection.RekordboxTrack.__repr__","title":"<code>__repr__()</code>","text":"<p>Produces a string representation of this track.</p> <p>Returns:</p> Type Description <code>str</code> <p>Track represented as a string.</p> Source code in <code>src/djtools/collection/rekordbox_track.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Produces a string representation of this track.\n\n    Returns:\n        Track represented as a string.\n    \"\"\"\n    # Enforce a maximum width for a Track representation.\n    max_width = 79\n    # Eventual repr string to return.\n    string = \"{}(\\n{}\\n)\"\n    # Body of the repr string to fill out with track contents.\n    body = \" \" * 4\n\n    # Dunder members aren't represented. Public members (i.e. methods)\n    # aren't represented either.\n    repr_attrs = {\n        key[1:]: value\n        for key, value in self.__dict__.items()\n        if not (\n            key.startswith(f\"_{type(self).__name__}\")\n            or not key.startswith(\"_\")\n        )\n    }\n\n    # Build a representation of this track.\n    for key, value in repr_attrs.items():\n        # Prettify output by enforcing `max_width`.\n        if len(body.split(\"\\n\", maxsplit=-1)[-1]) &gt; max_width:\n            body += f\"\\n{' ' * 4}\"\n\n        # Rather than display each beat grid or hot cue attribute, simply\n        # represent as the number of those attributes.\n        if key in [\"beat_grid\", \"hot_cues\"]:\n            value = len(value)\n\n        # Represent string values with surrounding double quotes.\n        if isinstance(value, str):\n            value = f'\"{value}\"'\n\n        # Truncate the HH:MM:SS part of the datetime.\n        if isinstance(value, datetime):\n            value = f'\"{value.strftime(\"%Y-%m-%d\")}\"'\n\n        # Append the attribute's name and value to the representation.\n        body += f\"{key}={value}, \"\n\n    # Truncate final comma and space.\n    body = body[:-2]\n\n    return string.format(type(self).__name__, body)\n</code></pre>"},{"location":"reference/collection/#djtools.collection.RekordboxTrack.__str__","title":"<code>__str__()</code>","text":"<p>Produces a string representation of this track.</p> <p>Returns:</p> Type Description <code>str</code> <p>Track represented as a string.</p> Source code in <code>src/djtools/collection/rekordbox_track.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Produces a string representation of this track.\n\n    Returns:\n        Track represented as a string.\n    \"\"\"\n    return str(self.serialize())\n</code></pre>"},{"location":"reference/collection/#djtools.collection.RekordboxTrack.get_artists","title":"<code>get_artists()</code>","text":"<p>Gets the track artists.</p> <p>Returns:</p> Type Description <code>str</code> <p>A string representing the track's artists.</p> Source code in <code>src/djtools/collection/rekordbox_track.py</code> <pre><code>def get_artists(self) -&gt; str:\n    \"\"\"Gets the track artists.\n\n    Returns:\n        A string representing the track's artists.\n    \"\"\"\n    return self._Artist\n</code></pre>"},{"location":"reference/collection/#djtools.collection.RekordboxTrack.get_bpm","title":"<code>get_bpm()</code>","text":"<p>Gets the track BPM.</p> <p>Returns:</p> Type Description <code>float</code> <p>A float representing BPM.</p> Source code in <code>src/djtools/collection/rekordbox_track.py</code> <pre><code>def get_bpm(self) -&gt; float:\n    \"\"\"Gets the track BPM.\n\n    Returns:\n        A float representing BPM.\n    \"\"\"\n    return self._AverageBpm\n</code></pre>"},{"location":"reference/collection/#djtools.collection.RekordboxTrack.get_comments","title":"<code>get_comments()</code>","text":"<p>Gets the track comments.</p> <p>Returns:</p> Type Description <code>str</code> <p>A string representing the track's comments.</p> Source code in <code>src/djtools/collection/rekordbox_track.py</code> <pre><code>def get_comments(self) -&gt; str:\n    \"\"\"Gets the track comments.\n\n    Returns:\n        A string representing the track's comments.\n    \"\"\"\n    return self._Comments\n</code></pre>"},{"location":"reference/collection/#djtools.collection.RekordboxTrack.get_date_added","title":"<code>get_date_added()</code>","text":"<p>Gets the track's date added.</p> <p>Returns:</p> Type Description <code>str</code> <p>A datetime representing the track's date added.</p> Source code in <code>src/djtools/collection/rekordbox_track.py</code> <pre><code>def get_date_added(self) -&gt; str:\n    \"\"\"Gets the track's date added.\n\n    Returns:\n        A datetime representing the track's date added.\n    \"\"\"\n    return self._DateAdded\n</code></pre>"},{"location":"reference/collection/#djtools.collection.RekordboxTrack.get_genre_tags","title":"<code>get_genre_tags()</code>","text":"<p>Gets the genre tags of the track.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>A list of the track's genre tags.</p> Source code in <code>src/djtools/collection/rekordbox_track.py</code> <pre><code>def get_genre_tags(self) -&gt; List[str]:\n    \"\"\"Gets the genre tags of the track.\n\n    Returns:\n        A list of the track's genre tags.\n    \"\"\"\n    return self._Genre\n</code></pre>"},{"location":"reference/collection/#djtools.collection.RekordboxTrack.get_id","title":"<code>get_id()</code>","text":"<p>Get the track ID.</p> <p>Returns:</p> Type Description <code>str</code> <p>The ID of this track.</p> Source code in <code>src/djtools/collection/rekordbox_track.py</code> <pre><code>def get_id(self) -&gt; str:\n    \"\"\"Get the track ID.\n\n    Returns:\n        The ID of this track.\n    \"\"\"\n    return self._TrackID\n</code></pre>"},{"location":"reference/collection/#djtools.collection.RekordboxTrack.get_key","title":"<code>get_key()</code>","text":"<p>Gets the track key.</p> <p>Returns:</p> Type Description <code>Any</code> <p>The key of this track.</p> Source code in <code>src/djtools/collection/rekordbox_track.py</code> <pre><code>def get_key(self) -&gt; Any:\n    \"\"\"Gets the track key.\n\n    Returns:\n        The key of this track.\n    \"\"\"\n    return self._Tonality\n</code></pre>"},{"location":"reference/collection/#djtools.collection.RekordboxTrack.get_label","title":"<code>get_label()</code>","text":"<p>Gets the track label.</p> <p>Returns:</p> Type Description <code>Any</code> <p>The label of this track.</p> Source code in <code>src/djtools/collection/rekordbox_track.py</code> <pre><code>def get_label(self) -&gt; Any:\n    \"\"\"Gets the track label.\n\n    Returns:\n        The label of this track.\n    \"\"\"\n    return self._Label\n</code></pre>"},{"location":"reference/collection/#djtools.collection.RekordboxTrack.get_location","title":"<code>get_location()</code>","text":"<p>Gets the location of the track.</p> <p>Returns:</p> Type Description <code>Path</code> <p>The Path for the location of the track.</p> Source code in <code>src/djtools/collection/rekordbox_track.py</code> <pre><code>def get_location(self) -&gt; Path:\n    \"\"\"Gets the location of the track.\n\n    Returns:\n        The Path for the location of the track.\n    \"\"\"\n    return self._Location\n</code></pre>"},{"location":"reference/collection/#djtools.collection.RekordboxTrack.get_rating","title":"<code>get_rating()</code>","text":"<p>Gets the rating of the track.</p> <p>Returns:</p> Type Description <code>int</code> <p>The rating of the track.</p> Source code in <code>src/djtools/collection/rekordbox_track.py</code> <pre><code>def get_rating(self) -&gt; int:\n    \"\"\"Gets the rating of the track.\n\n    Returns:\n        The rating of the track.\n    \"\"\"\n    return self._Rating\n</code></pre>"},{"location":"reference/collection/#djtools.collection.RekordboxTrack.get_tags","title":"<code>get_tags()</code>","text":"<p>Gets the tags of the track.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>A set of the track's tags.</p> Source code in <code>src/djtools/collection/rekordbox_track.py</code> <pre><code>def get_tags(self) -&gt; List[str]:\n    \"\"\"Gets the tags of the track.\n\n    Returns:\n        A set of the track's tags.\n    \"\"\"\n    return self._Tags\n</code></pre>"},{"location":"reference/collection/#djtools.collection.RekordboxTrack.get_year","title":"<code>get_year()</code>","text":"<p>Gets the year of the track.</p> <p>Returns:</p> Type Description <code>str</code> <p>The year of the track.</p> Source code in <code>src/djtools/collection/rekordbox_track.py</code> <pre><code>def get_year(self) -&gt; str:\n    \"\"\"Gets the year of the track.\n\n    Returns:\n        The year of the track.\n    \"\"\"\n    return self._Year\n</code></pre>"},{"location":"reference/collection/#djtools.collection.RekordboxTrack.serialize","title":"<code>serialize(*args, playlist=False, **kwargs)</code>","text":"<p>Serializes this track as a BeautifulSoup TRACK Tag.</p> <p>Parameters:</p> Name Type Description Default <code>playlist</code> <code>bool</code> <p>Whether or not to serialize this track as a member of a playlist.</p> <code>False</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>The DateAdded attribute must serialize into its original format.</p> <p>Returns:</p> Type Description <code>Tag</code> <p>BeautifulSoup Tag representing this track.</p> Source code in <code>src/djtools/collection/rekordbox_track.py</code> <pre><code>def serialize(\n    self, *args, playlist: bool = False, **kwargs\n) -&gt; bs4.element.Tag:\n    \"\"\"Serializes this track as a BeautifulSoup TRACK Tag.\n\n    Args:\n        playlist: Whether or not to serialize this track as a member of a\n            playlist.\n\n    Raises:\n        ValueError: The DateAdded attribute must serialize into its\n            original format.\n\n    Returns:\n        BeautifulSoup Tag representing this track.\n    \"\"\"\n    # BeautifulSoup Tag to populate with attributes of this track.\n    track_tag = bs4.Tag(name=\"TRACK\", can_be_empty_element=True)\n\n    # TRACK Tags in playlists are serialized differently from top-level\n    # TRACK Tags.\n    if playlist:\n        track_tag[\"Key\"] = self.get_id()\n\n        return track_tag\n\n    # Dunder members aren't serialized. Public members (i.e. methods)\n    # aren't serialized either.\n    serialize_attrs = {\n        key[1:]: value\n        for key, value in self.__dict__.items()\n        if not (\n            key.startswith(f\"_{type(self).__name__}\")\n            or not key.startswith(\"_\")\n            or key in [\"_MyTags\", \"_Tags\"]\n        )\n    }\n\n    # Serialize attributes into a TRACK Tag.\n    for key, value in serialize_attrs.items():\n        # Beat grid and hot cue data is serialized as TEMPO and\n        # POSITION_MARK Tags, respectively.\n        if key in [\"beat_grid\", \"hot_cues\"]:\n            for val in value:\n                tag = bs4.Tag(\n                    name=\"POSITION_MARK\" if key == \"hot_cues\" else \"TEMPO\",\n                    can_be_empty_element=True,\n                )\n                tag.attrs = val\n                track_tag.extend([bs4.NavigableString(\"\\n\"), tag])\n            continue\n\n        # Cast integers back into a string.\n        if key in [\n            \"BitRate\",\n            \"DiscNumber\",\n            \"PlayCount\",\n            \"SampleRate\",\n            \"Size\",\n            \"TotalTime\",\n            \"TrackNumber\",\n        ]:\n            value = str(value)\n\n        # Increase BPM precision to make serialization 100% symmetrical.\n        if key == \"AverageBpm\":\n            value = f\"{value:0,.2f}\"\n\n        # Truncate the HH:MM:SS part of the datetime.\n        if isinstance(value, datetime):\n            # Rekordbox doesn't consistently format dates with or without\n            # leading zeros on the month and day portion of the date\n            # string, so we have to try all three of these formats to see\n            # if the resulting formatting matches the original one.\n            date_formats = [\n                \"%Y-%m-%d\",\n                (\"%Y-%-m-%d\" if os.name == \"posix\" else \"%Y-%#m-%d\"),\n                (\"%Y-%-m-%-d\" if os.name == \"posix\" else \"%Y-%#m-%#d\"),\n            ]\n            for date_format in date_formats:\n                attempt = value.strftime(date_format)\n                if attempt == self.__original_date_added:\n                    break\n            value = attempt\n\n            if value != self.__original_date_added:\n                raise ValueError(  # pragma: no cover\n                    f\"Failed to serialize the datetime {value} into its \"\n                    f\"original format {self.__original_date_added}\"\n                )\n\n        # Re-join genre tags with forward slashes.\n        if key == \"Genre\":\n            value = \" / \".join(value)\n\n        # Re-insert the location prefix and quote the path.\n        if key == \"Location\":\n            track_path = quote(value.as_posix(), safe=\"/,()!+=#;$:\")\n            value = f\"{self.__location_prefix}{track_path}\"\n            value = re.sub(\n                r\"%[0-9A-Z]{2}\", lambda x: x.group(0).lower(), value\n            )\n\n        # Reverse the rating value to the range recognized by Rekordbox.\n        if key == \"Rating\":\n            value = {\n                0: \"0\",\n                1: \"51\",\n                2: \"102\",\n                3: \"153\",\n                4: \"204\",\n                5: \"255\",\n            }.get(value)\n\n        # Otherwise the data is serialized as TRACK Tag attributes.\n        track_tag[key] = value\n\n    # If this TRACK Tag has children, append a final newline character.\n    if len(track_tag) &gt; 1:\n        track_tag.append(bs4.NavigableString(\"\\n\"))\n\n    return track_tag\n</code></pre>"},{"location":"reference/collection/#djtools.collection.RekordboxTrack.set_location","title":"<code>set_location(location)</code>","text":"<p>Sets the path of the track to location.</p> <p>Parameters:</p> Name Type Description Default <code>location</code> <code>Path</code> <p>New location of the track.</p> required Source code in <code>src/djtools/collection/rekordbox_track.py</code> <pre><code>@make_path\ndef set_location(self, location: Path):\n    \"\"\"Sets the path of the track to location.\n\n    Args:\n        location: New location of the track.\n    \"\"\"\n    self._Location = location  # pylint: disable=attribute-defined-outside-init,invalid-name\n</code></pre>"},{"location":"reference/collection/#djtools.collection.RekordboxTrack.set_track_number","title":"<code>set_track_number(number)</code>","text":"<p>Sets the track number of a track.</p> <p>Parameters:</p> Name Type Description Default <code>number</code> <code>int</code> <p>Number to set for TrackNumber.</p> required Source code in <code>src/djtools/collection/rekordbox_track.py</code> <pre><code>def set_track_number(self, number: int):\n    \"\"\"Sets the track number of a track.\n\n    Args:\n        number: Number to set for TrackNumber.\n    \"\"\"\n    self._TrackNumber = number  # pylint: disable=attribute-defined-outside-init,invalid-name\n</code></pre>"},{"location":"reference/collection/#djtools.collection.collection_playlists","title":"<code>collection_playlists(config, path=None)</code>","text":"<p>Builds playlists automatically.</p> <p>By maintaining a collection with tracks having tag data (e.g. genre tags, Rekordbox's \"My Tags\", etc.) and providing a playlist config which specifies a desired playlist structure based around these tags, users can automatically generate that playlist structure.</p> <p>The playlist config is a YAML file which specifies a nested structure of folders. Each folder is declared with a \"name\" and a list of \"playlists\" which may be either more folder declarations or else strings matching a tag in your collection.</p> <p>Any folder that has more than one playlist within it will automatically have an \"All \" playlist added to it that contains the set of tracks from all the other playlists in that folder. <p>Any tag in your collection that is not specified in the playlist config will automatically be added to either an \"Other\" folder of playlists or an \"Other\" playlist (depending on your configured choice for collection_playlists_remainder).</p> <p>A special folder with the name \"_ignore\" may be included anywhere within the \"tags\" specification with playlists matching the set of tags to ignore when creating the \"Other\" folder / playlist.</p> <p>In addition to creating playlists from tags, this function also supports creating \"combiner\" playlists by evaluating boolean algebra expressions. This is an incredibly powerful feature which allows users to apply set operations {union, intersection, and difference} to a diverse range of operands {tag, playlists, BPMs, ratings, etc.}.</p> <p>Combiner playlists are declared in the \"combiner\" specification of the playlist config with playlists whose names are the boolean algebra expressions used to construct them.</p> <p>Here's an example combiner playlist to illustrate this:</p> <pre><code>((Dubstep ~ [1-3]) | {playlist: My Favorites} | (*Techno &amp; [135-145])) &amp; Dark\n</code></pre> <p>The resulting combiner playlist will be comprised of tracks that are:</p> <ul> <li>tagged as \"Dubstep\" but NOT having a rating less than 4</li> <li>OR in the playlist called \"My Favorites\"</li> <li>OR tagged as something ending with \"Techno\" AND in the BPM range of 135 to 145</li> <li>AND tagged as \"Dark\"</li> </ul> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>BaseConfig</code> <p>Configuration object.</p> required <code>path</code> <code>Optional[Path]</code> <p>Path to write the new collection to.</p> <code>None</code> Source code in <code>src/djtools/collection/playlist_builder.py</code> <pre><code>@make_path\ndef collection_playlists(config: BaseConfig, path: Optional[Path] = None):\n    \"\"\"Builds playlists automatically.\n\n    By maintaining a collection with tracks having tag data (e.g. genre tags,\n    Rekordbox's \"My Tags\", etc.) and providing a playlist config which\n    specifies a desired playlist structure based around these tags, users can\n    automatically generate that playlist structure.\n\n    The playlist config is a YAML file which specifies a nested structure of\n    folders. Each folder is declared with a \"name\" and a list of \"playlists\"\n    which may be either more folder declarations or else strings matching a tag\n    in your collection.\n\n    Any folder that has more than one playlist within it will automatically\n    have an \"All &lt;folder name&gt;\" playlist added to it that contains the set of\n    tracks from all the other playlists in that folder.\n\n    Any tag in your collection that is not specified in the playlist config\n    will automatically be added to either an \"Other\" folder of playlists or an\n    \"Other\" playlist (depending on your configured choice for\n    collection_playlists_remainder).\n\n    A special folder with the name \"_ignore\" may be included anywhere within\n    the \"tags\" specification with playlists matching the set of tags to ignore\n    when creating the \"Other\" folder / playlist.\n\n    In addition to creating playlists from tags, this function also supports\n    creating \"combiner\" playlists by evaluating boolean algebra expressions.\n    This is an incredibly powerful feature which allows users to apply set\n    operations {union, intersection, and difference} to a diverse range of\n    operands {tag, playlists, BPMs, ratings, etc.}.\n\n    Combiner playlists are declared in the \"combiner\" specification of the\n    playlist config with playlists whose names are the boolean algebra\n    expressions used to construct them.\n\n    Here's an example combiner playlist to illustrate this:\n\n        ((Dubstep ~ [1-3]) | {playlist: My Favorites} | (*Techno &amp; [135-145])) &amp; Dark\n\n    The resulting combiner playlist will be comprised of tracks that are:\n\n    - tagged as \"Dubstep\" but NOT having a rating less than 4\n    - OR in the playlist called \"My Favorites\"\n    - OR tagged as something ending with \"Techno\" AND in the BPM range of 135\n    to 145\n    - AND tagged as \"Dark\"\n\n    Args:\n        config: Configuration object.\n        path: Path to write the new collection to.\n    \"\"\"\n    # Check if the playlist config is populated before continuing.\n    if not (\n        config.collection.playlist_config.tags\n        or config.collection.playlist_config.combiner\n    ):\n        logger.warning(\n            \"Not building playlists because the playlist config is empty.\"\n        )\n        return\n\n    # Load the collection.\n    collection = PLATFORM_REGISTRY[config.collection.platform][\"collection\"](\n        path=config.collection.collection_path\n    )\n\n    # Get the Playlist implementation to use for this collection.\n    playlist_class = PLATFORM_REGISTRY[config.collection.platform][\"playlist\"]\n\n    # Required number of tracks to make tag and combiner playlists.\n    minimum_tag_tracks = config.collection.minimum_tag_playlist_tracks\n    minimum_combiner_tracks = (\n        config.collection.minimum_combiner_playlist_tracks\n    )\n\n    # Create a dict of tracks keyed by their individual tags.\n    tags_tracks = defaultdict(dict)\n    for track_id, track in collection.get_tracks().items():\n        for tag in track.get_tags():\n            tags_tracks[tag][track_id] = track\n\n    # This will hold the playlists being built.\n    auto_playlists = []\n\n    # List of PlaylistFilter implementations to run against built playlists.\n    filters = [\n        getattr(playlist_filters, playlist_filter.value)()\n        for playlist_filter in config.collection.collection_playlist_filters\n    ]\n\n    # Create playlists for the \"tags\" portion of the playlist config.\n    if config.collection.playlist_config.tags:\n        # A set of tags seen is maintained while creating the tags playlists so\n        # that they are ignored when creating the \"Other\" playlists.\n        seen_tags = set()\n        tag_playlists = build_tag_playlists(\n            config.collection.playlist_config.tags,\n            tags_tracks,\n            playlist_class,\n            seen_tags,\n            minimum_tracks=minimum_tag_tracks,\n        )\n\n        # The tag playlists must have their \"parent\" attribute set so that\n        # PlaylistFilter implementations may apply logic that depends on the\n        # relative position of the playlist with the playlist tree.\n        tag_playlists.set_parent()\n\n        # Apply the filtering logic of the configured PlaylistFilter implementations.\n        filter_tag_playlists(tag_playlists, filters)\n\n        # Recursively traverse the playlist tree and create \"all\" playlists\n        # within each folder containing more than one playlist. These \"all\"\n        # playlists aggregate the set of tracks contained within all the other\n        # playlists within the same folder.\n        _ = aggregate_playlists(\n            tag_playlists, playlist_class, minimum_tag_tracks\n        )\n\n        auto_playlists.extend(tag_playlists)\n\n        # Identify the set of tags that did not appear in the playlist config\n        # and create either an \"Other\" folder of playlists or simply an \"Other\"\n        # playlist.\n        other_tags = sorted(set(tags_tracks).difference(seen_tags))\n        if (\n            config.collection.collection_playlists_remainder\n            == PlaylistRemainder.FOLDER\n        ):\n            auto_playlists.append(\n                build_tag_playlists(\n                    PlaylistConfigContent(\n                        name=\"Unused Tags\", playlists=other_tags\n                    ),\n                    tags_tracks,\n                    playlist_class,\n                    minimum_tracks=minimum_tag_tracks,\n                )\n            )\n        else:\n            auto_playlists.append(\n                build_tag_playlists(\n                    \"Unused Tags\",\n                    {\n                        \"Unused Tags\": {\n                            track_id: track\n                            for tag, track_dict in tags_tracks.items()\n                            for track_id, track in track_dict.items()\n                            if tag in other_tags\n                        }\n                    },\n                    playlist_class,\n                    minimum_tracks=minimum_tag_tracks,\n                )\n            )\n\n    # Create playlists for the \"combiner\" portion of the playlist config.\n    if config.collection.playlist_config.combiner:\n        # Parse selectors from the combiner playlist names and update the\n        # tags_tracks mapping.\n        add_selectors_to_tags(\n            config.collection.playlist_config.combiner,\n            tags_tracks,\n            collection,\n            auto_playlists,\n        )\n\n        # Evaluate the boolean logic of the combiner playlists.\n        combiner_playlists = build_combiner_playlists(\n            config.collection.playlist_config.combiner,\n            tags_tracks,\n            playlist_class,\n            minimum_tracks=minimum_combiner_tracks,\n        )\n\n        # The tag playlists must have their \"parent\" attribute set so that\n        # PlaylistFilter implementations may apply logic that depends on the\n        # relative position of the playlist with the playlist tree.\n        combiner_playlists.set_parent()\n\n        # Apply the filtering logic of the configured PlaylistFilter implementations.\n        filter_tag_playlists(combiner_playlists, filters)\n\n        # Recursively traverse the playlist tree and create \"all\" playlists\n        # within each folder containing more than one playlist. These \"all\"\n        # playlists aggregate the set of tracks contained within all the other\n        # playlists within the same folder.\n        _ = aggregate_playlists(\n            combiner_playlists, playlist_class, minimum_combiner_tracks\n        )\n\n        auto_playlists.extend(combiner_playlists)\n\n        # Print tag statistics for each combiner playlist.\n        if config.verbosity and combiner_playlists:\n            print_playlists_tag_statistics(combiner_playlists)\n\n    # Remove any previous playlist builder playlists.\n    previous_playlists = collection.get_playlists(name=PLAYLIST_NAME)\n    root = collection.get_playlists()\n    for playlist in previous_playlists:\n        root.remove_playlist(playlist)\n\n    # Insert a new playlist containing the built playlists.\n    auto_playlist = playlist_class.new_playlist(\n        name=PLAYLIST_NAME, playlists=auto_playlists\n    )\n    auto_playlist.set_parent(collection.get_playlists())\n    collection.add_playlist(auto_playlist)\n    collection.serialize(path=path)\n\n    num_playlists = collection.get_playlists().get_number_of_playlists()\n    logger.info(f\"{PLAYLIST_NAME} generated with {num_playlists} playlists\")\n</code></pre> <p>This module contains the configuration objects for the collection package. The attributes of this configuration object correspond with the \"collection\" key of config.yaml</p> <p>This module is used to automatically generate a playlist structure.</p>"},{"location":"reference/collection/#djtools.collection.config.CollectionConfig","title":"<code>CollectionConfig</code>","text":"<p>               Bases: <code>BaseConfigFormatter</code></p> <p>Configuration object for the collection package.</p> Source code in <code>src/djtools/collection/config.py</code> <pre><code>class CollectionConfig(BaseConfigFormatter):\n    \"\"\"Configuration object for the collection package.\"\"\"\n\n    collection_path: Optional[Path] = None\n    collection_playlist_filters: List[PlaylistFilters] = []\n    collection_playlists: bool = False\n    collection_playlists_remainder: PlaylistRemainder = (\n        PlaylistRemainder.FOLDER\n    )\n    copy_playlists: List[str] = []\n    copy_playlists_destination: Optional[Path] = None\n    minimum_combiner_playlist_tracks: Optional[PositiveInt] = None\n    minimum_tag_playlist_tracks: Optional[PositiveInt] = None\n    platform: RegisteredPlatforms = RegisteredPlatforms.REKORDBOX\n    shuffle_playlists: List[str] = []\n    playlist_config: Optional[\"PlaylistConfig\"] = None\n\n    def __init__(self, *args, **kwargs):\n        \"\"\"Constructor.\n\n        Raises:\n            RuntimeError: Using the collection package requires a valid\n                collection_path.\n            RuntimeError: Failed to render collection_playlist.yaml from\n                template.\n            RuntimeError: collection_path must be a valid collection path.\n            RuntimeError: collection_playlists.yaml must be a valid YAML file.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n\n        if any(\n            [\n                self.collection_playlists,\n                self.copy_playlists,\n                self.shuffle_playlists,\n            ]\n        ) and (not self.collection_path or not self.collection_path.exists()):\n            raise RuntimeError(\n                \"Using the collection package requires the config option \"\n                \"collection_path to be a valid collection path\"\n            )\n\n        if self.collection_playlists:\n            config_path = Path(__file__).parent.parent / \"configs\"\n            env = Environment(\n                loader=FileSystemLoader(config_path / \"playlist_templates\")\n            )\n            playlist_template = None\n            playlist_template_name = \"collection_playlists.j2\"\n            playlist_config_path = config_path / \"collection_playlists.yaml\"\n\n            try:\n                playlist_template = env.get_template(playlist_template_name)\n            except TemplateNotFound:\n                pass\n\n            if playlist_template:\n                try:\n                    playlist_config = playlist_template.render()\n                except Exception as exc:\n                    raise RuntimeError(\n                        f\"Failed to render {playlist_template_name}: {exc}\"\n                    ) from exc\n\n                if playlist_config_path.exists():\n                    logger.warning(\n                        f\"Both {playlist_template_name} and \"\n                        f\"{playlist_config_path.name} exist. Overwriting \"\n                        f\"{playlist_config_path.name} with the rendered \"\n                        \"template\"\n                    )\n\n                with open(\n                    playlist_config_path, mode=\"w\", encoding=\"utf-8\"\n                ) as _file:\n                    _file.write(playlist_config)\n\n            if not playlist_config_path.exists():\n                raise RuntimeError(\n                    \"collection_playlists.yaml must exist to use the \"\n                    \"collection_playlists feature\"\n                )\n\n            try:\n                with open(\n                    playlist_config_path, mode=\"r\", encoding=\"utf-8\"\n                ) as _file:\n                    self.playlist_config = PlaylistConfig(\n                        **yaml.load(_file, Loader=yaml.FullLoader) or {}\n                    )\n            except ValidationError as exc:\n                raise RuntimeError(\n                    \"collection_playlists.yaml must be a valid YAML to use \"\n                    \"the collection_playlists feature\"\n                ) from exc\n</code></pre>"},{"location":"reference/collection/#djtools.collection.config.CollectionConfig.__init__","title":"<code>__init__(*args, **kwargs)</code>","text":"<p>Constructor.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>Using the collection package requires a valid collection_path.</p> <code>RuntimeError</code> <p>Failed to render collection_playlist.yaml from template.</p> <code>RuntimeError</code> <p>collection_path must be a valid collection path.</p> <code>RuntimeError</code> <p>collection_playlists.yaml must be a valid YAML file.</p> Source code in <code>src/djtools/collection/config.py</code> <pre><code>def __init__(self, *args, **kwargs):\n    \"\"\"Constructor.\n\n    Raises:\n        RuntimeError: Using the collection package requires a valid\n            collection_path.\n        RuntimeError: Failed to render collection_playlist.yaml from\n            template.\n        RuntimeError: collection_path must be a valid collection path.\n        RuntimeError: collection_playlists.yaml must be a valid YAML file.\n    \"\"\"\n    super().__init__(*args, **kwargs)\n\n    if any(\n        [\n            self.collection_playlists,\n            self.copy_playlists,\n            self.shuffle_playlists,\n        ]\n    ) and (not self.collection_path or not self.collection_path.exists()):\n        raise RuntimeError(\n            \"Using the collection package requires the config option \"\n            \"collection_path to be a valid collection path\"\n        )\n\n    if self.collection_playlists:\n        config_path = Path(__file__).parent.parent / \"configs\"\n        env = Environment(\n            loader=FileSystemLoader(config_path / \"playlist_templates\")\n        )\n        playlist_template = None\n        playlist_template_name = \"collection_playlists.j2\"\n        playlist_config_path = config_path / \"collection_playlists.yaml\"\n\n        try:\n            playlist_template = env.get_template(playlist_template_name)\n        except TemplateNotFound:\n            pass\n\n        if playlist_template:\n            try:\n                playlist_config = playlist_template.render()\n            except Exception as exc:\n                raise RuntimeError(\n                    f\"Failed to render {playlist_template_name}: {exc}\"\n                ) from exc\n\n            if playlist_config_path.exists():\n                logger.warning(\n                    f\"Both {playlist_template_name} and \"\n                    f\"{playlist_config_path.name} exist. Overwriting \"\n                    f\"{playlist_config_path.name} with the rendered \"\n                    \"template\"\n                )\n\n            with open(\n                playlist_config_path, mode=\"w\", encoding=\"utf-8\"\n            ) as _file:\n                _file.write(playlist_config)\n\n        if not playlist_config_path.exists():\n            raise RuntimeError(\n                \"collection_playlists.yaml must exist to use the \"\n                \"collection_playlists feature\"\n            )\n\n        try:\n            with open(\n                playlist_config_path, mode=\"r\", encoding=\"utf-8\"\n            ) as _file:\n                self.playlist_config = PlaylistConfig(\n                    **yaml.load(_file, Loader=yaml.FullLoader) or {}\n                )\n        except ValidationError as exc:\n            raise RuntimeError(\n                \"collection_playlists.yaml must be a valid YAML to use \"\n                \"the collection_playlists feature\"\n            ) from exc\n</code></pre>"},{"location":"reference/collection/#djtools.collection.config.PlaylistConfig","title":"<code>PlaylistConfig</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A class for type checking the playlist config YAML.</p> Source code in <code>src/djtools/collection/config.py</code> <pre><code>class PlaylistConfig(BaseModel, extra=\"forbid\"):\n    \"A class for type checking the playlist config YAML.\"\n\n    combiner: Optional[PlaylistConfigContent] = None\n    tags: Optional[PlaylistConfigContent] = None\n</code></pre>"},{"location":"reference/collection/#djtools.collection.config.PlaylistConfigContent","title":"<code>PlaylistConfigContent</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A class for type checking the content of the playlist config YAML.</p> Source code in <code>src/djtools/collection/config.py</code> <pre><code>class PlaylistConfigContent(BaseModel, extra=\"forbid\"):\n    \"A class for type checking the content of the playlist config YAML.\"\n\n    name: str\n    playlists: List[Union[\"PlaylistConfigContent\", PlaylistName, str]]\n    enable_aggregation: Optional[bool] = None\n</code></pre>"},{"location":"reference/collection/#djtools.collection.config.PlaylistFilters","title":"<code>PlaylistFilters</code>","text":"<p>               Bases: <code>Enum</code></p> <p>PlaylistFilters enum.</p> Source code in <code>src/djtools/collection/config.py</code> <pre><code>class PlaylistFilters(Enum):\n    \"\"\"PlaylistFilters enum.\"\"\"\n\n    COMPLEX_TRACK_FILTER = \"ComplexTrackFilter\"\n    HIPHOP_FILTER = \"HipHopFilter\"\n    MINIMAL_DEEP_TECH_FILTER = \"MinimalDeepTechFilter\"\n    TRANSITION_TRACK_FILTER = \"TransitionTrackFilter\"\n</code></pre>"},{"location":"reference/collection/#djtools.collection.config.PlaylistName","title":"<code>PlaylistName</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A class for configuring the names of playlists.</p> Source code in <code>src/djtools/collection/config.py</code> <pre><code>class PlaylistName(BaseModel, extra=\"forbid\"):\n    \"A class for configuring the names of playlists.\"\n\n    tag_content: str\n    name: Optional[str] = None\n</code></pre>"},{"location":"reference/collection/#djtools.collection.config.PlaylistRemainder","title":"<code>PlaylistRemainder</code>","text":"<p>               Bases: <code>Enum</code></p> <p>PlaylistRemainder enum.</p> Source code in <code>src/djtools/collection/config.py</code> <pre><code>class PlaylistRemainder(Enum):\n    \"\"\"PlaylistRemainder enum.\"\"\"\n\n    FOLDER = \"folder\"\n    PLAYLIST = \"playlist\"\n</code></pre>"},{"location":"reference/collection/#djtools.collection.config.RegisteredPlatforms","title":"<code>RegisteredPlatforms</code>","text":"<p>               Bases: <code>Enum</code></p> <p>RegisteredPlatforms enum.</p> Source code in <code>src/djtools/collection/config.py</code> <pre><code>class RegisteredPlatforms(Enum):\n    \"\"\"RegisteredPlatforms enum.\"\"\"\n\n    REKORDBOX = \"rekordbox\"\n</code></pre>"},{"location":"reference/collection/#djtools.collection.playlist_builder.collection_playlists","title":"<code>collection_playlists(config, path=None)</code>","text":"<p>Builds playlists automatically.</p> <p>By maintaining a collection with tracks having tag data (e.g. genre tags, Rekordbox's \"My Tags\", etc.) and providing a playlist config which specifies a desired playlist structure based around these tags, users can automatically generate that playlist structure.</p> <p>The playlist config is a YAML file which specifies a nested structure of folders. Each folder is declared with a \"name\" and a list of \"playlists\" which may be either more folder declarations or else strings matching a tag in your collection.</p> <p>Any folder that has more than one playlist within it will automatically have an \"All \" playlist added to it that contains the set of tracks from all the other playlists in that folder. <p>Any tag in your collection that is not specified in the playlist config will automatically be added to either an \"Other\" folder of playlists or an \"Other\" playlist (depending on your configured choice for collection_playlists_remainder).</p> <p>A special folder with the name \"_ignore\" may be included anywhere within the \"tags\" specification with playlists matching the set of tags to ignore when creating the \"Other\" folder / playlist.</p> <p>In addition to creating playlists from tags, this function also supports creating \"combiner\" playlists by evaluating boolean algebra expressions. This is an incredibly powerful feature which allows users to apply set operations {union, intersection, and difference} to a diverse range of operands {tag, playlists, BPMs, ratings, etc.}.</p> <p>Combiner playlists are declared in the \"combiner\" specification of the playlist config with playlists whose names are the boolean algebra expressions used to construct them.</p> <p>Here's an example combiner playlist to illustrate this:</p> <pre><code>((Dubstep ~ [1-3]) | {playlist: My Favorites} | (*Techno &amp; [135-145])) &amp; Dark\n</code></pre> <p>The resulting combiner playlist will be comprised of tracks that are:</p> <ul> <li>tagged as \"Dubstep\" but NOT having a rating less than 4</li> <li>OR in the playlist called \"My Favorites\"</li> <li>OR tagged as something ending with \"Techno\" AND in the BPM range of 135 to 145</li> <li>AND tagged as \"Dark\"</li> </ul> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>BaseConfig</code> <p>Configuration object.</p> required <code>path</code> <code>Optional[Path]</code> <p>Path to write the new collection to.</p> <code>None</code> Source code in <code>src/djtools/collection/playlist_builder.py</code> <pre><code>@make_path\ndef collection_playlists(config: BaseConfig, path: Optional[Path] = None):\n    \"\"\"Builds playlists automatically.\n\n    By maintaining a collection with tracks having tag data (e.g. genre tags,\n    Rekordbox's \"My Tags\", etc.) and providing a playlist config which\n    specifies a desired playlist structure based around these tags, users can\n    automatically generate that playlist structure.\n\n    The playlist config is a YAML file which specifies a nested structure of\n    folders. Each folder is declared with a \"name\" and a list of \"playlists\"\n    which may be either more folder declarations or else strings matching a tag\n    in your collection.\n\n    Any folder that has more than one playlist within it will automatically\n    have an \"All &lt;folder name&gt;\" playlist added to it that contains the set of\n    tracks from all the other playlists in that folder.\n\n    Any tag in your collection that is not specified in the playlist config\n    will automatically be added to either an \"Other\" folder of playlists or an\n    \"Other\" playlist (depending on your configured choice for\n    collection_playlists_remainder).\n\n    A special folder with the name \"_ignore\" may be included anywhere within\n    the \"tags\" specification with playlists matching the set of tags to ignore\n    when creating the \"Other\" folder / playlist.\n\n    In addition to creating playlists from tags, this function also supports\n    creating \"combiner\" playlists by evaluating boolean algebra expressions.\n    This is an incredibly powerful feature which allows users to apply set\n    operations {union, intersection, and difference} to a diverse range of\n    operands {tag, playlists, BPMs, ratings, etc.}.\n\n    Combiner playlists are declared in the \"combiner\" specification of the\n    playlist config with playlists whose names are the boolean algebra\n    expressions used to construct them.\n\n    Here's an example combiner playlist to illustrate this:\n\n        ((Dubstep ~ [1-3]) | {playlist: My Favorites} | (*Techno &amp; [135-145])) &amp; Dark\n\n    The resulting combiner playlist will be comprised of tracks that are:\n\n    - tagged as \"Dubstep\" but NOT having a rating less than 4\n    - OR in the playlist called \"My Favorites\"\n    - OR tagged as something ending with \"Techno\" AND in the BPM range of 135\n    to 145\n    - AND tagged as \"Dark\"\n\n    Args:\n        config: Configuration object.\n        path: Path to write the new collection to.\n    \"\"\"\n    # Check if the playlist config is populated before continuing.\n    if not (\n        config.collection.playlist_config.tags\n        or config.collection.playlist_config.combiner\n    ):\n        logger.warning(\n            \"Not building playlists because the playlist config is empty.\"\n        )\n        return\n\n    # Load the collection.\n    collection = PLATFORM_REGISTRY[config.collection.platform][\"collection\"](\n        path=config.collection.collection_path\n    )\n\n    # Get the Playlist implementation to use for this collection.\n    playlist_class = PLATFORM_REGISTRY[config.collection.platform][\"playlist\"]\n\n    # Required number of tracks to make tag and combiner playlists.\n    minimum_tag_tracks = config.collection.minimum_tag_playlist_tracks\n    minimum_combiner_tracks = (\n        config.collection.minimum_combiner_playlist_tracks\n    )\n\n    # Create a dict of tracks keyed by their individual tags.\n    tags_tracks = defaultdict(dict)\n    for track_id, track in collection.get_tracks().items():\n        for tag in track.get_tags():\n            tags_tracks[tag][track_id] = track\n\n    # This will hold the playlists being built.\n    auto_playlists = []\n\n    # List of PlaylistFilter implementations to run against built playlists.\n    filters = [\n        getattr(playlist_filters, playlist_filter.value)()\n        for playlist_filter in config.collection.collection_playlist_filters\n    ]\n\n    # Create playlists for the \"tags\" portion of the playlist config.\n    if config.collection.playlist_config.tags:\n        # A set of tags seen is maintained while creating the tags playlists so\n        # that they are ignored when creating the \"Other\" playlists.\n        seen_tags = set()\n        tag_playlists = build_tag_playlists(\n            config.collection.playlist_config.tags,\n            tags_tracks,\n            playlist_class,\n            seen_tags,\n            minimum_tracks=minimum_tag_tracks,\n        )\n\n        # The tag playlists must have their \"parent\" attribute set so that\n        # PlaylistFilter implementations may apply logic that depends on the\n        # relative position of the playlist with the playlist tree.\n        tag_playlists.set_parent()\n\n        # Apply the filtering logic of the configured PlaylistFilter implementations.\n        filter_tag_playlists(tag_playlists, filters)\n\n        # Recursively traverse the playlist tree and create \"all\" playlists\n        # within each folder containing more than one playlist. These \"all\"\n        # playlists aggregate the set of tracks contained within all the other\n        # playlists within the same folder.\n        _ = aggregate_playlists(\n            tag_playlists, playlist_class, minimum_tag_tracks\n        )\n\n        auto_playlists.extend(tag_playlists)\n\n        # Identify the set of tags that did not appear in the playlist config\n        # and create either an \"Other\" folder of playlists or simply an \"Other\"\n        # playlist.\n        other_tags = sorted(set(tags_tracks).difference(seen_tags))\n        if (\n            config.collection.collection_playlists_remainder\n            == PlaylistRemainder.FOLDER\n        ):\n            auto_playlists.append(\n                build_tag_playlists(\n                    PlaylistConfigContent(\n                        name=\"Unused Tags\", playlists=other_tags\n                    ),\n                    tags_tracks,\n                    playlist_class,\n                    minimum_tracks=minimum_tag_tracks,\n                )\n            )\n        else:\n            auto_playlists.append(\n                build_tag_playlists(\n                    \"Unused Tags\",\n                    {\n                        \"Unused Tags\": {\n                            track_id: track\n                            for tag, track_dict in tags_tracks.items()\n                            for track_id, track in track_dict.items()\n                            if tag in other_tags\n                        }\n                    },\n                    playlist_class,\n                    minimum_tracks=minimum_tag_tracks,\n                )\n            )\n\n    # Create playlists for the \"combiner\" portion of the playlist config.\n    if config.collection.playlist_config.combiner:\n        # Parse selectors from the combiner playlist names and update the\n        # tags_tracks mapping.\n        add_selectors_to_tags(\n            config.collection.playlist_config.combiner,\n            tags_tracks,\n            collection,\n            auto_playlists,\n        )\n\n        # Evaluate the boolean logic of the combiner playlists.\n        combiner_playlists = build_combiner_playlists(\n            config.collection.playlist_config.combiner,\n            tags_tracks,\n            playlist_class,\n            minimum_tracks=minimum_combiner_tracks,\n        )\n\n        # The tag playlists must have their \"parent\" attribute set so that\n        # PlaylistFilter implementations may apply logic that depends on the\n        # relative position of the playlist with the playlist tree.\n        combiner_playlists.set_parent()\n\n        # Apply the filtering logic of the configured PlaylistFilter implementations.\n        filter_tag_playlists(combiner_playlists, filters)\n\n        # Recursively traverse the playlist tree and create \"all\" playlists\n        # within each folder containing more than one playlist. These \"all\"\n        # playlists aggregate the set of tracks contained within all the other\n        # playlists within the same folder.\n        _ = aggregate_playlists(\n            combiner_playlists, playlist_class, minimum_combiner_tracks\n        )\n\n        auto_playlists.extend(combiner_playlists)\n\n        # Print tag statistics for each combiner playlist.\n        if config.verbosity and combiner_playlists:\n            print_playlists_tag_statistics(combiner_playlists)\n\n    # Remove any previous playlist builder playlists.\n    previous_playlists = collection.get_playlists(name=PLAYLIST_NAME)\n    root = collection.get_playlists()\n    for playlist in previous_playlists:\n        root.remove_playlist(playlist)\n\n    # Insert a new playlist containing the built playlists.\n    auto_playlist = playlist_class.new_playlist(\n        name=PLAYLIST_NAME, playlists=auto_playlists\n    )\n    auto_playlist.set_parent(collection.get_playlists())\n    collection.add_playlist(auto_playlist)\n    collection.serialize(path=path)\n\n    num_playlists = collection.get_playlists().get_number_of_playlists()\n    logger.info(f\"{PLAYLIST_NAME} generated with {num_playlists} playlists\")\n</code></pre> <p>This module contains the PlaylistFilter abstract base class and its implementations.</p> <p>PlaylistFilter subclasses implement an 'is_filter_playlist' method and a 'filter_track' method.</p> <p>The 'is_filter_playlist' method, when given a 'Playlist', returns true if that 'Playlist' should have its tracks filtered.</p> <p>The 'filter_track' method, when given a 'Track', returns true if that 'Track' should remain in the playlist.</p> <p>This module is used to emulate shuffling the track order of one or more playlists. This is done by setting the track number attribute of each track in sequential order after collecting the set of Tracks from the provided playlist(s).</p> <p>This module is used to copy the audio files from the provided playlists to a new location and serialize a new collection with those tracks pointing to these new locations.</p> <p>The purpose of this utility is to:</p> <ul> <li>backup subsets of your library</li> <li>ensure you have easy access to a preparation independent of the setup</li> </ul> <p>This module contains helpers for the collection package.</p>"},{"location":"reference/collection/#djtools.collection.playlist_filters.ComplexTrackFilter","title":"<code>ComplexTrackFilter</code>","text":"<p>               Bases: <code>PlaylistFilter</code></p> <p>This class filters \"complex\" playlists.</p> <p>This PlaylistFilter looks for playlists with \"complex\" in their name or in the name of a parent playlist. When found, tracks contained in the playlist must have no less than 'min_tags_for_complex_track' in order to remain in the playlist.</p> Source code in <code>src/djtools/collection/playlist_filters.py</code> <pre><code>class ComplexTrackFilter(PlaylistFilter):\n    \"\"\"This class filters \"complex\" playlists.\n\n    This PlaylistFilter looks for playlists with \"complex\" in their name or in\n    the name of a parent playlist. When found, tracks contained in the playlist\n    must have no less than 'min_tags_for_complex_track' in order to remain in\n    the playlist.\n    \"\"\"\n\n    def __init__(\n        self,\n        min_tags_for_complex_track: Optional[int] = 3,\n        exclude_tags: Optional[List[str]] = None,\n    ):\n        \"\"\"Constructor.\n\n        Args:\n            min_tags_for_complex_track: Maximum number of non-genre tags before\n                a track is no longer considered \"complex\".\n            exclude_tags: Tags to ignore when determining the number of\n                non-genre tags.\n        \"\"\"\n        super().__init__()\n        self._min_tags_for_complex_track = min_tags_for_complex_track\n        if exclude_tags is None:\n            exclude_tags = [\n                \"DELETE\",\n                \"Flute\",\n                \"Guitar\",\n                \"Horn\",\n                \"Piano\",\n                \"Scratch\",\n                \"Strings\",\n                \"Vocal\",\n            ]\n        self._exclude_tags = set(exclude_tags)\n\n    def filter_track(self, track: Track) -&gt; bool:\n        \"\"\"Returns True if this track should remain in the playlist.\n\n        Args:\n            track: Track object to apply filter to.\n\n        Returns:\n            Whether or not this track should be included in the playlist.\n        \"\"\"\n        other_tags = (\n            set(track.get_tags())\n            .difference(set(track.get_genre_tags()))\n            .difference(self._exclude_tags)\n        )\n\n        return (\n            other_tags and len(other_tags) &gt;= self._min_tags_for_complex_track\n        )\n\n    def is_filter_playlist(self, playlist: Playlist) -&gt; bool:\n        \"\"\"Returns True if this playlist should be filtered.\n\n        Args:\n            playlist: Playlist object to potentially filter.\n\n        Returns:\n            Whether or not to filter this playlist.\n        \"\"\"\n        playlist_exp = re.compile(r\".*complex.*\")\n        if re.search(playlist_exp, playlist.get_name().lower()):\n            return True\n\n        parent = playlist.get_parent()\n        while parent:\n            if re.search(playlist_exp, parent.get_name().lower()):\n                return True\n            parent = parent.get_parent()\n\n        return False\n</code></pre>"},{"location":"reference/collection/#djtools.collection.playlist_filters.ComplexTrackFilter.__init__","title":"<code>__init__(min_tags_for_complex_track=3, exclude_tags=None)</code>","text":"<p>Constructor.</p> <p>Parameters:</p> Name Type Description Default <code>min_tags_for_complex_track</code> <code>Optional[int]</code> <p>Maximum number of non-genre tags before a track is no longer considered \"complex\".</p> <code>3</code> <code>exclude_tags</code> <code>Optional[List[str]]</code> <p>Tags to ignore when determining the number of non-genre tags.</p> <code>None</code> Source code in <code>src/djtools/collection/playlist_filters.py</code> <pre><code>def __init__(\n    self,\n    min_tags_for_complex_track: Optional[int] = 3,\n    exclude_tags: Optional[List[str]] = None,\n):\n    \"\"\"Constructor.\n\n    Args:\n        min_tags_for_complex_track: Maximum number of non-genre tags before\n            a track is no longer considered \"complex\".\n        exclude_tags: Tags to ignore when determining the number of\n            non-genre tags.\n    \"\"\"\n    super().__init__()\n    self._min_tags_for_complex_track = min_tags_for_complex_track\n    if exclude_tags is None:\n        exclude_tags = [\n            \"DELETE\",\n            \"Flute\",\n            \"Guitar\",\n            \"Horn\",\n            \"Piano\",\n            \"Scratch\",\n            \"Strings\",\n            \"Vocal\",\n        ]\n    self._exclude_tags = set(exclude_tags)\n</code></pre>"},{"location":"reference/collection/#djtools.collection.playlist_filters.ComplexTrackFilter.filter_track","title":"<code>filter_track(track)</code>","text":"<p>Returns True if this track should remain in the playlist.</p> <p>Parameters:</p> Name Type Description Default <code>track</code> <code>Track</code> <p>Track object to apply filter to.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether or not this track should be included in the playlist.</p> Source code in <code>src/djtools/collection/playlist_filters.py</code> <pre><code>def filter_track(self, track: Track) -&gt; bool:\n    \"\"\"Returns True if this track should remain in the playlist.\n\n    Args:\n        track: Track object to apply filter to.\n\n    Returns:\n        Whether or not this track should be included in the playlist.\n    \"\"\"\n    other_tags = (\n        set(track.get_tags())\n        .difference(set(track.get_genre_tags()))\n        .difference(self._exclude_tags)\n    )\n\n    return (\n        other_tags and len(other_tags) &gt;= self._min_tags_for_complex_track\n    )\n</code></pre>"},{"location":"reference/collection/#djtools.collection.playlist_filters.ComplexTrackFilter.is_filter_playlist","title":"<code>is_filter_playlist(playlist)</code>","text":"<p>Returns True if this playlist should be filtered.</p> <p>Parameters:</p> Name Type Description Default <code>playlist</code> <code>Playlist</code> <p>Playlist object to potentially filter.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether or not to filter this playlist.</p> Source code in <code>src/djtools/collection/playlist_filters.py</code> <pre><code>def is_filter_playlist(self, playlist: Playlist) -&gt; bool:\n    \"\"\"Returns True if this playlist should be filtered.\n\n    Args:\n        playlist: Playlist object to potentially filter.\n\n    Returns:\n        Whether or not to filter this playlist.\n    \"\"\"\n    playlist_exp = re.compile(r\".*complex.*\")\n    if re.search(playlist_exp, playlist.get_name().lower()):\n        return True\n\n    parent = playlist.get_parent()\n    while parent:\n        if re.search(playlist_exp, parent.get_name().lower()):\n            return True\n        parent = parent.get_parent()\n\n    return False\n</code></pre>"},{"location":"reference/collection/#djtools.collection.playlist_filters.HipHopFilter","title":"<code>HipHopFilter</code>","text":"<p>               Bases: <code>PlaylistFilter</code></p> <p>This class filters playlists called \"Hip Hop\".</p> Source code in <code>src/djtools/collection/playlist_filters.py</code> <pre><code>class HipHopFilter(PlaylistFilter):\n    'This class filters playlists called \"Hip Hop\".'\n\n    def filter_track(self, track: Track) -&gt; bool:\n        \"\"\"Returns True if this track should remain in the playlist.\n\n        If the playlist is not underneath a folder called \"Bass\", then this\n        track is filtered out unless it has exclusively \"Hip Hop\" and \"R&amp;B\"\n        genre tags. If the playlist is underneath a folder called \"Bass\", then\n        this track is filtered out if it does have exclusively \"Hip Hop\" and\n        \"R&amp;B\" genre tags.\n\n        Args:\n            track: Track object to apply filter to.\n\n        Returns:\n            Whether or not this track should be included in the playlist.\n        \"\"\"\n        pure_hip_hop_with_other_tags = not self._bass_hip_hop and any(\n            \"r&amp;b\" not in x.lower() and \"hip hop\" not in x.lower()\n            for x in track.get_genre_tags()\n        )\n        bass_hip_hop_without_other_tags = self._bass_hip_hop and all(\n            \"r&amp;b\" in x.lower() or \"hip hop\" in x.lower()\n            for x in track.get_genre_tags()\n        )\n        if pure_hip_hop_with_other_tags or bass_hip_hop_without_other_tags:\n            return False\n\n        return True\n\n    def is_filter_playlist(self, playlist: Playlist) -&gt; bool:\n        \"\"\"Returns True if this playlist's name is \"Hip Hop\".\n\n        Args:\n            playlist: Playlist object to potentially filter.\n\n        Returns:\n            Whether or not to filter this playlist.\n        \"\"\"\n        self._bass_hip_hop = (  # pylint: disable=attribute-defined-outside-init\n            False\n        )\n\n        if not playlist.get_name() == \"Hip Hop\":\n            return False\n\n        parent = playlist.get_parent()\n        while parent:\n            if parent.get_name() == \"Bass\":\n                self._bass_hip_hop = (  # pylint: disable=attribute-defined-outside-init\n                    True\n                )\n                break\n            parent = parent.get_parent()\n\n        return True\n</code></pre>"},{"location":"reference/collection/#djtools.collection.playlist_filters.HipHopFilter.filter_track","title":"<code>filter_track(track)</code>","text":"<p>Returns True if this track should remain in the playlist.</p> <p>If the playlist is not underneath a folder called \"Bass\", then this track is filtered out unless it has exclusively \"Hip Hop\" and \"R&amp;B\" genre tags. If the playlist is underneath a folder called \"Bass\", then this track is filtered out if it does have exclusively \"Hip Hop\" and \"R&amp;B\" genre tags.</p> <p>Parameters:</p> Name Type Description Default <code>track</code> <code>Track</code> <p>Track object to apply filter to.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether or not this track should be included in the playlist.</p> Source code in <code>src/djtools/collection/playlist_filters.py</code> <pre><code>def filter_track(self, track: Track) -&gt; bool:\n    \"\"\"Returns True if this track should remain in the playlist.\n\n    If the playlist is not underneath a folder called \"Bass\", then this\n    track is filtered out unless it has exclusively \"Hip Hop\" and \"R&amp;B\"\n    genre tags. If the playlist is underneath a folder called \"Bass\", then\n    this track is filtered out if it does have exclusively \"Hip Hop\" and\n    \"R&amp;B\" genre tags.\n\n    Args:\n        track: Track object to apply filter to.\n\n    Returns:\n        Whether or not this track should be included in the playlist.\n    \"\"\"\n    pure_hip_hop_with_other_tags = not self._bass_hip_hop and any(\n        \"r&amp;b\" not in x.lower() and \"hip hop\" not in x.lower()\n        for x in track.get_genre_tags()\n    )\n    bass_hip_hop_without_other_tags = self._bass_hip_hop and all(\n        \"r&amp;b\" in x.lower() or \"hip hop\" in x.lower()\n        for x in track.get_genre_tags()\n    )\n    if pure_hip_hop_with_other_tags or bass_hip_hop_without_other_tags:\n        return False\n\n    return True\n</code></pre>"},{"location":"reference/collection/#djtools.collection.playlist_filters.HipHopFilter.is_filter_playlist","title":"<code>is_filter_playlist(playlist)</code>","text":"<p>Returns True if this playlist's name is \"Hip Hop\".</p> <p>Parameters:</p> Name Type Description Default <code>playlist</code> <code>Playlist</code> <p>Playlist object to potentially filter.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether or not to filter this playlist.</p> Source code in <code>src/djtools/collection/playlist_filters.py</code> <pre><code>def is_filter_playlist(self, playlist: Playlist) -&gt; bool:\n    \"\"\"Returns True if this playlist's name is \"Hip Hop\".\n\n    Args:\n        playlist: Playlist object to potentially filter.\n\n    Returns:\n        Whether or not to filter this playlist.\n    \"\"\"\n    self._bass_hip_hop = (  # pylint: disable=attribute-defined-outside-init\n        False\n    )\n\n    if not playlist.get_name() == \"Hip Hop\":\n        return False\n\n    parent = playlist.get_parent()\n    while parent:\n        if parent.get_name() == \"Bass\":\n            self._bass_hip_hop = (  # pylint: disable=attribute-defined-outside-init\n                True\n            )\n            break\n        parent = parent.get_parent()\n\n    return True\n</code></pre>"},{"location":"reference/collection/#djtools.collection.playlist_filters.MinimalDeepTechFilter","title":"<code>MinimalDeepTechFilter</code>","text":"<p>               Bases: <code>PlaylistFilter</code></p> <p>This class filters playlists called \"Minimal Deep Tech\".</p> Source code in <code>src/djtools/collection/playlist_filters.py</code> <pre><code>class MinimalDeepTechFilter(PlaylistFilter):\n    'This class filters playlists called \"Minimal Deep Tech\".'\n\n    def filter_track(self, track: Track) -&gt; bool:\n        \"\"\"Returns True if this track should remain in the playlist.\n\n        If the playlist is not underneath a folder called \"Techno\", then this\n        track is filtered out if there's another genre tag containing \"Techno\".\n        If the playlist is underneath a folder called \"Techno\", then\n        this track is filtered out if there's no other genre tag containing\n        \"Techno\".\n\n        Args:\n            track: Track object to apply filter to.\n\n        Returns:\n            Whether or not this track should be included in the playlist.\n        \"\"\"\n        house_exp = re.compile(r\".*house.*\")\n        techno_exp = re.compile(r\".*techno.*\")\n        house_tag = techno_tag = False\n        for tag in track.get_genre_tags():\n            if re.search(house_exp, tag.lower()):\n                house_tag = True\n            if re.search(techno_exp, tag.lower()):\n                techno_tag = True\n        if (self._techno and not techno_tag) or (\n            self._house and not house_tag\n        ):\n            return False\n\n        return True\n\n    def is_filter_playlist(self, playlist: Playlist) -&gt; bool:\n        \"\"\"Returns True if this playlist's name is \"Minimal Deep Tech\".\n\n        Args:\n            playlist: Playlist object to potentially filter.\n\n        Returns:\n            Whether or not to filter this playlist.\n        \"\"\"\n        self._techno = False  # pylint: disable=attribute-defined-outside-init\n        self._house = False  # pylint: disable=attribute-defined-outside-init\n\n        if not playlist.get_name() == \"Minimal Deep Tech\":\n            return False\n\n        parent = playlist.get_parent()\n        while parent:\n            if parent.get_name() == \"Techno\":\n                self._techno = (  # pylint: disable=attribute-defined-outside-init\n                    True\n                )\n            if parent.get_name() == \"House\":\n                self._house = (  # pylint: disable=attribute-defined-outside-init\n                    True\n                )\n            parent = parent.get_parent()\n\n        return self._techno or self._house\n</code></pre>"},{"location":"reference/collection/#djtools.collection.playlist_filters.MinimalDeepTechFilter.filter_track","title":"<code>filter_track(track)</code>","text":"<p>Returns True if this track should remain in the playlist.</p> <p>If the playlist is not underneath a folder called \"Techno\", then this track is filtered out if there's another genre tag containing \"Techno\". If the playlist is underneath a folder called \"Techno\", then this track is filtered out if there's no other genre tag containing \"Techno\".</p> <p>Parameters:</p> Name Type Description Default <code>track</code> <code>Track</code> <p>Track object to apply filter to.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether or not this track should be included in the playlist.</p> Source code in <code>src/djtools/collection/playlist_filters.py</code> <pre><code>def filter_track(self, track: Track) -&gt; bool:\n    \"\"\"Returns True if this track should remain in the playlist.\n\n    If the playlist is not underneath a folder called \"Techno\", then this\n    track is filtered out if there's another genre tag containing \"Techno\".\n    If the playlist is underneath a folder called \"Techno\", then\n    this track is filtered out if there's no other genre tag containing\n    \"Techno\".\n\n    Args:\n        track: Track object to apply filter to.\n\n    Returns:\n        Whether or not this track should be included in the playlist.\n    \"\"\"\n    house_exp = re.compile(r\".*house.*\")\n    techno_exp = re.compile(r\".*techno.*\")\n    house_tag = techno_tag = False\n    for tag in track.get_genre_tags():\n        if re.search(house_exp, tag.lower()):\n            house_tag = True\n        if re.search(techno_exp, tag.lower()):\n            techno_tag = True\n    if (self._techno and not techno_tag) or (\n        self._house and not house_tag\n    ):\n        return False\n\n    return True\n</code></pre>"},{"location":"reference/collection/#djtools.collection.playlist_filters.MinimalDeepTechFilter.is_filter_playlist","title":"<code>is_filter_playlist(playlist)</code>","text":"<p>Returns True if this playlist's name is \"Minimal Deep Tech\".</p> <p>Parameters:</p> Name Type Description Default <code>playlist</code> <code>Playlist</code> <p>Playlist object to potentially filter.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether or not to filter this playlist.</p> Source code in <code>src/djtools/collection/playlist_filters.py</code> <pre><code>def is_filter_playlist(self, playlist: Playlist) -&gt; bool:\n    \"\"\"Returns True if this playlist's name is \"Minimal Deep Tech\".\n\n    Args:\n        playlist: Playlist object to potentially filter.\n\n    Returns:\n        Whether or not to filter this playlist.\n    \"\"\"\n    self._techno = False  # pylint: disable=attribute-defined-outside-init\n    self._house = False  # pylint: disable=attribute-defined-outside-init\n\n    if not playlist.get_name() == \"Minimal Deep Tech\":\n        return False\n\n    parent = playlist.get_parent()\n    while parent:\n        if parent.get_name() == \"Techno\":\n            self._techno = (  # pylint: disable=attribute-defined-outside-init\n                True\n            )\n        if parent.get_name() == \"House\":\n            self._house = (  # pylint: disable=attribute-defined-outside-init\n                True\n            )\n        parent = parent.get_parent()\n\n    return self._techno or self._house\n</code></pre>"},{"location":"reference/collection/#djtools.collection.playlist_filters.PlaylistFilter","title":"<code>PlaylistFilter</code>","text":"<p>               Bases: <code>ABC</code></p> <p>This class defines an interface for filtering tracks from playlists.</p> Source code in <code>src/djtools/collection/playlist_filters.py</code> <pre><code>class PlaylistFilter(ABC):\n    \"This class defines an interface for filtering tracks from playlists.\"\n\n    @abstractmethod\n    def filter_track(self, track: Track) -&gt; bool:\n        \"\"\"Returns True if this track should remain in the playlist.\n\n        Args:\n            track: Track object to apply filter to.\n\n        Returns:\n            Whether or not this track should be included in the playlist.\n        \"\"\"\n\n    @abstractmethod\n    def is_filter_playlist(self, playlist: Playlist) -&gt; bool:\n        \"\"\"Returns True if this playlist should be filtered.\n\n        Args:\n            playlist: Playlist object to potentially filter.\n\n        Returns:\n            Whether or not to filter this playlist.\n        \"\"\"\n</code></pre>"},{"location":"reference/collection/#djtools.collection.playlist_filters.PlaylistFilter.filter_track","title":"<code>filter_track(track)</code>  <code>abstractmethod</code>","text":"<p>Returns True if this track should remain in the playlist.</p> <p>Parameters:</p> Name Type Description Default <code>track</code> <code>Track</code> <p>Track object to apply filter to.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether or not this track should be included in the playlist.</p> Source code in <code>src/djtools/collection/playlist_filters.py</code> <pre><code>@abstractmethod\ndef filter_track(self, track: Track) -&gt; bool:\n    \"\"\"Returns True if this track should remain in the playlist.\n\n    Args:\n        track: Track object to apply filter to.\n\n    Returns:\n        Whether or not this track should be included in the playlist.\n    \"\"\"\n</code></pre>"},{"location":"reference/collection/#djtools.collection.playlist_filters.PlaylistFilter.is_filter_playlist","title":"<code>is_filter_playlist(playlist)</code>  <code>abstractmethod</code>","text":"<p>Returns True if this playlist should be filtered.</p> <p>Parameters:</p> Name Type Description Default <code>playlist</code> <code>Playlist</code> <p>Playlist object to potentially filter.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether or not to filter this playlist.</p> Source code in <code>src/djtools/collection/playlist_filters.py</code> <pre><code>@abstractmethod\ndef is_filter_playlist(self, playlist: Playlist) -&gt; bool:\n    \"\"\"Returns True if this playlist should be filtered.\n\n    Args:\n        playlist: Playlist object to potentially filter.\n\n    Returns:\n        Whether or not to filter this playlist.\n    \"\"\"\n</code></pre>"},{"location":"reference/collection/#djtools.collection.playlist_filters.TransitionTrackFilter","title":"<code>TransitionTrackFilter</code>","text":"<p>               Bases: <code>PlaylistFilter</code></p> <p>This class filters \"transition\" playlists.</p> <p>This PlaylistFilter looks for playlists with \"transition\" in their name or in the name of a parent playlist. When found, tracks contained in the playlist must have a square bracket enclosed set of transition tokens (forward-slash delimited list of floats, for BPMs, or otherwise, for genres).</p> Source code in <code>src/djtools/collection/playlist_filters.py</code> <pre><code>class TransitionTrackFilter(PlaylistFilter):\n    \"\"\"This class filters \"transition\" playlists.\n\n    This PlaylistFilter looks for playlists with \"transition\" in their name or in\n    the name of a parent playlist. When found, tracks contained in the playlist\n    must have a square bracket enclosed set of transition tokens (forward-slash\n    delimited list of floats, for BPMs, or otherwise, for genres).\n    \"\"\"\n\n    def __init__(self, separator: Optional[str] = \"/\"):\n        \"\"\"Constructor.\n\n        Args:\n            separator: Character used to separate transition tokens.\n        \"\"\"\n        super().__init__()\n        self._separator = separator\n        self._playlist_type = None\n\n    def filter_track(self, track: Track) -&gt; bool:\n        \"\"\"Returns True if this track should remain in the playlist.\n\n        Matches square bracket enclosed tokens representing transitions for\n        supported playlist types.\n\n        Args:\n            track: Track object to apply filter to.\n\n        Returns:\n            Whether or not this track should be included in the playlist.\n        \"\"\"\n        comments = track.get_comments()\n        transition_exp = re.compile(r\"\\[([^]]+)\\]\")\n        transition_tokens_match_playlist_type = False\n        for match in re.findall(transition_exp, comments):\n            try:\n                _ = [\n                    float(token.strip())\n                    for token in match.split(self._separator)\n                ]\n                if self._playlist_type == \"tempo\":\n                    transition_tokens_match_playlist_type = True\n            except ValueError:\n                if self._playlist_type == \"genre\":\n                    transition_tokens_match_playlist_type = True\n\n        return transition_tokens_match_playlist_type\n\n    def is_filter_playlist(self, playlist: Playlist) -&gt; bool:\n        \"\"\"Returns True if this playlist should be filtered.\n\n        Identifies playlists with a supported transition playlist type in its\n        name while also having a parent playlist with \"transition\" in its name.\n\n        Args:\n            playlist: Playlist object to potentially filter.\n\n        Returns:\n            Whether or not to filter this playlist.\n        \"\"\"\n        is_transition_playlist = False\n\n        # Check if the given playlist has a substring of \"transition\".\n        playlist_exp = re.compile(r\".*transition.*\")\n        if re.search(playlist_exp, playlist.get_name().lower()):\n            is_transition_playlist = True\n\n        # Search parents' names for \"transition\" substring.\n        parent = playlist.get_parent()\n        while not is_transition_playlist and parent:\n            if re.search(playlist_exp, parent.get_name().lower()):\n                is_transition_playlist = True\n            parent = parent.get_parent()\n\n        if not is_transition_playlist:\n            return False\n\n        # Check if the given playlist contains one, and only one, of the\n        # supported transition playlist types.\n        self._playlist_type = None\n        playlist_type_exprs = {\n            \"genre\": re.compile(r\".*genre.*\"),\n            \"tempo\": re.compile(r\".*tempo.*\"),\n        }\n        for playlist_type, exp in playlist_type_exprs.items():\n            if not re.search(exp, playlist.get_name().lower()):\n                continue\n            if self._playlist_type:\n                raise ValueError(\n                    f'\"{playlist.get_name()}\" matches multiple playlist types:'\n                    f\" {self._playlist_type}, {playlist_type}\"\n                )\n            self._playlist_type = playlist_type\n\n        return bool(self._playlist_type)\n</code></pre>"},{"location":"reference/collection/#djtools.collection.playlist_filters.TransitionTrackFilter.__init__","title":"<code>__init__(separator='/')</code>","text":"<p>Constructor.</p> <p>Parameters:</p> Name Type Description Default <code>separator</code> <code>Optional[str]</code> <p>Character used to separate transition tokens.</p> <code>'/'</code> Source code in <code>src/djtools/collection/playlist_filters.py</code> <pre><code>def __init__(self, separator: Optional[str] = \"/\"):\n    \"\"\"Constructor.\n\n    Args:\n        separator: Character used to separate transition tokens.\n    \"\"\"\n    super().__init__()\n    self._separator = separator\n    self._playlist_type = None\n</code></pre>"},{"location":"reference/collection/#djtools.collection.playlist_filters.TransitionTrackFilter.filter_track","title":"<code>filter_track(track)</code>","text":"<p>Returns True if this track should remain in the playlist.</p> <p>Matches square bracket enclosed tokens representing transitions for supported playlist types.</p> <p>Parameters:</p> Name Type Description Default <code>track</code> <code>Track</code> <p>Track object to apply filter to.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether or not this track should be included in the playlist.</p> Source code in <code>src/djtools/collection/playlist_filters.py</code> <pre><code>def filter_track(self, track: Track) -&gt; bool:\n    \"\"\"Returns True if this track should remain in the playlist.\n\n    Matches square bracket enclosed tokens representing transitions for\n    supported playlist types.\n\n    Args:\n        track: Track object to apply filter to.\n\n    Returns:\n        Whether or not this track should be included in the playlist.\n    \"\"\"\n    comments = track.get_comments()\n    transition_exp = re.compile(r\"\\[([^]]+)\\]\")\n    transition_tokens_match_playlist_type = False\n    for match in re.findall(transition_exp, comments):\n        try:\n            _ = [\n                float(token.strip())\n                for token in match.split(self._separator)\n            ]\n            if self._playlist_type == \"tempo\":\n                transition_tokens_match_playlist_type = True\n        except ValueError:\n            if self._playlist_type == \"genre\":\n                transition_tokens_match_playlist_type = True\n\n    return transition_tokens_match_playlist_type\n</code></pre>"},{"location":"reference/collection/#djtools.collection.playlist_filters.TransitionTrackFilter.is_filter_playlist","title":"<code>is_filter_playlist(playlist)</code>","text":"<p>Returns True if this playlist should be filtered.</p> <p>Identifies playlists with a supported transition playlist type in its name while also having a parent playlist with \"transition\" in its name.</p> <p>Parameters:</p> Name Type Description Default <code>playlist</code> <code>Playlist</code> <p>Playlist object to potentially filter.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether or not to filter this playlist.</p> Source code in <code>src/djtools/collection/playlist_filters.py</code> <pre><code>def is_filter_playlist(self, playlist: Playlist) -&gt; bool:\n    \"\"\"Returns True if this playlist should be filtered.\n\n    Identifies playlists with a supported transition playlist type in its\n    name while also having a parent playlist with \"transition\" in its name.\n\n    Args:\n        playlist: Playlist object to potentially filter.\n\n    Returns:\n        Whether or not to filter this playlist.\n    \"\"\"\n    is_transition_playlist = False\n\n    # Check if the given playlist has a substring of \"transition\".\n    playlist_exp = re.compile(r\".*transition.*\")\n    if re.search(playlist_exp, playlist.get_name().lower()):\n        is_transition_playlist = True\n\n    # Search parents' names for \"transition\" substring.\n    parent = playlist.get_parent()\n    while not is_transition_playlist and parent:\n        if re.search(playlist_exp, parent.get_name().lower()):\n            is_transition_playlist = True\n        parent = parent.get_parent()\n\n    if not is_transition_playlist:\n        return False\n\n    # Check if the given playlist contains one, and only one, of the\n    # supported transition playlist types.\n    self._playlist_type = None\n    playlist_type_exprs = {\n        \"genre\": re.compile(r\".*genre.*\"),\n        \"tempo\": re.compile(r\".*tempo.*\"),\n    }\n    for playlist_type, exp in playlist_type_exprs.items():\n        if not re.search(exp, playlist.get_name().lower()):\n            continue\n        if self._playlist_type:\n            raise ValueError(\n                f'\"{playlist.get_name()}\" matches multiple playlist types:'\n                f\" {self._playlist_type}, {playlist_type}\"\n            )\n        self._playlist_type = playlist_type\n\n    return bool(self._playlist_type)\n</code></pre>"},{"location":"reference/collection/#djtools.collection.shuffle_playlists.shuffle_playlists","title":"<code>shuffle_playlists(config, path=None)</code>","text":"<p>For each playlist in \"shuffle_playlists\", randomize the tracks and sequentially set the track number to emulate shuffling.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>BaseConfig</code> <p>Configuration object.</p> required <code>path</code> <code>Optional[Path]</code> <p>Path to write the new collection to.</p> <code>None</code> Source code in <code>src/djtools/collection/shuffle_playlists.py</code> <pre><code>@make_path\ndef shuffle_playlists(config: BaseConfig, path: Optional[Path] = None):\n    \"\"\"For each playlist in \"shuffle_playlists\", randomize the tracks and\n    sequentially set the track number to emulate shuffling.\n\n    Args:\n        config: Configuration object.\n        path: Path to write the new collection to.\n    \"\"\"\n    # Load collection.\n    collection = PLATFORM_REGISTRY[config.collection.platform][\"collection\"](\n        path=config.collection.collection_path\n    )\n\n    # Build a dict of tracks to shuffle from the provided list of playlists.\n    shuffled_tracks = {}\n    for playlist_name in config.collection.shuffle_playlists:\n        playlists = collection.get_playlists(playlist_name)\n        if not playlists:\n            raise LookupError(f\"{playlist_name} not found\")\n        for playlist in playlists:\n            tracks = playlist.get_tracks()\n            track_keys = list(tracks.keys())\n            random.shuffle(track_keys)\n            shuffled_tracks.update({key: tracks[key] for key in track_keys})\n\n    # Apply the shuffled track number to the attribute of the tracks.\n    shuffled_tracks = list(shuffled_tracks.values())\n    payload = [shuffled_tracks, list(range(1, len(shuffled_tracks) + 1))]\n    with ThreadPoolExecutor(\n        max_workers=os.cpu_count() * 4  # pylint: disable=no-member\n    ) as executor:\n        futures = [\n            executor.submit(track.set_track_number, number)\n            for track, number in zip(*payload)\n        ]\n        for future in tqdm(\n            as_completed(futures),\n            total=len(futures),\n            desc=f\"Randomizing {len(futures)} tracks\",\n        ):\n            _ = future.result()\n\n    # Insert a new playlist containing just the shuffled tracks.\n    collection.add_playlist(\n        PLATFORM_REGISTRY[config.collection.platform][\"playlist\"].new_playlist(\n            name=\"SHUFFLE\",\n            tracks={track.get_id(): track for track in shuffled_tracks},\n        )\n    )\n    _ = collection.serialize(path=path)\n</code></pre>"},{"location":"reference/collection/#djtools.collection.copy_playlists.copy_playlists","title":"<code>copy_playlists(config, path=None)</code>","text":"<p>Copies tracks from provided playlists to a destination.</p> <p>Serializes the collection with these playlists and updated locations.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>BaseConfig</code> <p>Configuration object.</p> required <code>path</code> <code>Optional[Path]</code> <p>Path to write the new collection to.</p> <code>None</code> <p>Raises:</p> Type Description <code>LookupError</code> <p>Playlist names in copy_playlists must exist in \"collection_path\".</p> Source code in <code>src/djtools/collection/copy_playlists.py</code> <pre><code>@make_path\ndef copy_playlists(config: BaseConfig, path: Optional[Path] = None):\n    \"\"\"Copies tracks from provided playlists to a destination.\n\n    Serializes the collection with these playlists and updated locations.\n\n    Args:\n        config: Configuration object.\n        path: Path to write the new collection to.\n\n    Raises:\n        LookupError: Playlist names in copy_playlists must exist in\n            \"collection_path\".\n    \"\"\"\n    # Load collection.\n    collection = PLATFORM_REGISTRY[config.collection.platform][\"collection\"](\n        path=config.collection.collection_path\n    )\n\n    # Create destination directory.\n    config.collection.copy_playlists_destination.mkdir(\n        parents=True, exist_ok=True\n    )\n\n    playlist_tracks = {}\n    lineage = defaultdict(set)\n    playlists = []\n\n    # Get the playlists from the collection.\n    for playlist_name in config.collection.copy_playlists:\n        found_playlists = collection.get_playlists(playlist_name)\n        if not found_playlists:\n            raise LookupError(f\"{playlist_name} not found\")\n        playlists.extend(\n            [\n                playlist\n                for playlist in found_playlists\n                if not playlist.is_folder()\n            ]\n        )\n\n    # Traverse the playlist to get tracks for the desired playlists and mark\n    # the rest for removal.\n    for playlist in playlists:\n        playlist_tracks.update(playlist.get_tracks())\n        parent = playlist.get_parent()\n        while parent:\n            lineage[parent] = set()\n            for child in list(parent):\n                if child not in playlists and child not in lineage:\n                    lineage[parent].add(child)\n                    continue\n            parent = parent.get_parent()\n    collection.set_tracks(playlist_tracks)\n\n    # Remove the extra playlists.\n    for parent, children in lineage.items():\n        for child in children:\n            parent.remove_playlist(child)\n\n    # Copy tracks to the destination and update their location.\n    payload = zip(\n        playlist_tracks.values(),\n        [config.collection.copy_playlists_destination] * len(playlist_tracks),\n    )\n\n    with ThreadPoolExecutor(\n        max_workers=os.cpu_count() * 4  # pylint: disable=no-member\n    ) as executor:\n        futures = [executor.submit(copy_file, *args) for args in payload]\n\n        with tqdm(total=len(futures), desc=\"Copying tracks\") as pbar:\n            for future in as_completed(futures):\n                _ = future.result()\n                pbar.update(1)\n\n    # Unless specified, write the output collection to the same directory that\n    # the files are being copied to.\n    if not path:\n        path = (\n            config.collection.copy_playlists_destination\n            / f\"copied_playlists_collection{config.collection.collection_path.suffix}\"\n        )\n\n    # Serialize the new collection.\n    _ = collection.serialize(path=path)\n</code></pre>"},{"location":"reference/collection/#djtools.collection.helpers.BooleanNode","title":"<code>BooleanNode</code>","text":"<p>Node that contains boolean logic for a sub-expression.</p> Source code in <code>src/djtools/collection/helpers.py</code> <pre><code>class BooleanNode:\n    \"\"\"Node that contains boolean logic for a sub-expression.\"\"\"\n\n    def __init__(\n        self,\n        tags_tracks: Dict[str, Dict[str, Track]],\n        parent: Optional[\"BooleanNode\"] = None,\n    ):\n        \"\"\"Constructor.\n\n        Args:\n            tags_tracks: Dict of tags to tracks.\n            parent: BooleanNode of which this node is a sub-expression.\n        \"\"\"\n        self._ops = {\n            \"&amp;\": set.intersection,\n            \"|\": set.union,\n            \"~\": set.difference,\n        }\n        self._parent = parent\n        self._operators = []\n        self._operands = []\n        self._tags_tracks = tags_tracks\n\n    def _get_tracks(self, tag: str) -&gt; Set[str]:\n        \"\"\"Gets set of track IDs for the provided tag.\n\n        If the tag contains a wildcard, denoted with \"*\", then the union of\n        track IDs with a tag containing the provided tag as a sub-string is\n        returned.\n\n        Args:\n            tag: Tag for indexing tracks.\n\n        Returns:\n            Set of track IDs for the provided tag.\n        \"\"\"\n        if \"*\" in tag and not (\n            re.search(NUMERICAL_SELECTOR_REGEX, tag)\n            or re.search(STRING_SELECTOR_REGEX, tag)\n        ):\n            exp = re.compile(r\".*\".join(tag.split(\"*\")) + \"$\")\n            tracks = {}\n            for key in self._tags_tracks:\n                if re.match(exp, key):\n                    tracks.update(self._tags_tracks[key])\n            return tracks\n\n        return self._tags_tracks.get(tag, {})\n\n    def add_operand(self, operand: str) -&gt; str:\n        \"\"\"Add operand to BooleanNode.\n\n        Args:\n            operand: Tag or track set to be evaluated.\n\n        Returns:\n            Empty string to reset tag in the parse_expression function.\n        \"\"\"\n        if isinstance(operand, str):\n            operand = operand.strip()\n            if not operand:\n                return \"\"\n        self._operands.append(operand)\n\n        return \"\"\n\n    def add_operator(self, operator: str):\n        \"\"\"Adds a set operation to the BooleanNode.\n\n        Args:\n            operator: Character representing a set operation.\n        \"\"\"\n        self._operators.append(self._ops[operator])\n\n    def evaluate(self) -&gt; Dict[str, Track]:\n        \"\"\"Applies operators to the operands to produce a dict of tracks.\n\n        Raises:\n            RuntimeError: The boolean expression is malformed. It must contain\n                one less operator than there are operands.\n\n        Returns:\n            A dict of tracks reduced from the boolean expression.\n        \"\"\"\n        if len(self._operators) + 1 != len(self._operands):\n            operands = [\n                x if isinstance(x, str) else str(len(x)) + \" tracks\"\n                for x in self._operands\n            ]\n            raise RuntimeError(\n                \"Invalid boolean expression:\\n\"\n                f\"\\toperands: {operands}\\n\"\n                f\"\\toperators: {[x.__name__ for x in self._operators]}\"\n            )\n        while self._operators:\n            tracks_a = (\n                self._operands.pop(0)\n                if not isinstance(self._operands[0], str)\n                else self._get_tracks(tag=self._operands.pop(0))\n            )\n            tracks_b = (\n                self._operands.pop(0)\n                if not isinstance(self._operands[0], str)\n                else self._get_tracks(tag=self._operands.pop(0))\n            )\n            operator = self._operators.pop(0)\n            track_ids = operator(set(tracks_a), set(tracks_b))\n            tracks = {\n                track_id: track\n                for track_id, track in {**tracks_a, **tracks_b}.items()\n                if track_id in track_ids\n            }\n            self._operands.insert(0, tracks)\n\n        return next(iter(self._operands), set())\n\n    def get_parent(self) -&gt; \"BooleanNode\":\n        \"\"\"Gets the parent of the BooleanNode.\n\n        Returns:\n            Parent BooleanNode.\n        \"\"\"\n        return self._parent\n\n    def is_operator(self, char: str) -&gt; bool:\n        \"\"\"Checks if a character is one that represents a set operation.\n\n        Args:\n            char: Character that may represent a set operation.\n\n        Returns:\n            Whether or not the character is an operator.\n        \"\"\"\n        return char in self._ops\n</code></pre>"},{"location":"reference/collection/#djtools.collection.helpers.BooleanNode.__init__","title":"<code>__init__(tags_tracks, parent=None)</code>","text":"<p>Constructor.</p> <p>Parameters:</p> Name Type Description Default <code>tags_tracks</code> <code>Dict[str, Dict[str, Track]]</code> <p>Dict of tags to tracks.</p> required <code>parent</code> <code>Optional[BooleanNode]</code> <p>BooleanNode of which this node is a sub-expression.</p> <code>None</code> Source code in <code>src/djtools/collection/helpers.py</code> <pre><code>def __init__(\n    self,\n    tags_tracks: Dict[str, Dict[str, Track]],\n    parent: Optional[\"BooleanNode\"] = None,\n):\n    \"\"\"Constructor.\n\n    Args:\n        tags_tracks: Dict of tags to tracks.\n        parent: BooleanNode of which this node is a sub-expression.\n    \"\"\"\n    self._ops = {\n        \"&amp;\": set.intersection,\n        \"|\": set.union,\n        \"~\": set.difference,\n    }\n    self._parent = parent\n    self._operators = []\n    self._operands = []\n    self._tags_tracks = tags_tracks\n</code></pre>"},{"location":"reference/collection/#djtools.collection.helpers.BooleanNode.add_operand","title":"<code>add_operand(operand)</code>","text":"<p>Add operand to BooleanNode.</p> <p>Parameters:</p> Name Type Description Default <code>operand</code> <code>str</code> <p>Tag or track set to be evaluated.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Empty string to reset tag in the parse_expression function.</p> Source code in <code>src/djtools/collection/helpers.py</code> <pre><code>def add_operand(self, operand: str) -&gt; str:\n    \"\"\"Add operand to BooleanNode.\n\n    Args:\n        operand: Tag or track set to be evaluated.\n\n    Returns:\n        Empty string to reset tag in the parse_expression function.\n    \"\"\"\n    if isinstance(operand, str):\n        operand = operand.strip()\n        if not operand:\n            return \"\"\n    self._operands.append(operand)\n\n    return \"\"\n</code></pre>"},{"location":"reference/collection/#djtools.collection.helpers.BooleanNode.add_operator","title":"<code>add_operator(operator)</code>","text":"<p>Adds a set operation to the BooleanNode.</p> <p>Parameters:</p> Name Type Description Default <code>operator</code> <code>str</code> <p>Character representing a set operation.</p> required Source code in <code>src/djtools/collection/helpers.py</code> <pre><code>def add_operator(self, operator: str):\n    \"\"\"Adds a set operation to the BooleanNode.\n\n    Args:\n        operator: Character representing a set operation.\n    \"\"\"\n    self._operators.append(self._ops[operator])\n</code></pre>"},{"location":"reference/collection/#djtools.collection.helpers.BooleanNode.evaluate","title":"<code>evaluate()</code>","text":"<p>Applies operators to the operands to produce a dict of tracks.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>The boolean expression is malformed. It must contain one less operator than there are operands.</p> <p>Returns:</p> Type Description <code>Dict[str, Track]</code> <p>A dict of tracks reduced from the boolean expression.</p> Source code in <code>src/djtools/collection/helpers.py</code> <pre><code>def evaluate(self) -&gt; Dict[str, Track]:\n    \"\"\"Applies operators to the operands to produce a dict of tracks.\n\n    Raises:\n        RuntimeError: The boolean expression is malformed. It must contain\n            one less operator than there are operands.\n\n    Returns:\n        A dict of tracks reduced from the boolean expression.\n    \"\"\"\n    if len(self._operators) + 1 != len(self._operands):\n        operands = [\n            x if isinstance(x, str) else str(len(x)) + \" tracks\"\n            for x in self._operands\n        ]\n        raise RuntimeError(\n            \"Invalid boolean expression:\\n\"\n            f\"\\toperands: {operands}\\n\"\n            f\"\\toperators: {[x.__name__ for x in self._operators]}\"\n        )\n    while self._operators:\n        tracks_a = (\n            self._operands.pop(0)\n            if not isinstance(self._operands[0], str)\n            else self._get_tracks(tag=self._operands.pop(0))\n        )\n        tracks_b = (\n            self._operands.pop(0)\n            if not isinstance(self._operands[0], str)\n            else self._get_tracks(tag=self._operands.pop(0))\n        )\n        operator = self._operators.pop(0)\n        track_ids = operator(set(tracks_a), set(tracks_b))\n        tracks = {\n            track_id: track\n            for track_id, track in {**tracks_a, **tracks_b}.items()\n            if track_id in track_ids\n        }\n        self._operands.insert(0, tracks)\n\n    return next(iter(self._operands), set())\n</code></pre>"},{"location":"reference/collection/#djtools.collection.helpers.BooleanNode.get_parent","title":"<code>get_parent()</code>","text":"<p>Gets the parent of the BooleanNode.</p> <p>Returns:</p> Type Description <code>BooleanNode</code> <p>Parent BooleanNode.</p> Source code in <code>src/djtools/collection/helpers.py</code> <pre><code>def get_parent(self) -&gt; \"BooleanNode\":\n    \"\"\"Gets the parent of the BooleanNode.\n\n    Returns:\n        Parent BooleanNode.\n    \"\"\"\n    return self._parent\n</code></pre>"},{"location":"reference/collection/#djtools.collection.helpers.BooleanNode.is_operator","title":"<code>is_operator(char)</code>","text":"<p>Checks if a character is one that represents a set operation.</p> <p>Parameters:</p> Name Type Description Default <code>char</code> <code>str</code> <p>Character that may represent a set operation.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether or not the character is an operator.</p> Source code in <code>src/djtools/collection/helpers.py</code> <pre><code>def is_operator(self, char: str) -&gt; bool:\n    \"\"\"Checks if a character is one that represents a set operation.\n\n    Args:\n        char: Character that may represent a set operation.\n\n    Returns:\n        Whether or not the character is an operator.\n    \"\"\"\n    return char in self._ops\n</code></pre>"},{"location":"reference/collection/#djtools.collection.helpers.add_selectors_to_tags","title":"<code>add_selectors_to_tags(content, tags_tracks, collection, auto_playlists)</code>","text":"<p>Recursively update the track lookup with selectors.</p> <p>Parameters:</p> Name Type Description Default <code>content</code> <code>Union[PlaylistConfigContent, PlaylistName, str]</code> <p>A component of a playlist config to create a playlist for.</p> required <code>tags_tracks</code> <code>Dict[str, Dict[str, Track]]</code> <p>Dict of tags to tracks.</p> required <code>collection</code> <code>Collection</code> <p>Collection object.</p> required <code>auto_playlists</code> <code>List[Playlist]</code> <p>Tag playlists built in this same run.</p> required Source code in <code>src/djtools/collection/helpers.py</code> <pre><code>def add_selectors_to_tags(\n    content: Union[PlaylistConfigContent, PlaylistName, str],\n    tags_tracks: Dict[str, Dict[str, Track]],\n    collection: Collection,\n    auto_playlists: List[Playlist],\n):\n    \"\"\"Recursively update the track lookup with selectors.\n\n    Args:\n        content: A component of a playlist config to create a playlist for.\n        tags_tracks: Dict of tags to tracks.\n        collection: Collection object.\n        auto_playlists: Tag playlists built in this same run.\n    \"\"\"\n    # This is a folder so parse selectors from playlists within it.\n    if isinstance(content, PlaylistConfigContent):\n        for playlist in content.playlists:\n            add_selectors_to_tags(\n                playlist, tags_tracks, collection, auto_playlists\n            )\n        return\n\n    # This is not a folder so these playlists must have their selectors parsed.\n    if isinstance(content, PlaylistName):\n        tag_content = content.tag_content\n    else:\n        tag_content = content\n\n    numerical_value_lookup = {}\n    string_selector_type_map = {\n        \"artist\": \"get_artists\",\n        \"comment\": \"get_comments\",\n        \"date\": \"get_date_added\",\n        \"key\": \"get_key\",\n        \"label\": \"get_label\",\n    }\n    string_value_lookup = {}\n    playlists = set()\n\n    # Grab selectors from Combiner playlist name.\n    parse_numerical_selectors(\n        re.findall(NUMERICAL_SELECTOR_REGEX, tag_content),\n        numerical_value_lookup,\n    )\n    parse_string_selectors(\n        re.findall(STRING_SELECTOR_REGEX, tag_content),\n        string_value_lookup,\n        string_selector_type_map,\n        playlists,\n    )\n\n    # Add keys for numerical selectors for tracks having those values.\n    for value, tag in numerical_value_lookup.items():\n        if tag in tags_tracks:\n            continue\n\n        for track_id, track in collection.get_tracks().items():\n            values = map(\n                str,\n                [round(track.get_bpm()), track.get_rating(), track.get_year()],\n            )\n            for val in values:\n                if (isinstance(value, str) and value == val) or (\n                    isinstance(value, tuple) and val in value\n                ):\n                    tags_tracks[tag][track_id] = track\n\n    # Add keys for string selectors for tracks having those values.\n    for selector, tag in string_value_lookup.items():\n        if tag in tags_tracks:\n            continue\n\n        selector_type, selector_value = selector\n        for track_id, track in collection.get_tracks().items():\n            value = getattr(track, string_selector_type_map[selector_type])()\n            if not value:\n                continue\n            if selector_type == \"date\":\n                inequality, date, date_format = selector_value\n                if not inequality:\n                    if value.strftime(date_format) == date.strftime(\n                        date_format\n                    ):\n                        tags_tracks[tag][track_id] = track\n                    continue\n                # In order for inequalities with lower precision levels than\n                # YYYY-MM-DD to work properly, the date added value for the\n                # track must be converted to the lower precision string and\n                # back into a datetime object.\n                value = datetime.strptime(\n                    value.strftime(date_format), date_format\n                )\n                if not inequality(value, date):\n                    continue\n                tags_tracks[tag][track_id] = track\n                continue\n            if \"*\" in selector_value:\n                exp = re.compile(r\".*\".join(selector_value.lower().split(\"*\")))\n                if re.search(exp, value.lower()):\n                    tags_tracks[tag][track_id] = track\n                    continue\n            if value.lower() == selector_value.lower():\n                tags_tracks[tag][track_id] = track\n\n    # Get playlists for the identified playlist selectors. Not only must we get\n    # playlists from the collection, but we must also get playlists from the\n    # auto playlists constructed in the very same run of the playlist_builder.\n    # This is because the playlists being selected may include those generated\n    # by the playlist_builder.\n    for playlist_name in playlists:\n        playlist_key = f\"{{playlist:{playlist_name}}}\"\n        if playlist_key in tags_tracks:\n            continue\n\n        for playlist_object in [collection, *auto_playlists]:\n            for playlist in playlist_object.get_playlists(playlist_name):\n                if playlist.is_folder():\n                    continue\n                tags_tracks[playlist_key].update(playlist.get_tracks())\n</code></pre>"},{"location":"reference/collection/#djtools.collection.helpers.aggregate_playlists","title":"<code>aggregate_playlists(playlist, playlist_class, minimum_tracks=None)</code>","text":"<p>Recursively aggregate tracks from folders into \"All\" playlists.</p> <p>Parameters:</p> Name Type Description Default <code>playlist</code> <code>Playlist</code> <p>Playlist which may be a folder or not.</p> required <code>playlist_class</code> <code>Playlist</code> <p>Playlist implementation class.</p> required <code>minimum_tracks</code> <code>Optional[int]</code> <p>Required number of tracks to make a playlist.</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict[str, Track]</code> <p>Dict of tracks.</p> Source code in <code>src/djtools/collection/helpers.py</code> <pre><code>def aggregate_playlists(\n    playlist: Playlist,\n    playlist_class: Playlist,\n    minimum_tracks: Optional[int] = None,\n) -&gt; Dict[str, Track]:\n    \"\"\"Recursively aggregate tracks from folders into \"All\" playlists.\n\n    Args:\n        playlist: Playlist which may be a folder or not.\n        playlist_class: Playlist implementation class.\n        minimum_tracks: Required number of tracks to make a playlist.\n\n    Returns:\n        Dict of tracks.\n    \"\"\"\n    # Get tracks from the playlist if it's not a folder.\n    if not playlist.is_folder():\n        return playlist.get_tracks() if playlist.aggregate() else {}\n\n    # Recursively get tracks from each playlist within this folder.\n    aggregate_tracks = {\n        track_id: track\n        for p in playlist\n        for track_id, track in aggregate_playlists(\n            p, playlist_class, minimum_tracks\n        ).items()\n    }\n\n    playlist_too_small = (\n        minimum_tracks and len(aggregate_tracks) &lt; minimum_tracks\n    )\n\n    # Create an \"All\" playlist in this folder if the folder contains more than\n    # one playlist.\n    if playlist.aggregate() and not playlist_too_small:\n        playlist.add_playlist(\n            playlist_class.new_playlist(\n                name=f\"All {playlist.get_name()}\", tracks=aggregate_tracks\n            ),\n            index=0,\n        )\n\n    return aggregate_tracks\n</code></pre>"},{"location":"reference/collection/#djtools.collection.helpers.build_combiner_playlists","title":"<code>build_combiner_playlists(content, tags_tracks, playlist_class, minimum_tracks=None)</code>","text":"<p>Recursively traverses a playlist config to generate playlists from tags.</p> <p>Parameters:</p> Name Type Description Default <code>content</code> <code>Union[PlaylistConfig, PlaylistName, str]</code> <p>A component of a playlist config to create a playlist for.</p> required <code>tags_tracks</code> <code>Dict[str, Dict[str, Track]]</code> <p>Dict of tags to tracks.</p> required <code>playlist_class</code> <code>Playlist</code> <p>Playlist implementation class.</p> required <code>minimum_tracks</code> <code>Optional[int]</code> <p>Required number of tracks to make a playlist.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>The user's playlist config must not be malformed.</p> <p>Returns:</p> Type Description <code>Optional[Playlist]</code> <p>A Playlist or None.</p> Source code in <code>src/djtools/collection/helpers.py</code> <pre><code>def build_combiner_playlists(\n    content: Union[PlaylistConfig, PlaylistName, str],\n    tags_tracks: Dict[str, Dict[str, Track]],\n    playlist_class: Playlist,\n    minimum_tracks: Optional[int] = None,\n) -&gt; Optional[Playlist]:\n    \"\"\"Recursively traverses a playlist config to generate playlists from tags.\n\n    Args:\n        content: A component of a playlist config to create a playlist for.\n        tags_tracks: Dict of tags to tracks.\n        playlist_class: Playlist implementation class.\n        minimum_tracks: Required number of tracks to make a playlist.\n\n    Raises:\n        ValueError: The user's playlist config must not be malformed.\n\n    Returns:\n        A Playlist or None.\n    \"\"\"\n    if not isinstance(content, (PlaylistConfigContent, PlaylistName, str)):\n        raise ValueError(f\"Invalid input type {type(content)}: {content}\")\n\n    # Folders can opt-in to having an aggregation playlist.\n    enable_aggregation = None\n\n    if isinstance(content, PlaylistName):\n        tag_content = content.tag_content\n        name = content.name or tag_content\n    elif isinstance(content, str):\n        tag_content = name = content\n    if isinstance(content, PlaylistConfigContent):\n        enable_aggregation = content.enable_aggregation\n\n    # This is not a folder so a playlist with tracks must be created.\n    if isinstance(content, (PlaylistName, str)):\n        try:\n            tracks = parse_expression(tag_content, tags_tracks)\n        except Exception as exc:\n            logger.warning(f\"Error parsing expression: {tag_content}\\n{exc}\")\n            return None\n\n        if minimum_tracks and len(tracks) &lt; minimum_tracks:\n            return None\n\n        return playlist_class.new_playlist(\n            name=name, tracks=tracks, enable_aggregation=enable_aggregation\n        )\n\n    # This is a folder so create playlists for those playlists within it.\n    playlists = []\n    for item in content.playlists:\n        playlist = build_combiner_playlists(\n            item,\n            tags_tracks,\n            playlist_class,\n            minimum_tracks=minimum_tracks,\n        )\n        if playlist:\n            playlists.append(playlist)\n        else:\n            logger.warning(\n                f\"There are no tracks for the Combiner playlist: {item}\"\n            )\n    if not playlists:\n        logger.warning(\n            f'There were no playlists created from \"{content.playlists}\"'\n        )\n\n    return playlist_class.new_playlist(\n        name=content.name,\n        playlists=playlists,\n        enable_aggregation=enable_aggregation,\n    )\n</code></pre>"},{"location":"reference/collection/#djtools.collection.helpers.build_tag_playlists","title":"<code>build_tag_playlists(content, tags_tracks, playlist_class, tag_set=None, minimum_tracks=None)</code>","text":"<p>Recursively traverses a playlist config to generate playlists from tags.</p> <p>Parameters:</p> Name Type Description Default <code>content</code> <code>Union[PlaylistConfigContent, PlaylistName, str]</code> <p>A component of a playlist config to create a playlist for.</p> required <code>tags_tracks</code> <code>Dict[str, Dict[str, Track]]</code> <p>Dict of tags to tracks.</p> required <code>playlist_class</code> <code>Playlist</code> <p>Playlist implementation class.</p> required <code>tag_set</code> <code>Optional[Set]</code> <p>A set of tags seen while creating playlists. This is used to indicate which tags should be ignored when creating the \"Unused Tags\" playlists.</p> <code>None</code> <code>minimum_tracks</code> <code>Optional[int]</code> <p>Required number of tracks to make a playlist.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>The user's playlist config must not be malformed.</p> <p>Returns:</p> Type Description <code>Optional[Playlist]</code> <p>A Playlist or None.</p> Source code in <code>src/djtools/collection/helpers.py</code> <pre><code>def build_tag_playlists(\n    content: Union[PlaylistConfigContent, PlaylistName, str],\n    tags_tracks: Dict[str, Dict[str, Track]],\n    playlist_class: Playlist,\n    tag_set: Optional[Set] = None,\n    minimum_tracks: Optional[int] = None,\n) -&gt; Optional[Playlist]:\n    \"\"\"Recursively traverses a playlist config to generate playlists from tags.\n\n    Args:\n        content: A component of a playlist config to create a playlist for.\n        tags_tracks: Dict of tags to tracks.\n        playlist_class: Playlist implementation class.\n        tag_set: A set of tags seen while creating playlists. This is used to\n            indicate which tags should be ignored when creating the\n            \"Unused Tags\" playlists.\n        minimum_tracks: Required number of tracks to make a playlist.\n\n    Raises:\n        ValueError: The user's playlist config must not be malformed.\n\n    Returns:\n        A Playlist or None.\n    \"\"\"\n    if not isinstance(content, (PlaylistConfigContent, PlaylistName, str)):\n        raise ValueError(f\"Invalid input type {type(content)}: {content}\")\n\n    # Initialize the set of tags in case the caller didn't provide one.\n    tag_set = tag_set if tag_set is not None else set()\n\n    # Folders can opt-in to having an aggregation playlist.\n    enable_aggregation = None\n\n    if isinstance(content, PlaylistConfigContent):\n        enable_aggregation = content.enable_aggregation\n\n    # This is a folder so create playlists for those playlists within it.\n    if isinstance(content, PlaylistConfigContent):\n        # Update the set of tags seen so these are ignored in when creating the\n        # \"Unused Tags\" playlists.\n        if content.name == \"_ignore\":\n            tag_set.update(content.playlists)\n            return None\n\n        # Create playlists for each playlist in this folder.\n        playlists = [\n            build_tag_playlists(\n                item,\n                tags_tracks,\n                playlist_class,\n                tag_set,\n                minimum_tracks=minimum_tracks,\n            )\n            for item in content.playlists\n        ]\n        playlists = [playlist for playlist in playlists if playlist]\n        if not playlists:\n            logger.warning(\n                f'There were no playlists created from \"{content.playlists}\"'\n            )\n            return None\n\n        return playlist_class.new_playlist(\n            name=content.name,\n            playlists=playlists,\n            enable_aggregation=enable_aggregation,\n        )\n\n    # This is not a folder so a playlist with tracks must be created.\n\n    # If a PlaylistName is used, then the tag_content field is used to\n    # determine the tag corresponding with this playlist and the name field is\n    # used to name the playlist. Otherwise, the content is a string that\n    # represents both the tag and the name.\n    if isinstance(content, PlaylistName):\n        tag_content = content.tag_content\n        name = content.name or tag_content\n    else:\n        tag_content = name = content\n\n    # Apply special logic for creating a \"pure\" playlist. \"Pure\" playlists are\n    # those that contain tracks with a set of genre tags that all contain the\n    # sub-string indicated by the suffix of the playlist name. For example,\n    # \"Pure Techno\" will contain tracks that have genres {\"Hard Techno\",\n    # \"Melodic Techno\"} but will not contain tracks that contain\n    # {\"Hard Techno\", \"Tech House\"} because \"Tech House\" does not contain\n    # \"Techno\" as a sub-string.\n    if tag_content.startswith(\"Pure \"):\n        # Isolate the tag to create a pure playlist for.\n        tag = tag_content.split(\"Pure \")[-1]\n        tracks_with_tag = tags_tracks.get(tag)\n        if not tracks_with_tag:\n            logger.warning(\n                f'Can\\'t make a \"Pure {tag}\" playlist because there are no '\n                \"tracks with that tag.\"\n            )\n            return None\n\n        # Filter out tracks that aren't pure.\n        pure_tag_tracks = {\n            track_id: track\n            for track_id, track in tracks_with_tag.items()\n            if all(tag.lower() in _.lower() for _ in track.get_genre_tags())\n        }\n        if not pure_tag_tracks:\n            logger.warning(\n                f'Can\\'t make a \"Pure {tag}\" playlist because there are no '\n                f\"tracks that are pure {tag}.\"\n            )\n            return None\n\n        if minimum_tracks and len(pure_tag_tracks) &lt; minimum_tracks:\n            return None\n\n        return playlist_class.new_playlist(\n            name=name,\n            tracks=pure_tag_tracks,\n            enable_aggregation=enable_aggregation,\n        )\n\n    # Get tracks with this tag and index it so that it's not added to the\n    # \"Unused Tags\" playlists.\n    tracks_with_tag = tags_tracks.get(tag_content)\n    tag_set.add(tag_content)\n    if not tracks_with_tag:\n        logger.warning(f'There are no tracks with the tag \"{tag_content}\"')\n        return None\n\n    if minimum_tracks and len(tracks_with_tag) &lt; minimum_tracks:\n        return None\n\n    return playlist_class.new_playlist(\n        name=name,\n        tracks=tracks_with_tag,\n        enable_aggregation=enable_aggregation,\n    )\n</code></pre>"},{"location":"reference/collection/#djtools.collection.helpers.copy_file","title":"<code>copy_file(track, destination)</code>","text":"<p>Copies a track to a destination and updates its location.</p> <p>Parameters:</p> Name Type Description Default <code>track</code> <code>Track</code> <p>Track object.</p> required <code>destination</code> <code>Path</code> <p>Directory to copy tracks to.</p> required Source code in <code>src/djtools/collection/helpers.py</code> <pre><code>@make_path\ndef copy_file(track: Track, destination: Path):\n    \"\"\"Copies a track to a destination and updates its location.\n\n    Args:\n        track: Track object.\n        destination: Directory to copy tracks to.\n    \"\"\"\n    loc = track.get_location()\n    dest = destination / loc.name\n    if not dest.exists():\n        shutil.copyfile(loc.as_posix(), dest)\n    track.set_location(dest)\n</code></pre>"},{"location":"reference/collection/#djtools.collection.helpers.filter_tag_playlists","title":"<code>filter_tag_playlists(playlist, playlist_filters)</code>","text":"<p>Applies a list of PlaylistFilter implementations to the playlist.</p> <p>If the PlaylistFilter implementations' is_filter_playlist method evaluates to True, then the filter_track method is applied to each track in the playlist. The playlist's tracks are set to remove the tracks that have been filtered out.</p> <p>Parameters:</p> Name Type Description Default <code>playlist</code> <code>Playlist</code> <p>Playlist to potentially have its tracks filtered.</p> required <code>playlist_filters</code> <code>List[PlaylistFilter]</code> <p>A list of PlaylistFilter implementations used to filter playlist tracks.</p> required Source code in <code>src/djtools/collection/helpers.py</code> <pre><code>def filter_tag_playlists(\n    playlist: Playlist, playlist_filters: List[PlaylistFilter]\n) -&gt; None:\n    \"\"\"Applies a list of PlaylistFilter implementations to the playlist.\n\n    If the PlaylistFilter implementations' is_filter_playlist method evaluates\n    to True, then the filter_track method is applied to each track in the\n    playlist. The playlist's tracks are set to remove the tracks that have been\n    filtered out.\n\n    Args:\n        playlist: Playlist to potentially have its tracks filtered.\n        playlist_filters: A list of PlaylistFilter implementations used to\n            filter playlist tracks.\n    \"\"\"\n    # This is a folder so filter its playlists.\n    if playlist.is_folder():\n        for _playlist in playlist:\n            filter_tag_playlists(_playlist, playlist_filters)\n        return\n\n    # Apply each PlaylistFilter to this playlist.\n    for playlist_filter in playlist_filters:\n        if not playlist_filter.is_filter_playlist(playlist):\n            continue\n        playlist.set_tracks(\n            tracks={\n                track_id: track\n                for track_id, track in playlist.get_tracks().items()\n                if playlist_filter.filter_track(track)\n            },\n        )\n</code></pre>"},{"location":"reference/collection/#djtools.collection.helpers.parse_expression","title":"<code>parse_expression(expression, tags_tracks)</code>","text":"<p>Parses a boolean algebra expression by constructing a tree.</p> <p>Parameters:</p> Name Type Description Default <code>expression</code> <code>str</code> <p>String representing boolean algebra expression.</p> required <code>tags_tracks</code> <code>Dict[str, Dict[str, Track]]</code> <p>Dict of tags to tracks.</p> required <p>Returns:</p> Type Description <code>Dict[str, Track]</code> <p>Dict of track IDs and tracks.</p> Source code in <code>src/djtools/collection/helpers.py</code> <pre><code>def parse_expression(\n    expression: str, tags_tracks: Dict[str, Dict[str, Track]]\n) -&gt; Dict[str, Track]:\n    \"\"\"Parses a boolean algebra expression by constructing a tree.\n\n    Args:\n        expression: String representing boolean algebra expression.\n        tags_tracks: Dict of tags to tracks.\n\n    Returns:\n        Dict of track IDs and tracks.\n    \"\"\"\n    node = BooleanNode(tags_tracks)\n    tag = \"\"\n    for char in expression:\n        if char == \"(\":\n            node = BooleanNode(tags_tracks, parent=node)\n        elif node.is_operator(char):\n            tag = node.add_operand(tag)\n            node.add_operator(char)\n        elif char == \")\":\n            tag = node.add_operand(tag)\n            tracks = node.evaluate()\n            node = node.get_parent()\n            if tracks:\n                node.add_operand(tracks)\n        else:\n            tag += char\n    tag = node.add_operand(tag)\n\n    return node.evaluate()\n</code></pre>"},{"location":"reference/collection/#djtools.collection.helpers.parse_numerical_selectors","title":"<code>parse_numerical_selectors(numerical_matches, numerical_value_lookup)</code>","text":"<p>Parses a string match of one or more numerical selectors.</p> <p>Parameters:</p> Name Type Description Default <code>numerical_matches</code> <code>List[str]</code> <p>List of numerical strings.</p> required <code>numerical_value_lookup</code> <code>Dict[Union[str, Tuple], str]</code> <p>Empty dict to populate with tuples or strings mapping numerical ranges or values to their \"tag\" representation.</p> required <p>Returns:</p> Type Description <code>Set[str]</code> <p>Set of numerical selector values.</p> Source code in <code>src/djtools/collection/helpers.py</code> <pre><code>def parse_numerical_selectors(\n    numerical_matches: List[str],\n    numerical_value_lookup: Dict[Union[str, Tuple], str],\n) -&gt; Set[str]:\n    \"\"\"Parses a string match of one or more numerical selectors.\n\n    Args:\n        numerical_matches: List of numerical strings.\n        numerical_value_lookup: Empty dict to populate with tuples or strings\n            mapping numerical ranges or values to their \"tag\" representation.\n\n    Returns:\n        Set of numerical selector values.\n    \"\"\"\n    numerical_values = set()\n    for match in numerical_matches:\n        _range = None\n        # If \"match\" is a digit, then it's an explicit numerical value.\n        if match.isdigit():\n            numerical_values.add(match)\n        # If \"match\" is two digits separated by a \"-\", then it's a range.\n        elif len(match.split(\"-\")) == 2 and all(\n            x.isdigit() for x in match.split(\"-\")\n        ):\n            _range = list(map(int, match.split(\"-\")))\n            _range = range(min(_range), max(_range) + 1)\n            if not (\n                all(0 &lt;= x &lt;= 5 for x in _range)\n                or all(6 &lt;= x &lt;= 999 for x in _range)  # range for ratings\n                or all(  # range for BPMs\n                    x &gt;= 1000 for x in _range\n                )  # range for years\n            ):\n                logger.error(f\"Bad numerical range selector: {match}\")\n                continue\n            numerical_values.update(map(str, _range))\n        else:\n            logger.error(f\"Malformed numerical selector: {match}\")\n            continue\n\n        numerical_value_lookup[tuple(map(str, _range or [])) or match] = (\n            f\"[{match}]\"\n        )\n\n    return numerical_values\n</code></pre>"},{"location":"reference/collection/#djtools.collection.helpers.parse_string_selectors","title":"<code>parse_string_selectors(string_matches, string_value_lookup, string_selector_type_map, playlists)</code>","text":"<p>Parses a string match of one or more string selectors.</p> <p>Parameters:</p> Name Type Description Default <code>string_matches</code> <code>List[str]</code> <p>List of strings for string selectors.</p> required <code>string_value_lookup</code> <code>Dict[Union[str, Tuple], str]</code> <p>Empty dict to populate with strings mapping string selectors to their \"tag\" representation.</p> required <code>string_selector_type_map</code> <code>Dict[str, str]</code> <p>Maps a selector type to a Track method name.</p> required <code>playlists</code> <code>Set[str]</code> <p>Set for storing playlist names.</p> required Source code in <code>src/djtools/collection/helpers.py</code> <pre><code>def parse_string_selectors(\n    string_matches: List[str],\n    string_value_lookup: Dict[Union[str, Tuple], str],\n    string_selector_type_map: Dict[str, str],\n    playlists: Set[str],\n):\n    \"\"\"Parses a string match of one or more string selectors.\n\n    Args:\n        string_matches: List of strings for string selectors.\n        string_value_lookup: Empty dict to populate with strings mapping string\n            selectors to their \"tag\" representation.\n        string_selector_type_map: Maps a selector type to a Track method name.\n        playlists: Set for storing playlist names.\n    \"\"\"\n    date_formats = [\"%Y-%m-%d\", \"%Y-%m\", \"%Y\"]\n\n    for match in string_matches:\n        selector_type, selector_value = map(str.strip, match.split(\":\"))\n        if selector_type == \"playlist\":\n            playlists.add(selector_value)\n            continue\n        if not string_selector_type_map.get(selector_type):\n            logger.warning(f\"{selector_type} is not a supported selector!\")\n            continue\n        if selector_type != \"date\":\n            string_value_lookup[(selector_type, selector_value)] = (\n                f\"{{{match}}}\"\n            )\n            continue\n\n        dates, formats, inequalities = [], [], []\n        skip_date_selector = False\n        for part in filter(\n            None, re.split(DATE_SELECTOR_REGEX, selector_value)\n        ):\n            date = None\n            date_format = \"%Y-%m-%d\"\n\n            # Note if the part is an inequality and move onto the next part.\n            if re.search(DATE_SELECTOR_REGEX, part):\n                inequalities.append(INEQUALITY_MAP[part])\n                continue\n\n            # The following part may be a timedelta string...\n            date = parse_timedelta(part)\n\n            # ...but if it wasn't, it's probably an ISO format date string.\n            if not date:\n                for date_format in date_formats:\n                    try:\n                        date = datetime.strptime(part, date_format)\n                    except ValueError:\n                        continue\n                    break\n\n            # If there's no date, then the selector wasn't formatted correctly.\n            if not date:\n                skip_date_selector = True\n                break\n\n            dates.append(date)\n            formats.append(date_format)\n\n        if (\n            skip_date_selector\n            or len(dates) != 1\n            or (len(inequalities) not in [0, 1])\n        ):\n            logger.warning(f\"Date selector {selector_value} is invalid!\")\n            continue\n\n        string_value_lookup[\n            (\n                selector_type,\n                (\n                    None if not inequalities else inequalities[0],\n                    dates[0],\n                    formats[0],\n                ),\n            )\n        ] = f\"{{{match}}}\"\n</code></pre>"},{"location":"reference/collection/#djtools.collection.helpers.parse_timedelta","title":"<code>parse_timedelta(time_str)</code>","text":"<p>Parse a timedelta from a string and return the relative offset from now.</p> Supported units of time <ul> <li>years</li> <li>months</li> <li>weeks</li> <li>days</li> </ul> Some example strings <ul> <li>1y</li> <li>6m</li> <li>3m2w</li> <li>7d</li> </ul> <p>Modified from peter's answer at https://stackoverflow.com/a/51916936</p> <p>Parameters:</p> Name Type Description Default <code>time_str</code> <p>A string identifying a duration.</p> required <p>Returns:</p> Type Description <code>Optional[datetime]</code> <p>A datetime.datetime object.</p> Source code in <code>src/djtools/collection/helpers.py</code> <pre><code>def parse_timedelta(time_str) -&gt; Optional[datetime]:\n    \"\"\"\n    Parse a timedelta from a string and return the relative offset from now.\n\n    Supported units of time:\n      - years\n      - months\n      - weeks\n      - days\n\n    Some example strings:\n      - 1y\n      - 6m\n      - 3m2w\n      - 7d\n\n    Modified from peter's answer at https://stackoverflow.com/a/51916936\n\n    Args:\n        time_str: A string identifying a duration.\n\n    Returns:\n        A datetime.datetime object.\n    \"\"\"\n    parts = TIMEDELTA_REGEX.match(time_str)\n\n    if not parts:\n        return None\n\n    time_params = {\n        name: float(val) for name, val in parts.groupdict().items() if val\n    }\n\n    now = datetime.now()\n    time_delta = relativedelta(**time_params)\n    relative_time = now - time_delta\n\n    return relative_time\n</code></pre>"},{"location":"reference/collection/#djtools.collection.helpers.print_data","title":"<code>print_data(data)</code>","text":"<p>Prints an ASCII histogram of tag data.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Dict[str, int]</code> <p>Tag names to tag counts.</p> required Source code in <code>src/djtools/collection/helpers.py</code> <pre><code>def print_data(data: Dict[str, int]):\n    \"\"\"Prints an ASCII histogram of tag data.\n\n    Args:\n        data: Tag names to tag counts.\n    \"\"\"\n    data = {k: v for k, v in data.items() if v}\n    scaled_data = scale_data(data)\n    row_width = 0\n    width_pad = 1\n    row = max(scaled_data.items(), key=itemgetter(1))[1]\n    output = \"\"\n    while row &gt; 0:\n        output += \"|\"\n        for key in data:\n            key_width = len(key)\n            key_center = round(key_width / 2)\n            output += f\"{' ' * (width_pad + key_center)}\"\n            output += f\"{'*' if row &lt;= scaled_data[key] else ' '}\"\n            output += f\"{' ' * (width_pad + key_center)}\"\n        if not row_width:\n            row_width = len(output)\n        output += \"\\n\"\n        row -= 1\n    output += \"-\" * row_width + \"\\n \"\n    for key in data:\n        output += f\"{' ' * width_pad}{key}{' ' * (width_pad + 1)}\"\n    print(output)\n</code></pre>"},{"location":"reference/collection/#djtools.collection.helpers.print_playlists_tag_statistics","title":"<code>print_playlists_tag_statistics(combiner_playlists)</code>","text":"<p>Prints tag statistics for Combiner playlists.</p> <p>Statistics are split out by Combiner playlist and then by TagParser type.</p> <p>Parameters:</p> Name Type Description Default <code>combiner_playlists</code> <code>Playlist</code> <p>Playlist object for Combiner playlists.</p> required Source code in <code>src/djtools/collection/helpers.py</code> <pre><code>def print_playlists_tag_statistics(combiner_playlists: Playlist) -&gt; None:\n    \"\"\"Prints tag statistics for Combiner playlists.\n\n    Statistics are split out by Combiner playlist and then by TagParser type.\n\n    Args:\n        combiner_playlists: Playlist object for Combiner playlists.\n    \"\"\"\n    playlists = []\n    playlist_stack = [combiner_playlists]\n    while playlist_stack:\n        item = playlist_stack.pop()\n        if item.is_folder():\n            playlist_stack.extend(item.get_playlists())\n            continue\n        playlists.append(item)\n\n    for playlist in playlists:\n        tracks = playlist.get_tracks()\n        if tracks:\n            print(f\"\\n{playlist.get_name()} tag statistics:\")\n        playlist_tags = defaultdict(int)\n        genre_tags = set()\n        other_tags = set()\n        for track in tracks.values():\n            track_all_tags = track.get_tags()\n            track_genre_tags = set(track.get_genre_tags())\n            other_tags.update(set(track_all_tags).difference(track_genre_tags))\n            genre_tags.update(track_genre_tags)\n            for tag in track_all_tags:\n                playlist_tags[tag] += 1\n        for tag_subset, tags in [\n            (\"Genre\", sorted(genre_tags)),\n            (\"Other\", sorted(other_tags)),\n        ]:\n            data = {tag: playlist_tags[tag] for tag in tags}\n            if data:\n                print(f\"\\n{tag_subset}:\")\n                print_data(data)\n</code></pre>"},{"location":"reference/collection/#djtools.collection.helpers.scale_data","title":"<code>scale_data(data, maximum=25)</code>","text":"<p>Scales range of data values with an upper bound.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Dict[str, int]</code> <p>Tag names to tag counts.</p> required <code>maximum</code> <code>Optional[int]</code> <p>Upper bound for re-scaled data.</p> <code>25</code> <p>Returns:</p> Type Description <code>Dict[str, int]</code> <p>Re-scaled dictionary of tag names and tag counts.</p> Source code in <code>src/djtools/collection/helpers.py</code> <pre><code>def scale_data(\n    data: Dict[str, int], maximum: Optional[int] = 25\n) -&gt; Dict[str, int]:\n    \"\"\"Scales range of data values with an upper bound.\n\n    Args:\n        data: Tag names to tag counts.\n        maximum: Upper bound for re-scaled data.\n\n    Returns:\n        Re-scaled dictionary of tag names and tag counts.\n    \"\"\"\n    data_max = max(data.items(), key=itemgetter(1))[1]\n\n    return {\n        k: max(round((v / data_max) * maximum), 1) for k, v in data.items()\n    }\n</code></pre>"},{"location":"reference/configs/","title":"Configs","text":"<p>This module contains the base configuration object. All the attributes of this configuration object either don't apply to any particular package or they apply to multiple packages. The attributes of this configuration object correspond with the \"configs\" key of config.yaml.</p> <p>This module is responsible for creating the argparse.NameSpace object from the CLI args.</p> <p>This module is responsible for building this library's configuration objects using config.yaml. If command-line arguments are provided, this module overrides the corresponding configuration options with these arguments.</p>"},{"location":"reference/configs/#djtools.configs.config.BaseConfig","title":"<code>BaseConfig</code>","text":"<p>               Bases: <code>BaseConfigFormatter</code></p> <p>Base configuration object used across the whole library.</p> Source code in <code>src/djtools/configs/config.py</code> <pre><code>class BaseConfig(BaseConfigFormatter):\n    \"\"\"Base configuration object used across the whole library.\"\"\"\n\n    collection: CollectionConfig = Field(default_factory=CollectionConfig)\n    log_level: LogLevel = LogLevel.INFO\n    spotify: SpotifyConfig = Field(default_factory=SpotifyConfig)\n    sync: SyncConfig = Field(default_factory=SyncConfig)\n    utils: UtilsConfig = Field(default_factory=UtilsConfig)\n    verbosity: NonNegativeInt = 0\n\n    class Config:\n        \"\"\"Class necessary to support deserializing Enums.\"\"\"\n\n        extra = \"allow\"\n</code></pre>"},{"location":"reference/configs/#djtools.configs.config.BaseConfig.Config","title":"<code>Config</code>","text":"<p>Class necessary to support deserializing Enums.</p> Source code in <code>src/djtools/configs/config.py</code> <pre><code>class Config:\n    \"\"\"Class necessary to support deserializing Enums.\"\"\"\n\n    extra = \"allow\"\n</code></pre>"},{"location":"reference/configs/#djtools.configs.config.LogLevel","title":"<code>LogLevel</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Log level Enum.</p> Source code in <code>src/djtools/configs/config.py</code> <pre><code>class LogLevel(Enum):\n    \"\"\"Log level Enum.\"\"\"\n\n    DEBUG = \"DEBUG\"\n    INFO = \"INFO\"\n    WARNING = \"WARNING\"\n    ERROR = \"ERROR\"\n    CRITICAL = \"CRITICAL\"\n</code></pre>"},{"location":"reference/configs/#djtools.configs.cli_args.NonEmptyListElementAction","title":"<code>NonEmptyListElementAction</code>","text":"<p>               Bases: <code>Action</code></p> <p>This Action implementation permits overriding list defaults.</p> <p>Some configuration options, like upload_exclude_dirs, may be set to some sensible default in config.yaml. Because of this users will be unable to run \"--upload-music\" in conjunction with \"--download-include-dirs\" without having to first make an edit to their config.yaml (because the include/exclude options are mutually exclusive).</p> Source code in <code>src/djtools/configs/cli_args.py</code> <pre><code>class NonEmptyListElementAction(Action):\n    \"\"\"This Action implementation permits overriding list defaults.\n\n    Some configuration options, like upload_exclude_dirs, may be set to some\n    sensible default in config.yaml. Because of this users will be unable to\n    run \"--upload-music\" in conjunction with \"--download-include-dirs\" without\n    having to first make an edit to their config.yaml (because the\n    include/exclude options are mutually exclusive).\n    \"\"\"\n\n    def __call__(\n        self,\n        parser: ArgumentParser,\n        namespace: Namespace,\n        values: List[str],\n        option_string: Optional[str] = None,\n    ):\n        \"\"\"Filter list-type arguments for empty strings.\n\n        Args:\n            parser: The ArgumentParser object which contains this action.\n            namespace: The Namespace object returned by parse_args().\n            values: The associated command-line arguments.\n            option_string: The option string used to invoke this action.\n        \"\"\"\n        values = values or []\n        dest = getattr(namespace, self.dest) or []\n        dest.extend(filter(None, values))\n        setattr(namespace, self.dest, dest)\n</code></pre>"},{"location":"reference/configs/#djtools.configs.cli_args.NonEmptyListElementAction.__call__","title":"<code>__call__(parser, namespace, values, option_string=None)</code>","text":"<p>Filter list-type arguments for empty strings.</p> <p>Parameters:</p> Name Type Description Default <code>parser</code> <code>ArgumentParser</code> <p>The ArgumentParser object which contains this action.</p> required <code>namespace</code> <code>Namespace</code> <p>The Namespace object returned by parse_args().</p> required <code>values</code> <code>List[str]</code> <p>The associated command-line arguments.</p> required <code>option_string</code> <code>Optional[str]</code> <p>The option string used to invoke this action.</p> <code>None</code> Source code in <code>src/djtools/configs/cli_args.py</code> <pre><code>def __call__(\n    self,\n    parser: ArgumentParser,\n    namespace: Namespace,\n    values: List[str],\n    option_string: Optional[str] = None,\n):\n    \"\"\"Filter list-type arguments for empty strings.\n\n    Args:\n        parser: The ArgumentParser object which contains this action.\n        namespace: The Namespace object returned by parse_args().\n        values: The associated command-line arguments.\n        option_string: The option string used to invoke this action.\n    \"\"\"\n    values = values or []\n    dest = getattr(namespace, self.dest) or []\n    dest.extend(filter(None, values))\n    setattr(namespace, self.dest, dest)\n</code></pre>"},{"location":"reference/configs/#djtools.configs.cli_args.get_arg_parser","title":"<code>get_arg_parser()</code>","text":"<p>Build an argparse.ArgumentParser object.</p> <p>Returns:</p> Type Description <code>ArgumentParser</code> <p>ArgumentParser object.</p> Source code in <code>src/djtools/configs/cli_args.py</code> <pre><code>def get_arg_parser() -&gt; ArgumentParser:\n    \"\"\"Build an argparse.ArgumentParser object.\n\n    Returns:\n        ArgumentParser object.\n    \"\"\"\n    parser = ArgumentParser(\n        description=(\n            \"djtools is a Python library with many features for streamlining \"\n            \"the processes around collecting, curating, and sharing a music \"\n            \"collection.\\n\\nRun djtools with one of the four available \"\n            \"sub-commands: collection, spotify, sync, utils\"\n        ),\n        formatter_class=RawTextHelpFormatter,\n    )\n    parser.add_argument(\n        \"--link-configs\",\n        type=_convert_to_paths,\n        help=(\n            \"The configuration files used by djtools are included at the \"\n            \"location where this package is installed...\\nUse this option to \"\n            \"symbolically link them to a more accessible location for easier \"\n            \"editing.\\nNote, the directory you're linking to must not already \"\n            \"exist.\"\n        ),\n    )\n    parser.add_argument(\n        \"--log-level\",\n        choices=[\"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\", \"CRITICAL\"],\n        help=\"Logger level.\",\n    )\n    parser.add_argument(\n        \"--verbosity\",\n        \"-v\",\n        action=\"count\",\n        default=0,\n        help=\"Increase the logging verbosity.\",\n    )\n    parser.add_argument(\n        \"--version\",\n        action=\"store_true\",\n        help=\"Display the version number of the installed djtools.\",\n    )\n    subparsers = parser.add_subparsers(title=\"sub-commands\")\n\n    ###########################################################################\n    # Sub-command for the collection package.\n    ###########################################################################\n    collection_parser = subparsers.add_parser(\n        name=\"collection\",\n        help=(\n            \"Perform operations on your DJ collection such as building \"\n            \"playlists based on your tags, shuffling track numbers, and \"\n            \"copying playlists to another location.\"\n        ),\n        formatter_class=RawTextHelpFormatter,\n    )\n    collection_parser.add_argument(\n        \"--collection-path\",\n        type=_convert_to_paths,\n        help='Path to a collection database (e.g. \"rekordbox.xml\").',\n    )\n    collection_parser.add_argument(\n        \"--collection-playlist-filters\",\n        type=str,\n        nargs=\"+\",\n        action=NonEmptyListElementAction,\n        help=(\n            \"PlaylistFilter implementations to apply with \"\n            '\"--collection-playlists\"'\n        ),\n    )\n    collection_parser.add_argument(\n        \"--collection-playlists\",\n        action=\"store_true\",\n        help=\"Flag to trigger building collection playlists.\",\n    )\n    collection_parser.add_argument(\n        \"--collection-playlists-remainder\",\n        type=str,\n        choices=[\"folder\", \"playlist\"],\n        help=(\n            \"If there are tags not included in your \"\n            '\"collection_playlists.yaml\", the associated tracks are '\n            'automatically pushed into either an \"Other\" folder of playlists '\n            '(one for each tag) or an \"Other\" playlist based on this option.'\n        ),\n    )\n    collection_parser.add_argument(\n        \"--copy-playlists\",\n        type=str,\n        nargs=\"+\",\n        action=NonEmptyListElementAction,\n        help=(\n            \"By providing a list of playlist names, this option will:\\n  - \"\n            \"copy the audio files in those playlists to \"\n            '\"--copy-playlists-destination\"\\n  - create a new collection with '\n            \"just those playlists where the tracks contained in them have \"\n            \"updated locations\"\n        ),\n    )\n    collection_parser.add_argument(\n        \"--copy-playlists-destination\",\n        type=_convert_to_paths,\n        help=\"Location to copy playlists' audio files to.\",\n    )\n    collection_parser.add_argument(\n        \"--minimum-combiner-playlist-tracks\",\n        type=int,\n        default=None,\n        help=\"Minimum number of tracks for a combiner playlist to be valid.\",\n    )\n    collection_parser.add_argument(\n        \"--minimum-tag-playlist-tracks\",\n        type=int,\n        default=None,\n        help=\"Minimum number of tracks for a tag playlist to be valid.\",\n    )\n    collection_parser.add_argument(\n        \"--platform\",\n        type=str,\n        choices=[\"rekordbox\"],\n        help='DJ platform used for the collection package (e.g. \"rekordbox\").',\n    )\n    collection_parser.add_argument(\n        \"--shuffle-playlists\",\n        type=str,\n        nargs=\"+\",\n        action=NonEmptyListElementAction,\n        help=(\n            \"By providing a list of playlist names, this option will write to \"\n            \"the track number attribute to emulate shuffling of the tracks.\"\n        ),\n    )\n\n    ###########################################################################\n    # Sub-command for the spotify package.\n    ###########################################################################\n    spotify_parser = subparsers.add_parser(\n        name=\"spotify\",\n        help=(\n            \"Build playlists in Spotify either from:\\n  - posts in the \"\n            'subreddits configured with \"--spotify-playlist-subreddits\"\\n  - '\n            'the output generated by a user running \"--upload-music\" with the '\n            '\"--discord-url\" option configured'\n        ),\n        formatter_class=RawTextHelpFormatter,\n    )\n    spotify_parser.add_argument(\n        \"--reddit-client-id\",\n        type=str,\n        help=\"Reddit API client ID.\",\n    )\n    spotify_parser.add_argument(\n        \"--reddit-client-secret\",\n        type=str,\n        help=\"Reddit API client secret.\",\n    )\n    spotify_parser.add_argument(\n        \"--reddit-user-agent\",\n        type=str,\n        help=\"Reddit API user agent.\",\n    )\n    spotify_parser.add_argument(\n        \"--spotify-client-id\",\n        type=str,\n        help=\"Spotify API client ID.\",\n    )\n    spotify_parser.add_argument(\n        \"--spotify-client-secret\",\n        type=str,\n        help=\"Spotify API client secret.\",\n    )\n    spotify_parser.add_argument(\n        \"--spotify-playlist-default-limit\",\n        type=int,\n        help=\"Default number of tracks for a Spotify playlist.\",\n    )\n    spotify_parser.add_argument(\n        \"--spotify-playlist-default-period\",\n        type=str,\n        help=\"Default subreddit time filter for a Spotify playlist.\",\n    )\n    spotify_parser.add_argument(\n        \"--spotify-playlist-default-type\",\n        type=str,\n        help=\"Default subreddit post filter for a Spotify playlist.\",\n    )\n    spotify_parser.add_argument(\n        \"--spotify-playlist-from-upload\",\n        action=\"store_true\",\n        help=(\n            \"Flag to trigger building a Spotify playlist using the copied \"\n            \"Discord webhook output of a music upload.\"\n        ),\n    )\n    spotify_parser.add_argument(\n        \"--spotify-playlist-fuzz-ratio\",\n        type=int,\n        help=\"Minimum similarity to add track to a playlist.\",\n    )\n    spotify_parser.add_argument(\n        \"--spotify-playlist-post-limit\",\n        type=int,\n        help=\"Maximum subreddit posts to query for each playlist.\",\n    )\n    spotify_parser.add_argument(\n        \"--spotify-playlist-subreddits\",\n        type=_parse_json,\n        help=(\n            \"List of subreddits configs to build playlists from.\\nFormat as \"\n            'a JSON string containing a list of dictionaries with \"name\", '\n            '\"type\", \"period\", and \"limit\" keys.\\nNote: \"name\" is required '\n            \"while the other keys are optional.\\nExample:\\n  \"\n            '\\'[{\"name\": \"jungle\"}, {\"name\": \"techno\", \"type\": \"top\", '\n            '\"period\": \"week\", \"limit\": 75}]\\''\n        ),\n    )\n    spotify_parser.add_argument(\n        \"--spotify-playlists\",\n        action=\"store_true\",\n        help=\"Flag to trigger building Spotify playlists.\",\n    )\n    spotify_parser.add_argument(\n        \"--spotify-redirect-uri\",\n        type=str,\n        help=\"Spotify API redirect URI.\",\n    )\n    spotify_parser.add_argument(\n        \"--spotify-username\",\n        type=str,\n        help=\"Spotify user to build playlists for.\",\n    )\n\n    ###########################################################################\n    # Sub-command for the sync package.\n    ###########################################################################\n    sync_parser = subparsers.add_parser(\n        name=\"sync\",\n        help=(\n            'Sync audio files and DJ collections between your \"--usb-path\" '\n            \"and the Beatcloud.\"\n        ),\n        formatter_class=RawTextHelpFormatter,\n    )\n    sync_parser.add_argument(\n        \"--artist-first\",\n        action=\"store_true\",\n        help=(\n            \"Indicate that Beatcloud tracks are in the format \"\n            '\"Artist - Track Title\" instead of \"Track Title - Artist\".\\nThe '\n            \"ordering is important for any operation that compares your \"\n            \"tracks' filenames with Spotify tracks or other files...\\n\"\n            'This includes \"--spotify-playlist-from-upload\", '\n            '\"--download-spotify-playlist\", \"--spotify-playlists\", and '\n            '\"--check-tracks\".'\n        ),\n    )\n    sync_parser.add_argument(\n        \"--aws-profile\",\n        type=str,\n        help=\"AWS config profile.\",\n    )\n    sync_parser.add_argument(\n        \"--aws-use-date-modified\",\n        action=\"store_true\",\n        help=(\n            'Drop the \"--size-only\" flag for \"aws s3 sync\" command; '\n            '\"--aws-use-date-modified\" will permit re-syncing files if the '\n            \"date modified field changes.\"\n        ),\n    )\n    sync_parser.add_argument(\n        \"--bucket-url\",\n        type=str,\n        help=\"URL for an AWS S3 API compliant bucket.\",\n    )\n    sync_parser.add_argument(\n        \"--discord-url\",\n        type=str,\n        help=\"Discord webhook URL used to post uploaded tracks.\",\n    )\n    sync_parser.add_argument(\n        \"--download-collection\",\n        action=\"store_true\",\n        help=(\n            'Flag to trigger downloading the collection of \"--import-user\" '\n            \"from the Beatcloud.\"\n        ),\n    )\n    sync_parser.add_argument(\n        \"--download-exclude-dirs\",\n        type=_convert_to_paths,\n        nargs=\"+\",\n        action=NonEmptyListElementAction,\n        help=(\n            \"List of paths to exclude when downloading tracks from the \"\n            \"Beatcloud.\"\n        ),\n    )\n    sync_parser.add_argument(\n        \"--download-include-dirs\",\n        type=_convert_to_paths,\n        nargs=\"+\",\n        action=NonEmptyListElementAction,\n        help=(\n            \"List of paths to include when downloading tracks from the \"\n            \"Beatcloud.\"\n        ),\n    )\n    sync_parser.add_argument(\n        \"--download-music\",\n        action=\"store_true\",\n        help=\"Flag to trigger downloading tracks from the Beatcloud.\",\n    )\n    sync_parser.add_argument(\n        \"--download-spotify-playlist\",\n        type=str,\n        help=\"Playlist name containing tracks to download from the Beatcloud.\",\n    )\n    sync_parser.add_argument(\n        \"--dryrun\",\n        action=\"store_true\",\n        help=(\n            'Show result of \"--upload-music\" or \"--download-music\" commands '\n            \"without actually running them.\"\n        ),\n    )\n    sync_parser.add_argument(\n        \"--import-user\",\n        type=str,\n        help='\"--user\" whose \"--collection-path\" you\\'re downloading.',\n    )\n    sync_parser.add_argument(\n        \"--upload-collection\",\n        action=\"store_true\",\n        help=(\n            'Flag to trigger uploading the collection of \"--import_user\" from '\n            \"the Beatcloud.\"\n        ),\n    )\n    sync_parser.add_argument(\n        \"--upload-exclude-dirs\",\n        type=_convert_to_paths,\n        nargs=\"+\",\n        action=NonEmptyListElementAction,\n        help=(\n            \"List of paths to exclude when uploading tracks to the Beatcloud.\"\n        ),\n    )\n    sync_parser.add_argument(\n        \"--upload-include-dirs\",\n        type=_convert_to_paths,\n        nargs=\"+\",\n        action=NonEmptyListElementAction,\n        help=(\n            \"List of paths to include when uploading tracks to the Beatcloud.\"\n        ),\n    )\n    sync_parser.add_argument(\n        \"--upload-music\",\n        action=\"store_true\",\n        help=\"Flag to trigger uploading tracks to the Beatcloud.\",\n    )\n    sync_parser.add_argument(\n        \"--usb-path\",\n        type=_convert_to_paths,\n        help=(\n            \"Path to a drive containing completely and exclusively your set of\"\n            \" audio files.\"\n        ),\n    )\n    sync_parser.add_argument(\n        \"--user\",\n        type=str,\n        help=(\n            \"Username of the current user.\\nIf left empty, your operating \"\n            \"system username will be used.\\nMake sure you set this manually to\"\n            \" a consistent value so you don't create duplicate track \"\n            'collections in the Beatcloud and on your \"--usb-path\".'\n        ),\n    )\n\n    ###########################################################################\n    # Sub-command for the utils package.\n    ###########################################################################\n    utils_parser = subparsers.add_parser(\n        name=\"utils\",\n        help=(\n            \"Utilities that don't fit into any of the other packages.\\n  - \"\n            \"comparing tracks located in a list of Spotify playlists and/or a \"\n            \"list of local paths to tracks in the Beatcloud to determine if \"\n            \"you have redundancies\\n  - downloading audio files from a URL \"\n            \"containing embedded audio (e.g. Soundcloud)\\n  - normalizing the \"\n            \"peak amplitude of audio files in a list of directories\\n  - \"\n            \"processing a recording file using track data from a Spotify \"\n            \"playlist\"\n        ),\n        formatter_class=RawTextHelpFormatter,\n    )\n    utils_parser.add_argument(\n        \"--audio-bitrate\",\n        type=str,\n        help='Bitrate used to save files output by \"--process-recording\"',\n    )\n    utils_parser.add_argument(\n        \"--audio-destination\",\n        type=_convert_to_paths,\n        help=\"Location to download audio file(s) to.\",\n    )\n    utils_parser.add_argument(\n        \"--audio-format\",\n        type=str,\n        help='File format to save files output by \"--process-recording\"',\n    )\n    utils_parser.add_argument(\n        \"--audio-headroom\",\n        type=float,\n        help=\"Amount of headroom in decibels to leave when normalizing audio.\",\n    )\n    utils_parser.add_argument(\n        \"--check-tracks\",\n        action=\"store_true\",\n        help=(\n            \"Flag to trigger checking for track overlap between the Beatcloud \"\n            'and \"--local-dirs\" and / or \"--check-tracks-spotify-playlists\".'\n        ),\n    )\n    utils_parser.add_argument(\n        \"--check-tracks-fuzz-ratio\",\n        type=int,\n        help=(\n            \"Minimum similarity to indicate overlap between Beatcloud and \"\n            \"Spotify / local tracks.\"\n        ),\n    )\n    utils_parser.add_argument(\n        \"--check-tracks-spotify-playlists\",\n        type=str,\n        nargs=\"+\",\n        help=\"List of Spotify playlist names to check against the Beatcloud.\",\n    )\n    utils_parser.add_argument(\n        \"--local-dirs\",\n        type=_convert_to_paths,\n        nargs=\"+\",\n        action=NonEmptyListElementAction,\n        help=\"List of local directories to check against the Beatcloud.\",\n    )\n    utils_parser.add_argument(\n        \"--normalize-audio\",\n        action=\"store_true\",\n        help='Flag to trigger normalizing audio files at \"--local-dirs\".',\n    )\n    utils_parser.add_argument(\n        \"--process-recording\",\n        action=\"store_true\",\n        help=(\n            \"Flag to trigger processing an audio recording using a Spotify \"\n            \"playlist.\"\n        ),\n    )\n    utils_parser.add_argument(\n        \"--recording-file\",\n        type=_convert_to_paths,\n        help='Audio recording to pair with \"--recording-playlist\".',\n    )\n    utils_parser.add_argument(\n        \"--recording-playlist\",\n        type=str,\n        help='Spotify playlist to pair with \"--recording-file\".',\n    )\n    utils_parser.add_argument(\n        \"--trim-initial-silence\",\n        type=_parse_trim_initial_silence,\n        default=0,\n        help=(\n            'Milliseconds of initial silence to trim off \"--recording-file\". '\n            \"Can also be a negative integer to prepend silence. Can also be \"\n            '\"auto\" or \"smart\" for automatic silence detection or a '\n            \"home-brewed algorithm for finding the optimal offset.\"\n        ),\n    )\n    utils_parser.add_argument(\n        \"--url-download\",\n        type=str,\n        help=\"URL to download audio file(s) from.\",\n    )\n\n    return parser\n</code></pre>"},{"location":"reference/configs/#djtools.configs.helpers.ConfigLoadFailure","title":"<code>ConfigLoadFailure</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Exception for failing to load config.</p> Source code in <code>src/djtools/configs/helpers.py</code> <pre><code>class ConfigLoadFailure(Exception):\n    \"\"\"Exception for failing to load config.\"\"\"\n</code></pre>"},{"location":"reference/configs/#djtools.configs.helpers.InvalidConfigYaml","title":"<code>InvalidConfigYaml</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Exception for invalid config.</p> Source code in <code>src/djtools/configs/helpers.py</code> <pre><code>class InvalidConfigYaml(Exception):\n    \"\"\"Exception for invalid config.\"\"\"\n</code></pre>"},{"location":"reference/configs/#djtools.configs.helpers.build_config","title":"<code>build_config(config_file=Path(__file__).parent / 'config.yaml')</code>","text":"<p>This function loads configurations for the library.</p> <p>Configurations are loaded from config.yaml. If command-line arguments are provided, these override the configuration options set in config.yaml.</p> <p>Parameters:</p> Name Type Description Default <code>config_file</code> <code>Path</code> <p>Optional path to a config.yaml.</p> <code>parent / 'config.yaml'</code> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>config.yaml must be a valid YAML.</p> <p>Returns:</p> Type Description <code>BaseConfig</code> <p>Global configuration object.</p> Source code in <code>src/djtools/configs/helpers.py</code> <pre><code>@make_path\ndef build_config(\n    config_file: Path = Path(__file__).parent / \"config.yaml\",\n) -&gt; BaseConfig:\n    \"\"\"This function loads configurations for the library.\n\n    Configurations are loaded from config.yaml. If command-line arguments are\n    provided, these override the configuration options set in config.yaml.\n\n    Args:\n        config_file: Optional path to a config.yaml.\n\n    Raises:\n        RuntimeError: config.yaml must be a valid YAML.\n\n    Returns:\n        Global configuration object.\n    \"\"\"\n    # Create a default config if one doesn't already exist.\n    if not config_file.exists():\n        with open(config_file, mode=\"w\", encoding=\"utf-8\") as _file:\n            yaml.dump(BaseConfig().model_dump(), _file)\n\n    # Load the config.\n    try:\n        with open(config_file, mode=\"r\", encoding=\"utf-8\") as _file:\n            config_data = yaml.load(_file, Loader=yaml.FullLoader) or {}\n        config = BaseConfig(**config_data)\n    except Exception as exc:\n        msg = f\"Error reading config file {config_file}: {exc}\"\n        logger.critical(msg)\n        raise ConfigLoadFailure(msg) from exc\n\n    entry_frame_filename = inspect.stack()[-1][1]\n    valid_filenames = (\n        str(Path(\"bin\") / \"djtools\"),  # Unix djtools.\n        str(Path(\"bin\") / \"pytest\"),  # Unix pytest.\n        str(Path(\"lib\") / \"runpy.py\"),  # Windows Python&lt;=3.10.\n        \"&lt;frozen runpy&gt;\",  # Windows Python&gt;=3.11.\n    )\n\n    # Only get CLI arguments if calling djtools as a CLI.\n    if entry_frame_filename.endswith(valid_filenames):\n        cli_args = {\n            k: v for k, v in _arg_parse().items() if v or isinstance(v, list)\n        }\n        logger.info(f\"Args: {cli_args}\")\n        config = _update_config_with_cli_args(config, cli_args)\n\n    return config\n</code></pre>"},{"location":"reference/spotify/","title":"Spotify","text":"<p>This module contains the configuration object for the spotify package. The attributes of this configuration object correspond with the \"spotify\" key of config.yaml</p> <p>This module is responsible for creating or updating Spotify playlists. This can be done in a couple of ways.</p> <p>The first way is by using the posted output from <code>djtools.sync.sync_operations.upload_music</code>. When another user uploads music to the Beatcloud, you may want to generate a Spotify playlist from those tracks so they may be previewed before you decide whether or not to download them.</p> <p>The second way is by querying subreddit posts. Posts are first checked to see if they are direct links to a Spotify track. If this is not the case, then the post title is parsed in an attempt to interpret it as either 'ARTIST NAME - TRACK TITLE' or 'TRACK TITLE - ARTIST NAME'. These components are then used to search the Spotify API for tracks. The resulting tracks have their title and artist fields compared with the reddit post title and are added to the respective playlist if the Levenshtein similarity passes a threshold.</p> <p>This module contains helper functions used by the \"spotify\" module.</p>"},{"location":"reference/spotify/#djtools.spotify.config.SpotifyConfig","title":"<code>SpotifyConfig</code>","text":"<p>               Bases: <code>BaseConfigFormatter</code></p> <p>Configuration object for the spotify package.</p> Source code in <code>src/djtools/spotify/config.py</code> <pre><code>class SpotifyConfig(BaseConfigFormatter):\n    \"\"\"Configuration object for the spotify package.\"\"\"\n\n    spotify_playlist_default_limit: NonNegativeInt = 50\n    spotify_playlist_default_period: SubredditPeriod = SubredditPeriod.WEEK\n    spotify_playlist_default_type: SubredditType = SubredditType.HOT\n    spotify_playlist_from_upload: bool = False\n    spotify_playlist_fuzz_ratio: NonNegativeInt = 70\n    spotify_playlist_post_limit: NonNegativeInt = 100\n    spotify_playlist_subreddits: List[SubredditConfig] = []\n    spotify_playlists: bool = False\n    reddit_client_id: str = \"\"\n    reddit_client_secret: str = \"\"\n    reddit_user_agent: str = \"\"\n    spotify_client_id: str = \"\"\n    spotify_client_secret: str = \"\"\n    spotify_redirect_uri: str = \"\"\n    spotify_username: str = \"\"\n\n    def __init__(self, *args, **kwargs):\n        \"\"\"Constructor.\n\n        Raises:\n            RuntimeError: Spotify API credentials must exit.\n            RuntimeError: Spotify API credentials must be valid.\n            RuntimeError: Reddit API credentials must exist.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n\n        if (\n            self.spotify_playlists or self.spotify_playlist_from_upload\n        ) and not all(\n            [\n                self.spotify_client_id,\n                self.spotify_client_secret,\n                self.spotify_redirect_uri,\n                self.spotify_username,\n            ]\n        ):\n            raise RuntimeError(\n                \"Without all the configuration options spotify_client_id, \"\n                \"spotify_client_secret, spotify_redirect_uri, and \"\n                \"spotify_username set to valid values, you cannot use \"\n                \"spotify_playlists or spotify_playlist_from_upload\"\n            )\n        if self.spotify_playlists or self.spotify_playlist_from_upload:\n            # pylint: disable=cyclic-import\n            from djtools.spotify.helpers import get_spotify_client\n\n            spotify = get_spotify_client(self)\n            try:\n                spotify.current_user()\n            except Exception as exc:\n                raise RuntimeError(\"Spotify credentials are invalid!\") from exc\n\n        if self.spotify_playlists and not all(\n            [\n                self.reddit_client_id,\n                self.reddit_client_secret,\n                self.reddit_user_agent,\n            ]\n        ):\n            raise RuntimeError(\n                \"Without all the configuration options reddit_client_id, \"\n                \"reddit_client_secret, and reddit_user_agent, set to valid \"\n                \"values, you cannot use spotify_playlists\"\n            )\n</code></pre>"},{"location":"reference/spotify/#djtools.spotify.config.SpotifyConfig.__init__","title":"<code>__init__(*args, **kwargs)</code>","text":"<p>Constructor.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>Spotify API credentials must exit.</p> <code>RuntimeError</code> <p>Spotify API credentials must be valid.</p> <code>RuntimeError</code> <p>Reddit API credentials must exist.</p> Source code in <code>src/djtools/spotify/config.py</code> <pre><code>def __init__(self, *args, **kwargs):\n    \"\"\"Constructor.\n\n    Raises:\n        RuntimeError: Spotify API credentials must exit.\n        RuntimeError: Spotify API credentials must be valid.\n        RuntimeError: Reddit API credentials must exist.\n    \"\"\"\n    super().__init__(*args, **kwargs)\n\n    if (\n        self.spotify_playlists or self.spotify_playlist_from_upload\n    ) and not all(\n        [\n            self.spotify_client_id,\n            self.spotify_client_secret,\n            self.spotify_redirect_uri,\n            self.spotify_username,\n        ]\n    ):\n        raise RuntimeError(\n            \"Without all the configuration options spotify_client_id, \"\n            \"spotify_client_secret, spotify_redirect_uri, and \"\n            \"spotify_username set to valid values, you cannot use \"\n            \"spotify_playlists or spotify_playlist_from_upload\"\n        )\n    if self.spotify_playlists or self.spotify_playlist_from_upload:\n        # pylint: disable=cyclic-import\n        from djtools.spotify.helpers import get_spotify_client\n\n        spotify = get_spotify_client(self)\n        try:\n            spotify.current_user()\n        except Exception as exc:\n            raise RuntimeError(\"Spotify credentials are invalid!\") from exc\n\n    if self.spotify_playlists and not all(\n        [\n            self.reddit_client_id,\n            self.reddit_client_secret,\n            self.reddit_user_agent,\n        ]\n    ):\n        raise RuntimeError(\n            \"Without all the configuration options reddit_client_id, \"\n            \"reddit_client_secret, and reddit_user_agent, set to valid \"\n            \"values, you cannot use spotify_playlists\"\n        )\n</code></pre>"},{"location":"reference/spotify/#djtools.spotify.config.SubredditConfig","title":"<code>SubredditConfig</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Configuration object for spotify_playlists.</p> Source code in <code>src/djtools/spotify/config.py</code> <pre><code>class SubredditConfig(BaseModel):\n    \"\"\"Configuration object for spotify_playlists.\"\"\"\n\n    name: str\n    limit: NonNegativeInt = 50\n    period: SubredditPeriod = SubredditPeriod.WEEK\n    type: SubredditType = SubredditType.HOT\n</code></pre>"},{"location":"reference/spotify/#djtools.spotify.playlist_builder.async_spotify_playlists","title":"<code>async_spotify_playlists(config)</code>  <code>async</code>","text":"<p>This function updates the contents of one or more Spotify playlists with     the posts of one or more subreddits (currently only supports one     subreddit per playlist).</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>BaseConfig</code> <p>Configuration object.</p> required Source code in <code>src/djtools/spotify/playlist_builder.py</code> <pre><code>async def async_spotify_playlists(config: BaseConfig):\n    \"\"\"This function updates the contents of one or more Spotify playlists with\n        the posts of one or more subreddits (currently only supports one\n        subreddit per playlist).\n\n    Args:\n        config: Configuration object.\n    \"\"\"\n    spotify = get_spotify_client(config)\n    reddit = get_reddit_client(config)\n    playlist_ids = get_playlist_ids()\n\n    praw_cache = {}\n    cache_file = Path(__file__).parent / \".praw.cache\"\n    if cache_file.exists():\n        with open(cache_file, mode=\"r\", encoding=\"utf-8\") as _file:\n            praw_cache = yaml.load(_file, Loader=yaml.FullLoader) or {}\n\n    tasks = [\n        asyncio.create_task(\n            get_subreddit_posts(\n                spotify,\n                reddit,\n                subreddit,\n                config,\n                praw_cache,\n            )\n        )\n        for subreddit in config.spotify.spotify_playlist_subreddits\n    ]\n\n    for task in asyncio.as_completed(tasks):\n        tracks, subreddit = await task\n        playlist_ids = populate_playlist(\n            playlist_name=subreddit.name,\n            playlist_ids=playlist_ids,\n            spotify_username=config.spotify.spotify_username,\n            spotify=spotify,\n            tracks=tracks,\n            playlist_limit=subreddit.limit,\n            verbosity=config.verbosity,\n        )\n\n    await reddit.close()\n\n    write_playlist_ids(playlist_ids)\n\n    with open(cache_file, mode=\"w\", encoding=\"utf-8\") as _file:\n        yaml.dump(praw_cache, _file)\n</code></pre>"},{"location":"reference/spotify/#djtools.spotify.playlist_builder.spotify_playlist_from_upload","title":"<code>spotify_playlist_from_upload(config)</code>","text":"<p>Generates a Spotify playlist using a Discord webhook output.</p> <p>If \"upload_output\", a path to a text file containing the pasted output of the upload_music Discord webhook output, is provided, this is used to generate a Spotify playlist of those uploaded tracks. If this is not provided, then the clipboard contents are used instead.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>BaseConfig</code> <p>Configuration object.</p> required <p>Raises:</p> Type Description <code>RuntimeError</code> <p>Output from an upload_music Discord webhook must be copied to the system's clipboard</p> Source code in <code>src/djtools/spotify/playlist_builder.py</code> <pre><code>def spotify_playlist_from_upload(config: BaseConfig):\n    \"\"\"Generates a Spotify playlist using a Discord webhook output.\n\n    If \"upload_output\", a path to a text file containing the pasted output of\n    the upload_music Discord webhook output, is provided, this is used to\n    generate a Spotify playlist of those uploaded tracks. If this is not\n    provided, then the clipboard contents are used instead.\n\n    Args:\n        config: Configuration object.\n\n    Raises:\n        RuntimeError: Output from an upload_music Discord webhook must be\n            copied to the system's clipboard\n    \"\"\"\n    # Load upload output from the system's clipboard.\n    data = pyperclip.paste()\n    if not data:\n        raise RuntimeError(\n            \"Generating a Spotify playlist from an upload requires output \"\n            \"from an upload_music Discord webhook to be copied to the \"\n            \"system's clipboard\"\n        )\n\n    spotify = get_spotify_client(config)\n    playlist_ids = get_playlist_ids()\n\n    # Get (track title, artist name) tuples from file uploads.\n    user = \"\"\n    files = []\n    for line in data.split(\"\\n\"):\n        if not line.startswith(\" \"):\n            if not user:\n                user = line.split(\"/\")[0]\n            continue\n        file_ = Path(line).stem\n        try:\n            track, artist = file_.strip().split(\" - \")\n        except ValueError:\n            logger.warning(f\"{line.strip()} is not a valid file\")\n            continue\n        if config.sync.artist_first:\n            track, artist = artist, track\n        files.append((track, artist))\n    files = list(filter(lambda x: len(x) == 2, files))\n\n    # Query Spotify for files in upload output.\n    threshold = config.spotify.spotify_playlist_fuzz_ratio\n    tracks = []\n    for title, artist in files:\n        query = f\"track:{title} artist:{artist}\"\n        try:\n            results = spotify.search(q=query, type=\"track\", limit=50)\n        except Exception as exc:\n            logger.error(f'Error searching for \"{title} - {artist}\": {exc}')\n            continue\n\n        match, _ = filter_results(spotify, results, threshold, title, artist)\n        if match:\n            artists = \", \".join([y[\"name\"] for y in match[\"artists\"]])\n            logger.info(\n                f\"Matched {match['name']} - {artists} to {title} - {artist}\"\n            )\n        else:\n            logger.warning(f\"Could not find a match for {title} - {artist}\")\n            continue\n        tracks.append((match[\"id\"], f'{match[\"name\"]} - {artists}'))\n\n    playlist_ids = populate_playlist(\n        playlist_name=f\"{user} Uploads\",\n        playlist_ids=playlist_ids,\n        spotify_username=config.spotify.spotify_username,\n        spotify=spotify,\n        tracks=tracks,\n        verbosity=config.verbosity,\n    )\n\n    write_playlist_ids(playlist_ids)\n</code></pre>"},{"location":"reference/spotify/#djtools.spotify.playlist_builder.spotify_playlists","title":"<code>spotify_playlists(config)</code>","text":"<p>This function asynchronously updates Spotify playlists.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>BaseConfig</code> <p>Configuration object.</p> required Source code in <code>src/djtools/spotify/playlist_builder.py</code> <pre><code>def spotify_playlists(config: BaseConfig):\n    \"\"\"This function asynchronously updates Spotify playlists.\n\n    Args:\n        config: Configuration object.\n    \"\"\"\n    asyncio.run(async_spotify_playlists(config))\n</code></pre>"},{"location":"reference/spotify/#djtools.spotify.helpers.filter_results","title":"<code>filter_results(spotify, results, threshold, title, artist)</code>","text":"<p>Helper function for applying filtering logic to find tracks that     match the submission title closely enough.</p> <p>Parameters:</p> Name Type Description Default <code>spotify</code> <code>Spotify</code> <p>Spotify client.</p> required <code>results</code> <code>List[Dict]</code> <p>Spotify search results.</p> required <code>threshold</code> <code>float</code> <p>Minimum Levenshtein distance.</p> required <code>title</code> <code>str</code> <p>Potential title of a track.</p> required <code>artist</code> <code>str</code> <p>Potential artist of a track.</p> required <p>Returns:</p> Type Description <code>Tuple[Dict[str, Any], float]</code> <p>Tuple of track object and Levenshtein distance.</p> Source code in <code>src/djtools/spotify/helpers.py</code> <pre><code>def filter_results(\n    spotify: spotipy.Spotify,\n    results: List[Dict],\n    threshold: float,\n    title: str,\n    artist: str,\n) -&gt; Tuple[Dict[str, Any], float]:\n    \"\"\"Helper function for applying filtering logic to find tracks that\n        match the submission title closely enough.\n\n    Args:\n        spotify: Spotify client.\n        results: Spotify search results.\n        threshold: Minimum Levenshtein distance.\n        title: Potential title of a track.\n        artist: Potential artist of a track.\n\n    Returns:\n        Tuple of track object and Levenshtein distance.\n    \"\"\"\n    track, dist = {}, 0.0\n    tracks = _filter_tracks(\n        results[\"tracks\"][\"items\"], threshold, title, artist\n    )\n    while results[\"tracks\"][\"next\"]:\n        try:\n            results = spotify.next(results[\"tracks\"])\n        except Exception:\n            logger.warning(f\"Failed to get next tracks for {title, artist}\")\n            break\n        tracks.extend(\n            _filter_tracks(\n                results[\"tracks\"][\"items\"], threshold, title, artist\n            )\n        )\n\n    if tracks:\n        track, dist = max(tracks, key=itemgetter(1))\n\n    return track, dist\n</code></pre>"},{"location":"reference/spotify/#djtools.spotify.helpers.get_playlist_ids","title":"<code>get_playlist_ids()</code>","text":"<p>Load Spotify playlist names -&gt; IDs lookup.</p> <p>Returns:</p> Type Description <code>Dict[str, str]</code> <p>Dictionary of Spotify playlist names mapped to playlist IDs.</p> Source code in <code>src/djtools/spotify/helpers.py</code> <pre><code>def get_playlist_ids() -&gt; Dict[str, str]:\n    \"\"\"Load Spotify playlist names -&gt; IDs lookup.\n\n    Returns:\n        Dictionary of Spotify playlist names mapped to playlist IDs.\n    \"\"\"\n    playlist_ids = {}\n    ids_path = (\n        Path(__file__).parent.parent / \"configs\" / \"spotify_playlists.yaml\"\n    )\n    if ids_path.exists():\n        with open(ids_path, mode=\"r\", encoding=\"utf-8\") as _file:\n            playlist_ids = (\n                yaml.load(_file, Loader=yaml.FullLoader) or playlist_ids\n            )\n\n    return playlist_ids\n</code></pre>"},{"location":"reference/spotify/#djtools.spotify.helpers.get_reddit_client","title":"<code>get_reddit_client(config)</code>","text":"<p>Instantiate a Reddit API client.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>BaseConfig</code> <p>Configuration object.</p> required <p>Returns:</p> Type Description <code>Reddit</code> <p>Reddit API client.</p> Source code in <code>src/djtools/spotify/helpers.py</code> <pre><code>def get_reddit_client(config: BaseConfig) -&gt; praw.Reddit:\n    \"\"\"Instantiate a Reddit API client.\n\n    Args:\n        config: Configuration object.\n\n    Returns:\n        Reddit API client.\n    \"\"\"\n    reddit = praw.Reddit(\n        client_id=config.spotify.reddit_client_id,\n        client_secret=config.spotify.reddit_client_secret,\n        user_agent=config.spotify.reddit_user_agent,\n        timeout=30,\n    )\n\n    return reddit\n</code></pre>"},{"location":"reference/spotify/#djtools.spotify.helpers.get_spotify_client","title":"<code>get_spotify_client(config)</code>","text":"<p>Instantiate a Spotify API client.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>Union[BaseConfig, SpotifyConfig]</code> <p>Configuration object.</p> required <p>Returns:</p> Type Description <code>Spotify</code> <p>Spotify API client.</p> Source code in <code>src/djtools/spotify/helpers.py</code> <pre><code>def get_spotify_client(\n    config: Union[BaseConfig, SpotifyConfig],\n) -&gt; spotipy.Spotify:\n    \"\"\"Instantiate a Spotify API client.\n\n    Args:\n        config: Configuration object.\n\n    Returns:\n        Spotify API client.\n    \"\"\"\n    try:\n        spotify_config = getattr(config, \"spotify\")\n    except AttributeError:\n        spotify_config = config\n\n    spotify = spotipy.Spotify(\n        auth_manager=SpotifyOAuth(\n            client_id=spotify_config.spotify_client_id,\n            client_secret=spotify_config.spotify_client_secret,\n            redirect_uri=spotify_config.spotify_redirect_uri,\n            scope=\"playlist-modify-public\",\n            requests_timeout=30,\n            cache_handler=spotipy.CacheFileHandler(\n                cache_path=Path(__file__).parent / \".spotify.cache\"\n            ),\n        )\n    )\n\n    return spotify\n</code></pre>"},{"location":"reference/spotify/#djtools.spotify.helpers.get_subreddit_posts","title":"<code>get_subreddit_posts(spotify, reddit, subreddit, config, praw_cache)</code>  <code>async</code>","text":"<p>Filters the submissions for the provided subreddit and tries to resolve     each into a Spotify track until all the submissions are parsed or the     track limit has been met.</p> <p>Parameters:</p> Name Type Description Default <code>spotify</code> <code>Spotify</code> <p>Spotify client.</p> required <code>reddit</code> <code>Reddit</code> <p>Reddit client.</p> required <code>subreddit</code> <code>SubredditConfig</code> <p>SubredditConfig object.</p> required <code>config</code> <code>BaseConfig</code> <p>Configuration object.</p> required <code>praw_cache</code> <code>Dict[str, bool]</code> <p>Cached praw submissions.</p> required <p>Returns:</p> Type Description <code>Tuple[List[Tuple[str]], Dict[str, Union[str, int]]]</code> <p>List of Spotify track (\"id\", \"name\") tuples and SubredditConfig as a dictionary.</p> Source code in <code>src/djtools/spotify/helpers.py</code> <pre><code>async def get_subreddit_posts(\n    spotify: spotipy.Spotify,\n    reddit: praw.Reddit,\n    subreddit: SubredditConfig,\n    config: BaseConfig,\n    praw_cache: Dict[str, bool],\n) -&gt; Tuple[List[Tuple[str]], Dict[str, Union[str, int]]]:\n    \"\"\"Filters the submissions for the provided subreddit and tries to resolve\n        each into a Spotify track until all the submissions are parsed or the\n        track limit has been met.\n\n    Args:\n        spotify: Spotify client.\n        reddit: Reddit client.\n        subreddit: SubredditConfig object.\n        config: Configuration object.\n        praw_cache: Cached praw submissions.\n\n    Returns:\n        List of Spotify track (\"id\", \"name\") tuples and SubredditConfig as a\n            dictionary.\n    \"\"\"\n    sub = await reddit.subreddit(subreddit.name)\n    func = getattr(sub, subreddit.type.value)\n    kwargs = {\"limit\": config.spotify.spotify_playlist_post_limit}\n    if subreddit.type == SubredditType.TOP:\n        kwargs[\"time_filter\"] = subreddit.period\n    subs = [\n        x\n        async for x in _catch(\n            func(**kwargs), message=\"Failed to retrieve Reddit submission\"\n        )\n    ]\n    msg = f'Filtering {len(subs)} \"r/{subreddit.name}\" {subreddit.type.value} posts'\n    logger.info(msg)\n    submissions = []\n    for submission in tqdm(subs, desc=msg):\n        if submission.id in praw_cache:\n            continue\n        submissions.append(submission)\n        praw_cache[submission.id] = True\n    new_tracks = []\n    if submissions:\n        msg = (\n            f\"Searching Spotify for {len(submissions)} new submission(s) from \"\n            f'\"r/{subreddit.name}\"'\n        )\n        logger.info(msg)\n        payload = zip(\n            submissions,\n            [spotify] * len(submissions),\n            [config.spotify.spotify_playlist_fuzz_ratio] * len(submissions),\n        )\n\n        with ThreadPoolExecutor(max_workers=8) as executor:\n            futures = [executor.submit(_process, *args) for args in payload]\n\n            with tqdm(total=len(futures), desc=msg) as pbar:\n                new_tracks = []\n                for future in as_completed(futures):\n                    new_tracks.append(future.result())\n                    pbar.update(1)\n\n        new_tracks = [track for track in new_tracks if track]\n        logger.info(\n            f\"Got {len(new_tracks)} Spotify track(s) from new \"\n            f'\"r/{subreddit.name}\" posts'\n        )\n    else:\n        logger.info(f'No new submissions from \"r/{subreddit.name}\"')\n\n    return new_tracks, subreddit\n</code></pre>"},{"location":"reference/spotify/#djtools.spotify.helpers.populate_playlist","title":"<code>populate_playlist(playlist_name, playlist_ids, spotify_username, spotify, tracks, playlist_limit=sys.maxsize, verbosity=0)</code>","text":"<p>Inserts tracks into either a new playlist or an existing one.</p> <p>Parameters:</p> Name Type Description Default <code>playlist_name</code> <code>str</code> <p>Name of the playlist.</p> required <code>playlist_ids</code> <code>Dict[str, str]</code> <p>Lookup of playlist IDs.</p> required <code>spotify_username</code> <code>str</code> <p>Spotify user's username.</p> required <code>spotify</code> <code>Spotify</code> <p>Spotify client.</p> required <code>tracks</code> <code>List[Tuple[str]]</code> <p>List of tracks.</p> required <code>playlist_limit</code> <code>Optional[int]</code> <p>Maximum number of tracks allowed in a playlist.</p> <code>maxsize</code> <code>verbosity</code> <code>Optional[int]</code> <p>Logging verbosity level.</p> <code>0</code> <p>Returns:</p> Type Description <code>Dict[str, str]</code> <p>Updated playlist IDs.</p> Source code in <code>src/djtools/spotify/helpers.py</code> <pre><code>def populate_playlist(\n    playlist_name: str,\n    playlist_ids: Dict[str, str],\n    spotify_username: str,\n    spotify: spotipy.Spotify,\n    tracks: List[Tuple[str]],\n    playlist_limit: Optional[int] = sys.maxsize,\n    verbosity: Optional[int] = 0,\n) -&gt; Dict[str, str]:\n    \"\"\"Inserts tracks into either a new playlist or an existing one.\n\n    Args:\n        playlist_name: Name of the playlist.\n        playlist_ids: Lookup of playlist IDs.\n        spotify_username: Spotify user's username.\n        spotify: Spotify client.\n        tracks: List of tracks.\n        playlist_limit: Maximum number of tracks allowed in a playlist.\n        verbosity: Logging verbosity level.\n\n    Returns:\n        Updated playlist IDs.\n    \"\"\"\n    playlist_id = playlist_ids.get(playlist_name)\n    playlist = None\n    if playlist_id and tracks:\n        playlist = _update_existing_playlist(\n            spotify,\n            playlist_id,\n            tracks,\n            playlist_limit,\n            verbosity,\n        )\n    elif tracks:\n        logger.warning(\n            f\"Unable to get ID for {playlist_name}...creating a new \"\n            \"playlist\"\n        )\n        playlist = _build_new_playlist(\n            spotify, spotify_username, playlist_name, tracks\n        )\n        playlist_ids[playlist_name] = playlist[\"id\"]\n    elif playlist_id:\n        playlist = spotify.playlist(playlist_id)\n    if playlist:\n        logger.info(\n            f'\"{playlist[\"name\"]}\": '\n            f'{playlist[\"external_urls\"].get(\"spotify\")}'\n        )\n\n    return playlist_ids\n</code></pre>"},{"location":"reference/spotify/#djtools.spotify.helpers.write_playlist_ids","title":"<code>write_playlist_ids(playlist_ids)</code>","text":"<p>Write playlist IDs to file.</p> <p>Parameters:</p> Name Type Description Default <code>playlist_ids</code> <code>Dict[str, str]</code> <p>Dictionary of Spotify playlist names mapped to playlist IDs.</p> required Source code in <code>src/djtools/spotify/helpers.py</code> <pre><code>def write_playlist_ids(playlist_ids: Dict[str, str]):\n    \"\"\"Write playlist IDs to file.\n\n    Args:\n        playlist_ids: Dictionary of Spotify playlist names mapped to playlist\n            IDs.\n    \"\"\"\n    ids_path = (\n        Path(__file__).parent.parent / \"configs\" / \"spotify_playlists.yaml\"\n    )\n    with open(ids_path, mode=\"w\", encoding=\"utf-8\") as _file:\n        yaml.dump(playlist_ids, _file)\n</code></pre>"},{"location":"reference/sync/","title":"Sync","text":"<p>This module contains the configuration object for the sync package. The attributes of this configuration object correspond with the \"sync\" key of config.yaml</p> <p>This module is responsible for syncing tracks between \"usb_path\" and the Beatcloud (upload and download). It also handles uploading the collection located at \"collection_path\" and downloading the collection uploaded to the Beatcloud by \"import_user\" before modifying it to point to track locations at \"usb_path\".</p> <p>This module contains helper functions used by the \"sync_operations\" module. Helper functions include formatting \"aws s3 sync\" commands, formatting the output of \"aws s3 sync\" commands, posting uploaded tracks to Discord, and modifying import_user's collection to point to tracks located at \"usb_path\".</p>"},{"location":"reference/sync/#djtools.sync.config.SyncConfig","title":"<code>SyncConfig</code>","text":"<p>               Bases: <code>BaseConfigFormatter</code></p> <p>Configuration object for the sync package.</p> Source code in <code>src/djtools/sync/config.py</code> <pre><code>class SyncConfig(BaseConfigFormatter):\n    \"\"\"Configuration object for the sync package.\"\"\"\n\n    artist_first: bool = False\n    aws_profile: str = \"default\"\n    aws_use_date_modified: bool = False\n    bucket_url: str = \"\"\n    discord_url: str = \"\"\n    download_collection: bool = False\n    download_exclude_dirs: List[Path] = []\n    download_include_dirs: List[Path] = []\n    download_music: bool = False\n    download_spotify_playlist: str = \"\"\n    dryrun: bool = False\n    import_user: str = \"\"\n    upload_collection: bool = False\n    upload_exclude_dirs: List[Path] = []\n    upload_include_dirs: List[Path] = []\n    upload_music: bool = False\n    usb_path: Optional[Path] = None\n    user: str = \"\"\n\n    def __init__(self, *args, **kwargs):\n        \"\"\"Constructor.\n\n        Raises:\n            ValueError: Both include and exclude dirs can't be provided at the\n                same time.\n            RuntimeError: aws_profile must be set.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        if not self.user:\n            self.user = getpass.getuser()\n\n        if (self.upload_include_dirs and self.upload_exclude_dirs) or (\n            self.download_include_dirs and self.download_exclude_dirs\n        ):\n            msg = (\n                \"Config must neither contain both upload_include_dirs and \"\n                \"upload_exclude_dirs or both download_include_dirs and \"\n                \"download_exclude_dirs\"\n            )\n            logger.critical(msg)\n            raise ValueError(msg)\n\n        if any(\n            [\n                self.download_collection,\n                self.download_music,\n                self.upload_collection,\n                self.upload_music,\n            ]\n        ):\n            if not self.aws_profile:\n                msg = \"Config must include aws_profile for sync operations\"\n                logger.critical(msg)\n                raise RuntimeError(msg)\n\n            if not self.bucket_url:\n                msg = \"Config must include bucket_url for sync operations\"\n                logger.critical(msg)\n                raise RuntimeError(msg)\n\n        os.environ[\"AWS_PROFILE\"] = (\n            self.aws_profile\n        )  # pylint: disable=no-member\n\n        if any([self.download_music, self.upload_music]) and not self.usb_path:\n            msg = (\n                \"Config must include usb_path for both download_music and \"\n                \"upload_music sync operations\"\n            )\n            logger.critical(msg)\n            raise RuntimeError(msg)\n\n        if (\n            any([self.download_music, self.upload_music])\n            and not self.usb_path.exists()\n        ):\n            msg = f'Configured usb_path \"{self.usb_path}\" was not found!'\n            logger.critical(msg)\n            raise RuntimeError(msg)\n\n        if self.upload_music and not self.discord_url:\n            logger.warning(\n                'discord_url is not configured...set this for \"New Music\" '\n                \"discord messages!\"\n            )\n\n        if self.download_collection and not self.import_user:\n            raise RuntimeError(\n                \"import_user must be set to download a collection\"\n            )\n</code></pre>"},{"location":"reference/sync/#djtools.sync.config.SyncConfig.__init__","title":"<code>__init__(*args, **kwargs)</code>","text":"<p>Constructor.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Both include and exclude dirs can't be provided at the same time.</p> <code>RuntimeError</code> <p>aws_profile must be set.</p> Source code in <code>src/djtools/sync/config.py</code> <pre><code>def __init__(self, *args, **kwargs):\n    \"\"\"Constructor.\n\n    Raises:\n        ValueError: Both include and exclude dirs can't be provided at the\n            same time.\n        RuntimeError: aws_profile must be set.\n    \"\"\"\n    super().__init__(*args, **kwargs)\n    if not self.user:\n        self.user = getpass.getuser()\n\n    if (self.upload_include_dirs and self.upload_exclude_dirs) or (\n        self.download_include_dirs and self.download_exclude_dirs\n    ):\n        msg = (\n            \"Config must neither contain both upload_include_dirs and \"\n            \"upload_exclude_dirs or both download_include_dirs and \"\n            \"download_exclude_dirs\"\n        )\n        logger.critical(msg)\n        raise ValueError(msg)\n\n    if any(\n        [\n            self.download_collection,\n            self.download_music,\n            self.upload_collection,\n            self.upload_music,\n        ]\n    ):\n        if not self.aws_profile:\n            msg = \"Config must include aws_profile for sync operations\"\n            logger.critical(msg)\n            raise RuntimeError(msg)\n\n        if not self.bucket_url:\n            msg = \"Config must include bucket_url for sync operations\"\n            logger.critical(msg)\n            raise RuntimeError(msg)\n\n    os.environ[\"AWS_PROFILE\"] = (\n        self.aws_profile\n    )  # pylint: disable=no-member\n\n    if any([self.download_music, self.upload_music]) and not self.usb_path:\n        msg = (\n            \"Config must include usb_path for both download_music and \"\n            \"upload_music sync operations\"\n        )\n        logger.critical(msg)\n        raise RuntimeError(msg)\n\n    if (\n        any([self.download_music, self.upload_music])\n        and not self.usb_path.exists()\n    ):\n        msg = f'Configured usb_path \"{self.usb_path}\" was not found!'\n        logger.critical(msg)\n        raise RuntimeError(msg)\n\n    if self.upload_music and not self.discord_url:\n        logger.warning(\n            'discord_url is not configured...set this for \"New Music\" '\n            \"discord messages!\"\n        )\n\n    if self.download_collection and not self.import_user:\n        raise RuntimeError(\n            \"import_user must be set to download a collection\"\n        )\n</code></pre>"},{"location":"reference/sync/#djtools.sync.sync_operations.download_collection","title":"<code>download_collection(config)</code>","text":"<p>This function downloads the collection of \"import_user\".</p> <p>After downloading \"import_user\"'s collection, the location of all the tracks are modified so that they point to user's \"usb_path\".</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>BaseConfig</code> <p>Configuration object.</p> required Source code in <code>src/djtools/sync/sync_operations.py</code> <pre><code>def download_collection(config: BaseConfig):\n    \"\"\"This function downloads the collection of \"import_user\".\n\n    After downloading \"import_user\"'s collection, the location of all the\n    tracks are modified so that they point to user's \"usb_path\".\n\n    Args:\n        config: Configuration object.\n    \"\"\"\n    logger.info(\n        f\"Downloading {config.sync.import_user}'s {config.collection.platform.value} collection...\"\n    )\n    collection_dir = config.collection.collection_path.parent\n    src = (\n        f\"{config.sync.bucket_url}/dj/collections/{config.sync.import_user}/\"\n        f\"{config.collection.platform.value}_collection\"\n    )\n    dst = (\n        Path(collection_dir)\n        / f\"{config.sync.import_user}_{config.collection.collection_path.name}\"\n    )\n    cmd = [\"aws\", \"s3\", \"cp\", src, dst.as_posix()]\n    if config.collection.collection_path.is_dir():\n        cmd.append(\"--recursive\")\n    logger.info(\" \".join(cmd))\n    with Popen(cmd) as proc:\n        proc.wait()\n    if config.sync.user != config.sync.import_user:\n        rewrite_track_paths(config, dst)\n</code></pre>"},{"location":"reference/sync/#djtools.sync.sync_operations.download_music","title":"<code>download_music(config, beatcloud_tracks=None)</code>","text":"<p>This function syncs tracks from the Beatcloud to \"usb_path\".</p> <p>If \"download_spotify_playlist\" is set to a playlist name that exists in \"spotify_playlists.yaml\", then \"download_include_dirs\" will be populated with tracks in that playlist that match Beatcloud tracks.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>BaseConfig</code> <p>Configuration object.</p> required <code>beatcloud_tracks</code> <code>Optional[List[str]]</code> <p>List of track artist - titles from S3.</p> <code>None</code> Source code in <code>src/djtools/sync/sync_operations.py</code> <pre><code>def download_music(\n    config: BaseConfig, beatcloud_tracks: Optional[List[str]] = None\n):\n    \"\"\"This function syncs tracks from the Beatcloud to \"usb_path\".\n\n    If \"download_spotify_playlist\" is set to a playlist name that exists in\n    \"spotify_playlists.yaml\", then \"download_include_dirs\" will be populated\n    with tracks in that playlist that match Beatcloud tracks.\n\n    Args:\n        config: Configuration object.\n        beatcloud_tracks: List of track artist - titles from S3.\n    \"\"\"\n    if config.sync.download_spotify_playlist:\n        playlist_name = config.sync.download_spotify_playlist\n        user = playlist_name.split(\"Uploads\")[0].strip()\n        beatcloud_tracks, beatcloud_matches = compare_tracks(\n            config,\n            beatcloud_tracks=beatcloud_tracks,\n        )\n        if not beatcloud_matches:\n            logger.warning(\n                \"No Beatcloud matches were found! Make sure you've supplied \"\n                \"the correct playlist name.\"\n            )\n            return beatcloud_tracks\n        config.sync.download_include_dirs = [\n            (Path(user) / path.as_posix().split(f\"{Path(user)}/\")[-1])\n            for path in beatcloud_matches\n        ]\n        config.sync.download_exclude_dirs = []\n\n    logger.info(\"Downloading track collection...\")\n    dest = Path(config.sync.usb_path) / \"DJ Music\"\n    glob_path = (Path(\"**\") / \"*.*\").as_posix()\n    old = {str(p) for p in dest.rglob(glob_path)}\n    logger.info(f\"Found {len(old)} files at {config.sync.usb_path}\")\n\n    dest.mkdir(parents=True, exist_ok=True)\n    cmd = [\n        \"aws\",\n        \"s3\",\n        \"sync\",\n        f\"{config.sync.bucket_url}/dj/music/\",\n        dest.as_posix(),\n    ]\n    run_sync(parse_sync_command(cmd, config), config.sync.bucket_url)\n\n    new = {str(p) for p in dest.rglob(glob_path)}\n    difference = sorted(list(new.difference(old)), key=getmtime)\n    if difference:\n        logger.info(f\"Found {len(difference)} new files\")\n        for diff in difference:\n            logger.info(f\"\\t{diff}\")\n\n    return beatcloud_tracks\n</code></pre>"},{"location":"reference/sync/#djtools.sync.sync_operations.upload_collection","title":"<code>upload_collection(config)</code>","text":"<p>This function uploads \"collection_path\" to the cloud.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>BaseConfig</code> <p>Configuration object.</p> required Source code in <code>src/djtools/sync/sync_operations.py</code> <pre><code>def upload_collection(config: BaseConfig):\n    \"\"\"This function uploads \"collection_path\" to the cloud.\n\n    Args:\n        config: Configuration object.\n    \"\"\"\n    logger.info(\n        f\"Uploading {config.sync.user}'s {config.collection.platform.value} collection...\"\n    )\n    dst = (\n        f\"{config.sync.bucket_url}/dj/collections/{config.sync.user}/\"\n        f\"{config.collection.platform.value}_collection\"\n    )\n    cmd = [\n        \"aws\",\n        \"s3\",\n        \"cp\",\n        config.collection.collection_path.as_posix(),\n        dst,\n    ]\n    if config.collection.collection_path.is_dir():\n        cmd.append(\"--recursive\")\n    logger.info(\" \".join(cmd))\n    with Popen(cmd) as proc:\n        proc.wait()\n</code></pre>"},{"location":"reference/sync/#djtools.sync.sync_operations.upload_music","title":"<code>upload_music(config)</code>","text":"<p>This function syncs tracks from \"usb_path\" to the Beatcloud.</p> <p>\"aws_use_date_modified\" can be used in order to re-upload tracks that already exist in the Beatcloud but have been modified since the last time they were uploaded (i.e. ID3 tags have been altered).</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>BaseConfig</code> <p>Configuration object.</p> required Source code in <code>src/djtools/sync/sync_operations.py</code> <pre><code>def upload_music(config: BaseConfig):\n    \"\"\"This function syncs tracks from \"usb_path\" to the Beatcloud.\n\n    \"aws_use_date_modified\" can be used in order to re-upload tracks that\n    already exist in the Beatcloud but have been modified since the last time\n    they were uploaded (i.e. ID3 tags have been altered).\n\n    Args:\n        config: Configuration object.\n    \"\"\"\n    hidden_files = set(\n        (Path(config.sync.usb_path) / \"DJ Music\").rglob(\n            (Path(\"**\") / \".*.*\").as_posix()\n        )\n    )\n    if hidden_files:\n        logger.info(f\"Removed {len(hidden_files)} files...\")\n        for _file in hidden_files:\n            logger.info(f\"\\t{_file}\")\n            _file.unlink()\n\n    logger.info(\"Uploading track collection...\")\n    src = (Path(config.sync.usb_path) / \"DJ Music\").as_posix()\n    cmd = [\"aws\", \"s3\", \"sync\", src, f\"{config.sync.bucket_url}/dj/music/\"]\n\n    if config.sync.discord_url and not config.sync.dryrun:\n        webhook(\n            config.sync.discord_url,\n            content=run_sync(\n                parse_sync_command(cmd, config, upload=True),\n                config.sync.bucket_url,\n            ),\n        )\n    else:\n        run_sync(\n            parse_sync_command(cmd, config, upload=True),\n            config.sync.bucket_url,\n        )\n</code></pre>"},{"location":"reference/sync/#djtools.sync.helpers.parse_sync_command","title":"<code>parse_sync_command(_cmd, config, upload=False)</code>","text":"<p>Appends flags to \"aws s3 sync\" command. If \"_include_dirs\" is     specified, all directories are ignored except those specified. If     \"_exclude_dirs\" is specified, all directories are included except     those specified. Only one of these can be specified at once. If     \"aws_use_date_modified\", then tracks will be     re-downloaded / re-uploaded if their date modified at the source is     after that of the destination.</p> <p>Parameters:</p> Name Type Description Default <code>_cmd</code> <code>str</code> <p>Partial \"aws s3 sync\" command.</p> required <code>config</code> <code>BaseConfig</code> <p>Configuration object.</p> required <code>upload</code> <code>Optional[bool]</code> <p>Whether uploading or downloading.</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>Fully constructed \"aws s3 sync\" command.</p> Source code in <code>src/djtools/sync/helpers.py</code> <pre><code>def parse_sync_command(\n    _cmd: str,\n    config: BaseConfig,\n    upload: Optional[bool] = False,\n) -&gt; str:\n    \"\"\"Appends flags to \"aws s3 sync\" command. If \"*_include_dirs\" is\n        specified, all directories are ignored except those specified. If\n        \"*_exclude_dirs\" is specified, all directories are included except\n        those specified. Only one of these can be specified at once. If\n        \"aws_use_date_modified\", then tracks will be\n        re-downloaded / re-uploaded if their date modified at the source is\n        after that of the destination.\n\n    Args:\n        _cmd: Partial \"aws s3 sync\" command.\n        config: Configuration object.\n        upload: Whether uploading or downloading.\n\n    Returns:\n        Fully constructed \"aws s3 sync\" command.\n    \"\"\"\n    if (upload and config.sync.upload_include_dirs) or (\n        not upload and config.sync.download_include_dirs\n    ):\n        _cmd.extend([\"--exclude\", \"*\"])\n        directories = map(\n            Path,\n            getattr(\n                config.sync, f'{\"up\" if upload else \"down\"}load_include_dirs'\n            ),\n        )\n        for _dir in directories:\n            path = Path(_dir.stem)\n            ext = _dir.suffix\n            if not ext:\n                path = _dir / \"*\"\n            else:\n                path = _dir.parent / path.with_suffix(ext)\n            _cmd.extend([\"--include\", path.as_posix()])\n    if (upload and config.sync.upload_exclude_dirs) or (\n        not upload and config.sync.download_exclude_dirs\n    ):\n        _cmd.extend([\"--include\", \"*\"])\n        directories = map(\n            Path,\n            getattr(\n                config.sync, f'{\"up\" if upload else \"down\"}load_exclude_dirs'\n            ),\n        )\n        for _dir in directories:\n            path = Path(_dir.stem)\n            ext = _dir.suffix\n            if not ext:\n                path = _dir / \"*\"\n            else:\n                path = _dir.parent / path.with_suffix(ext)\n            _cmd.extend([\"--exclude\", path.as_posix()])\n    if not config.sync.aws_use_date_modified:\n        _cmd.append(\"--size-only\")\n    if config.sync.dryrun:\n        _cmd.append(\"--dryrun\")\n    logger.info(\" \".join(_cmd))\n\n    return _cmd\n</code></pre>"},{"location":"reference/sync/#djtools.sync.helpers.rewrite_track_paths","title":"<code>rewrite_track_paths(config, other_user_collection)</code>","text":"<p>This function modifies the location of tracks in a collection.</p> <p>This is done by replacing the \"usb_path\" written by \"import_user\" with the \"usb_path\" in \"config.yaml\".</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>BaseConfig</code> <p>Configuration object.</p> required <code>other_user_collection</code> <code>Path</code> <p>Path to another user's collection.</p> required Source code in <code>src/djtools/sync/helpers.py</code> <pre><code>@make_path\ndef rewrite_track_paths(config: BaseConfig, other_user_collection: Path):\n    \"\"\"This function modifies the location of tracks in a collection.\n\n    This is done by replacing the \"usb_path\" written by \"import_user\" with the\n    \"usb_path\" in \"config.yaml\".\n\n    Args:\n        config: Configuration object.\n        other_user_collection: Path to another user's collection.\n    \"\"\"\n    music_path = Path(\"DJ Music\")\n    collection = PLATFORM_REGISTRY[config.collection.platform][\"collection\"](\n        path=other_user_collection\n    )\n    for track in collection.get_tracks().values():\n        loc = track.get_location().as_posix()\n        common_path = (\n            music_path / loc.split(str(music_path) + \"/\", maxsplit=-1)[-1]\n        )\n        track.set_location(config.sync.usb_path / common_path)\n    collection.serialize(path=other_user_collection)\n</code></pre>"},{"location":"reference/sync/#djtools.sync.helpers.run_sync","title":"<code>run_sync(_cmd, bucket_url)</code>","text":"<p>Runs subprocess for \"aws s3 sync\" command. Output is collected and     formatted such that uploaded tracks are grouped by their directories.</p> <p>Parameters:</p> Name Type Description Default <code>_cmd</code> <code>str</code> <p>\"aws s3 sync\" command.</p> required <code>bucket_url</code> <code>str</code> <p>URL to an AWS S3 API compliant bucket.</p> required <p>Raises:</p> Type Description <code>CalledProcessError</code> <p>raised if \"aws s3 sync\" command fails.</p> <code>RuntimeError</code> <p>raised if any other exception occurs while syncing.</p> <p>Returns:</p> Type Description <code>str</code> <p>Formatted list of uploaded tracks; tracks are grouped by directory.</p> Source code in <code>src/djtools/sync/helpers.py</code> <pre><code>def run_sync(_cmd: str, bucket_url: str) -&gt; str:\n    \"\"\"Runs subprocess for \"aws s3 sync\" command. Output is collected and\n        formatted such that uploaded tracks are grouped by their directories.\n\n    Args:\n        _cmd: \"aws s3 sync\" command.\n        bucket_url: URL to an AWS S3 API compliant bucket.\n\n    Raises:\n        CalledProcessError: raised if \"aws s3 sync\" command fails.\n        RuntimeError: raised if any other exception occurs while syncing.\n\n    Returns:\n        Formatted list of uploaded tracks; tracks are grouped by directory.\n    \"\"\"\n    line = \"\"\n    termination_chars = {\"\\n\", \"\\r\"}\n    tracks = []\n    try:\n        with Popen(_cmd, stdout=PIPE) as proc:\n            while True:\n                try:\n                    char = proc.stdout.read(1).decode()\n                except UnicodeDecodeError:\n                    char = \"\"\n                if char == \"\" and proc.poll() is not None:\n                    break\n                if char not in termination_chars:\n                    line += char\n                    continue\n                print(line, end=char)\n                if char != \"\\r\" and \"upload: \" in line:\n                    line = line.split(f\"{bucket_url}/dj/music/\")[-1]\n                    tracks.append(Path(line))\n                line = \"\"\n            proc.stdout.close()\n            return_code = proc.wait()\n        if return_code:\n            raise CalledProcessError(return_code, \" \".join(_cmd))\n    except Exception as exc:\n        msg = f\"Failure while syncing: {exc}\"\n        logger.critical(msg)\n        raise RuntimeError(msg) from exc\n\n    new_music = \"\"\n    for group_id, group in groupby(\n        sorted(tracks, key=lambda x: x.parent.as_posix()),\n        key=lambda x: x.parent.as_posix(),\n    ):\n        group = sorted(group)\n        new_music += f\"{group_id}: {len(group)}\\n\"\n        for track in group:\n            new_music += f\"\\t{track.name}\\n\"\n    if new_music:\n        logger.info(\n            f\"Successfully uploaded {len(tracks)} tracks:\\n{new_music}\"\n        )\n\n    return new_music\n</code></pre>"},{"location":"reference/sync/#djtools.sync.helpers.upload_log","title":"<code>upload_log(config, log_file)</code>","text":"<p>This function uploads \"log_file\" to the \"user\" logs folder in S3. It     then deletes all files created more than one day ago.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>BaseConfig</code> <p>Configuration object.</p> required <code>log_file</code> <code>Path</code> <p>Path to log file.</p> required Source code in <code>src/djtools/sync/helpers.py</code> <pre><code>@make_path\ndef upload_log(config: BaseConfig, log_file: Path):\n    \"\"\"This function uploads \"log_file\" to the \"user\" logs folder in S3. It\n        then deletes all files created more than one day ago.\n\n    Args:\n        config: Configuration object.\n        log_file: Path to log file.\n    \"\"\"\n    if not config.sync.aws_profile:\n        logger.warning(\n            \"Logs cannot be backed up without specifying the config option \"\n            \"aws_profile\"\n        )\n        return\n\n    dst = (\n        f\"{config.sync.bucket_url}/dj/logs/{config.sync.user}/{log_file.name}\"\n    )\n    cmd = [\"aws\", \"s3\", \"cp\", log_file.as_posix(), dst]\n    logger.info(\" \".join(cmd))\n    with Popen(cmd) as proc:\n        proc.wait()\n\n    now = datetime.now()\n    one_day = timedelta(days=1)\n    for _file in log_file.parent.rglob(\"*\"):\n        if (\n            _file.name != \"__init__.py\"\n            and _file.is_file()\n            and _file.lstat().st_mtime &lt; (now - one_day).timestamp()\n        ):\n            _file.unlink()\n</code></pre>"},{"location":"reference/sync/#djtools.sync.helpers.webhook","title":"<code>webhook(url, content_size_limit=2000, content=None)</code>","text":"<p>Post track list of newly uploaded tracks to Discord channel associated     with \"url\". Track list is split across multiple messages if the     character limit exceed \"content_size_limit\".</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>Discord URL for webhook.</p> required <code>content_size_limit</code> <code>int</code> <p>Character limit for Discord message; if content is larger, then multiple messages are sent.</p> <code>2000</code> <code>content</code> <code>Optional[str]</code> <p>Uploaded tracks (if any).</p> <code>None</code> Source code in <code>src/djtools/sync/helpers.py</code> <pre><code>def webhook(\n    url: str, content_size_limit: int = 2000, content: Optional[str] = None\n):\n    \"\"\"Post track list of newly uploaded tracks to Discord channel associated\n        with \"url\". Track list is split across multiple messages if the\n        character limit exceed \"content_size_limit\".\n\n    Args:\n        url (str): Discord URL for webhook.\n        content_size_limit: Character limit for Discord message; if content is\n            larger, then multiple messages are sent.\n        content: Uploaded tracks (if any).\n    \"\"\"\n    if not content:\n        logger.info(\"There's no content\")\n        return\n\n    batch = content[:content_size_limit]\n    remainder = content[content_size_limit:]\n    while batch:\n        index = content_size_limit - 1\n        while True:\n            if index == 0:\n                index = content_size_limit\n                break\n            try:\n                if batch[index] == \"\\n\":\n                    break\n            except IndexError:\n                break\n            index -= 1\n        remainder = batch[index + 1 :] + remainder\n        batch = batch[: index + 1]\n\n        if batch:\n            requests.post(url, json={\"content\": batch}, timeout=10)\n            batch = remainder[:content_size_limit]\n            remainder = remainder[content_size_limit:]\n</code></pre>"},{"location":"reference/utils/","title":"Utils","text":"<p>This module contains the configuration object for the utils package. The attributes of this configuration object correspond with the \"utils\" key of config.yaml</p> <p>This module is used to compare tracks from Spotify playlists and / or local directories to see if there is any overlap with the contents of the Beatcloud.</p> <p>This module is used to normalize audio files in one or more directories.</p> <p>This module is used to process an audio recording.</p> <p>Given a recording of multiple tracks and a Spotify playlist, use the information from the Spotify API to:</p> <ul> <li>split the recording into individual files</li> <li>name these files with the title and artist(s)</li> <li>populate the title, artist, and album tags</li> <li>normalize the audio so the headroom is audio_headroom decibels</li> <li>export the files with the configured audio_bitrate and audio_format</li> </ul> <p>This module is used to download tracks from \"url_download\". For example, a Soundcloud playlist can be made and the URL of that playlist can be provided to download all those tracks and rename them to cleanup the digits appended to the files by the youtube-dl package.</p> <p>This module contains helper functions that are not specific to any particular sub-package of this library.</p>"},{"location":"reference/utils/#djtools.utils.config.UtilsConfig","title":"<code>UtilsConfig</code>","text":"<p>               Bases: <code>BaseConfigFormatter</code></p> <p>Configuration object for the utils package.</p> Source code in <code>src/djtools/utils/config.py</code> <pre><code>class UtilsConfig(BaseConfigFormatter):\n    \"\"\"Configuration object for the utils package.\"\"\"\n\n    audio_bitrate: str = \"320\"\n    audio_destination: Optional[Path] = None\n    audio_format: AudioFormats = AudioFormats.MP3\n    audio_headroom: NonNegativeFloat = 0.0\n    check_tracks: bool = False\n    check_tracks_fuzz_ratio: NonNegativeInt = 80\n    check_tracks_spotify_playlists: List[str] = []\n    local_dirs: List[Path] = []\n    normalize_audio: bool = False\n    process_recording: bool = False\n    recording_file: Optional[Path] = None\n    recording_playlist: str = \"\"\n    trim_initial_silence: Union[int, TrimInitialSilenceMode] = 0\n    url_download: str = \"\"\n\n    def __init__(self, *args, **kwargs):\n        \"\"\"Constructor.\n\n        Raises:\n            RuntimeError: aws_profile must be set for check_tracks.\n        \"\"\"\n\n        super().__init__(*args, **kwargs)\n        if self.check_tracks:\n            if not os.environ.get(\"AWS_PROFILE\"):\n                raise RuntimeError(\n                    \"Without aws_profile set to a valid profile ('default' or \"\n                    \"otherwise) you cannot use the check_tracks feature\"\n                )\n            if self.check_tracks_spotify_playlists:\n                logger.warning(\n                    \"check_tracks depends on valid Spotify API credentials in \"\n                    \"SpotifyConfig.\"\n                )\n\n        if self.process_recording:\n            if not self.recording_file.exists():\n                raise RuntimeError(\n                    f'Could not find recording_file \"{self.recording_file}\"'\n                )\n            if not self.recording_playlist:\n                raise RuntimeError(\n                    \"You must provide a playlist name as recording_playlist \"\n                    \"and this name must exists in spotify_playlists.yaml.\"\n                )\n\n    @field_validator(\"audio_bitrate\")\n    @classmethod\n    def bitrate_validation(cls, value: str) -&gt; str:\n        \"\"\"Validates audio_bitrate is in the range and casts it to a string.\n\n        Args:\n            value: audio_bitrate field\n\n        Raises:\n            ValueError: audio_bitrate must be in the range [36, 320]\n\n        Returns:\n            String representing the bit rate.\n        \"\"\"\n        value = int(value)\n        if value &lt; 36 or value &gt; 320:\n            raise ValueError(\"audio_bitrate must be in the range [36, 320]\")\n\n        return str(value)\n\n    @model_validator(mode=\"after\")\n    @classmethod\n    def format_validation(cls, model: \"UtilsConfig\") -&gt; \"UtilsConfig\":\n        \"\"\"Logs a warning message to install FFmpeg if audio_format isn't wav.\n\n        Args:\n            model: The validated model instance.\n\n        Returns:\n            The validated model instance.\n        \"\"\"\n        if model.audio_format != \"wav\" and (\n            model.normalize_audio or model.process_recording\n        ):\n            logger.warning(\n                \"You must install FFmpeg in order to use non-wav file formats.\"\n            )\n\n        return model\n</code></pre>"},{"location":"reference/utils/#djtools.utils.config.UtilsConfig.__init__","title":"<code>__init__(*args, **kwargs)</code>","text":"<p>Constructor.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>aws_profile must be set for check_tracks.</p> Source code in <code>src/djtools/utils/config.py</code> <pre><code>def __init__(self, *args, **kwargs):\n    \"\"\"Constructor.\n\n    Raises:\n        RuntimeError: aws_profile must be set for check_tracks.\n    \"\"\"\n\n    super().__init__(*args, **kwargs)\n    if self.check_tracks:\n        if not os.environ.get(\"AWS_PROFILE\"):\n            raise RuntimeError(\n                \"Without aws_profile set to a valid profile ('default' or \"\n                \"otherwise) you cannot use the check_tracks feature\"\n            )\n        if self.check_tracks_spotify_playlists:\n            logger.warning(\n                \"check_tracks depends on valid Spotify API credentials in \"\n                \"SpotifyConfig.\"\n            )\n\n    if self.process_recording:\n        if not self.recording_file.exists():\n            raise RuntimeError(\n                f'Could not find recording_file \"{self.recording_file}\"'\n            )\n        if not self.recording_playlist:\n            raise RuntimeError(\n                \"You must provide a playlist name as recording_playlist \"\n                \"and this name must exists in spotify_playlists.yaml.\"\n            )\n</code></pre>"},{"location":"reference/utils/#djtools.utils.config.UtilsConfig.bitrate_validation","title":"<code>bitrate_validation(value)</code>  <code>classmethod</code>","text":"<p>Validates audio_bitrate is in the range and casts it to a string.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>audio_bitrate field</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>audio_bitrate must be in the range [36, 320]</p> <p>Returns:</p> Type Description <code>str</code> <p>String representing the bit rate.</p> Source code in <code>src/djtools/utils/config.py</code> <pre><code>@field_validator(\"audio_bitrate\")\n@classmethod\ndef bitrate_validation(cls, value: str) -&gt; str:\n    \"\"\"Validates audio_bitrate is in the range and casts it to a string.\n\n    Args:\n        value: audio_bitrate field\n\n    Raises:\n        ValueError: audio_bitrate must be in the range [36, 320]\n\n    Returns:\n        String representing the bit rate.\n    \"\"\"\n    value = int(value)\n    if value &lt; 36 or value &gt; 320:\n        raise ValueError(\"audio_bitrate must be in the range [36, 320]\")\n\n    return str(value)\n</code></pre>"},{"location":"reference/utils/#djtools.utils.config.UtilsConfig.format_validation","title":"<code>format_validation(model)</code>  <code>classmethod</code>","text":"<p>Logs a warning message to install FFmpeg if audio_format isn't wav.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>UtilsConfig</code> <p>The validated model instance.</p> required <p>Returns:</p> Type Description <code>UtilsConfig</code> <p>The validated model instance.</p> Source code in <code>src/djtools/utils/config.py</code> <pre><code>@model_validator(mode=\"after\")\n@classmethod\ndef format_validation(cls, model: \"UtilsConfig\") -&gt; \"UtilsConfig\":\n    \"\"\"Logs a warning message to install FFmpeg if audio_format isn't wav.\n\n    Args:\n        model: The validated model instance.\n\n    Returns:\n        The validated model instance.\n    \"\"\"\n    if model.audio_format != \"wav\" and (\n        model.normalize_audio or model.process_recording\n    ):\n        logger.warning(\n            \"You must install FFmpeg in order to use non-wav file formats.\"\n        )\n\n    return model\n</code></pre>"},{"location":"reference/utils/#djtools.utils.check_tracks.compare_tracks","title":"<code>compare_tracks(config, beatcloud_tracks=None)</code>","text":"<p>Compares tracks from Spotify / local with Beatcloud tracks.</p> <p>Gets track titles and artists from Spotify playlist(s) and / or file names from local directories, and get file names from the beatcloud. Then compute the Levenshtein similarity between their product in order to identify any overlapping tracks.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>BaseConfig</code> <p>Configuration object.</p> required <code>beatcloud_tracks</code> <code>Optional[List[str]]</code> <p>Cached list of tracks from S3.</p> <code>None</code> <p>Returns:</p> Type Description <code>Tuple[List[str], List[str]]</code> <p>Tuple with a list of all Beatcloud tracks and list of full paths to matching Beatcloud tracks.</p> Source code in <code>src/djtools/utils/check_tracks.py</code> <pre><code>def compare_tracks(\n    config: BaseConfig,\n    beatcloud_tracks: Optional[List[str]] = None,\n) -&gt; Tuple[List[str], List[str]]:\n    \"\"\"Compares tracks from Spotify / local with Beatcloud tracks.\n\n    Gets track titles and artists from Spotify playlist(s) and / or file names\n    from local directories, and get file names from the beatcloud. Then compute\n    the Levenshtein similarity between their product in order to identify any\n    overlapping tracks.\n\n    Args:\n        config: Configuration object.\n        beatcloud_tracks: Cached list of tracks from S3.\n\n    Returns:\n        Tuple with a list of all Beatcloud tracks and list of full paths to\n            matching Beatcloud tracks.\n    \"\"\"\n    if config.sync.download_spotify_playlist:\n        cached_local_dirs = config.utils.local_dirs\n        config.utils.local_dirs = []\n        spotify_playlists = [config.sync.download_spotify_playlist]\n    else:\n        spotify_playlists = config.utils.check_tracks_spotify_playlists\n\n    track_sets = []\n    beatcloud_matches = []\n    if spotify_playlists:\n        spotify_tracks = get_spotify_tracks(config, spotify_playlists)\n        if not spotify_tracks:\n            if config.sync.download_spotify_playlist:\n                substring = \"download_spotify_playlist is a key\"\n            else:\n                substring = (\n                    \"check_tracks_spotify_playlists has one or more keys\"\n                )\n            logger.warning(\n                f\"There are no Spotify tracks; make sure {substring} in \"\n                \"spotify_playlists.yaml\"\n            )\n        else:\n            track_results = defaultdict(list)\n            for playlist_name, playlist_tracks in spotify_tracks.items():\n                for track in playlist_tracks:\n                    title = track[\"track\"][\"name\"]\n                    artists = \", \".join(\n                        [y[\"name\"] for y in track[\"track\"][\"artists\"]]\n                    )\n                    track_results[playlist_name].append(\n                        f\"{artists} - {title}\"\n                        if config.sync.artist_first\n                        else f\"{title} - {artists}\"\n                    )\n            track_sets.append((track_results, \"Spotify Playlist Tracks\"))\n    if config.utils.local_dirs:\n        local_tracks = get_local_tracks(config)\n        if not local_tracks:\n            logger.warning(\n                \"There are no local tracks; make sure local_dirs has one or \"\n                \"more directories containing one or more tracks\"\n            )\n        else:\n            track_results = {\n                key: [track.stem for track in value]\n                for key, value in local_tracks.items()\n            }\n            track_sets.append((track_results, \"Local Directory Tracks\"))\n\n    if config.sync.download_spotify_playlist:\n        config.utils.local_dirs = cached_local_dirs\n\n    if not track_sets:\n        return beatcloud_tracks, beatcloud_matches\n\n    if not beatcloud_tracks:\n        beatcloud_tracks = get_beatcloud_tracks(config.sync.bucket_url)\n\n    path_lookup = {x.stem: x for x in beatcloud_tracks}\n\n    for tracks, track_type in track_sets:\n        if config.sync.artist_first and track_type == \"Local Directory Tracks\":\n            path_lookup = reverse_title_and_artist(path_lookup)\n        matches = find_matches(\n            tracks,\n            path_lookup.keys(),\n            config,\n        )\n        logger.info(f\"\\n{track_type} / Beatcloud Matches: {len(matches)}\")\n        for loc, matches in groupby(\n            sorted(matches, key=itemgetter(0)), key=itemgetter(0)\n        ):\n            logger.info(f\"{loc}:\")\n            for _, track, beatcloud_track, fuzz_ratio in matches:\n                beatcloud_matches.append(path_lookup[beatcloud_track])\n                logger.info(f\"\\t{fuzz_ratio}: {track} | {beatcloud_track}\")\n\n    return beatcloud_tracks, beatcloud_matches\n</code></pre>"},{"location":"reference/utils/#djtools.utils.normalize_audio.normalize","title":"<code>normalize(config)</code>","text":"<p>Gets local tracks and normalizes them.</p> <p>Tracks will be overwritten and have a headroom equal to audio_headroom.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>BaseConfig</code> <p>Configuration object.</p> required <p>Raises:</p> Type Description <code>RuntimeError</code> <p>Must have local tracks to normalize.</p> Source code in <code>src/djtools/utils/normalize_audio.py</code> <pre><code>def normalize(config: BaseConfig):\n    \"\"\"Gets local tracks and normalizes them.\n\n    Tracks will be overwritten and have a headroom equal to audio_headroom.\n\n    Args:\n        config: Configuration object.\n\n    Raises:\n        RuntimeError: Must have local tracks to normalize.\n    \"\"\"\n    folder_tracks = get_local_tracks(config)\n    if not folder_tracks:\n        raise RuntimeError(\n            \"There are no local tracks; make sure local_dirs has one or \"\n            \"more directories containing one or more tracks\"\n        )\n\n    for track in [\n        track\n        for tracks in folder_tracks.values()\n        for track in tracks\n        if track.is_file() and not track.name.startswith(\".\")\n    ]:\n        try:\n            audio = AudioSegment.from_file(track)\n        except Exception as exc:\n            logger.error(f\"Couldn't decode {track}: {exc}\")\n            continue\n\n        if abs(audio.max_dBFS + config.utils.audio_headroom) &gt; 0.001:\n            logger.info(\n                f\"{track} has a max dB of {audio.max_dBFS}, normalizing to \"\n                f\"have a headroom of {config.utils.audio_headroom}...\"\n            )\n            try:\n                tags = utils.mediainfo(track).get(\"TAG\", {})\n            except FileNotFoundError as exc:\n                logger.warning(\n                    f\"Couldn't export {track.stem} with ID3 tags; ensure \"\n                    f'\"ffmpeg\" is installed: {exc}'\n                )\n                tags = {}\n            audio = effects.normalize(\n                audio, headroom=config.utils.audio_headroom\n            )\n            audio.export(\n                track.parent\n                / f\"{track.stem}.{config.utils.audio_format.value}\",\n                tags=tags,\n                bitrate=f\"{config.utils.audio_bitrate}k\",\n                format=config.utils.audio_format.value,\n            )\n            continue\n</code></pre>"},{"location":"reference/utils/#djtools.utils.process_recording.process","title":"<code>process(config)</code>","text":"<p>Process a recording whose contents map to tracks in a Spotify playlist.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>BaseConfig</code> <p>Configuration object.</p> required <p>Raises:</p> Type Description <code>RuntimeError</code> <p>The configured recording_playlist must both exist in spotify_playlists.yaml and have tracks in it.</p> Source code in <code>src/djtools/utils/process_recording.py</code> <pre><code>def process(config: BaseConfig):\n    \"\"\"Process a recording whose contents map to tracks in a Spotify playlist.\n\n    Args:\n        config: Configuration object.\n\n    Raises:\n        RuntimeError: The configured recording_playlist must both exist\n            in spotify_playlists.yaml and have tracks in it.\n    \"\"\"\n    # Get the tracks of the target Spotify playlist.\n    tracks = get_spotify_tracks(config, [config.utils.recording_playlist])\n    if not tracks:\n        raise RuntimeError(\n            \"There are no Spotify tracks; make sure download_spotify_playlist \"\n            \"is a key from spotify_playlists.yaml\"\n        )\n\n    # Parse the relevant data from the track responses.\n    track_data = []\n    playlist_duration = 0\n    for track in tracks[config.utils.recording_playlist]:\n        # Parse release date field based on the date precision\n        date_year = \"\"\n        release_date = track[\"track\"][\"album\"][\"release_date\"]\n        release_precision = track[\"track\"][\"album\"][\"release_date_precision\"]\n        if release_precision == \"year\":\n            date_year = datetime.strptime(release_date, \"%Y\").year\n        elif release_precision == \"month\":\n            date_year = datetime.strptime(release_date, \"%Y-%m\").year\n        elif release_precision == \"day\":\n            date_year = datetime.strptime(release_date, \"%Y-%m-%d\").year\n\n        # TODO(a-rich): Why won't Rekordbox load \"label\" and \"year\" tags?!\n        data = {\n            \"album\": track[\"track\"][\"album\"][\"name\"],\n            \"artist\": \", \".join(\n                [y[\"name\"] for y in track[\"track\"][\"artists\"]]\n            ),\n            # NOTE: There's a 500 ms gap between tracks during playback that\n            # must be accounted for.\n            \"duration\": track[\"track\"][\"duration_ms\"] + 500,\n            \"label\": track[\"track\"][\"album\"].get(\"label\", \"\"),\n            \"title\": track[\"track\"][\"name\"],\n            \"year\": date_year,\n        }\n        track_data.append(data)\n        playlist_duration += data[\"duration\"]\n\n    # Load the audio and trim the initial silence.\n    logger.info(\"Loading audio...\")\n    audio = AudioSegment.from_file(config.utils.recording_file)\n    if config.utils.trim_initial_silence:\n        audio = trim_initial_silence(\n            audio,\n            [track[\"duration\"] for track in track_data],\n            config.utils.trim_initial_silence,\n        )\n\n    # Check that the audio is at least as long as the playlist duration.\n    audio_duration = len(audio)\n    if audio_duration &lt; playlist_duration:\n        logger.warning(\n            f\"{config.utils.recording_file} has a duration of {audio_duration} \"\n            \"milliseconds which is less than the sum of track lengths in the \"\n            f\"Spotify playlist {config.utils.recording_playlist} which is \"\n            f\"{playlist_duration} milliseconds. Please confirm your recording \"\n            \"went as expected!\"\n        )\n\n    # Create destination for exported audio.\n    write_path = config.utils.audio_destination\n    write_path.mkdir(parents=True, exist_ok=True)\n\n    # Split recording into the individual tracks.\n    audio_chunks = []\n    for track in track_data:\n        track_audio = audio[: track[\"duration\"]]\n        audio = audio[track[\"duration\"] :]\n        audio_chunks.append(track_audio)\n\n    # Normalize audio and export tracks with tags.\n    payload = zip(\n        [config] * len(audio_chunks),\n        audio_chunks,\n        track_data,\n        [write_path] * len(audio_chunks),\n    )\n    exported_files = []\n\n    with ThreadPoolExecutor(\n        max_workers=os.cpu_count() * 4  # pylint: disable=no-member\n    ) as executor:\n        exported_files = executor.map(\n            lambda args: process_parallel(*args), payload\n        )\n\n    for index, filepath in enumerate(exported_files):\n        creation_time = datetime.now().timestamp() + index\n        os.utime(filepath, (creation_time, creation_time))\n</code></pre>"},{"location":"reference/utils/#djtools.utils.url_download.fix_up","title":"<code>fix_up(_file)</code>","text":"<p>Removes digits appended to file name by youtube-dl.</p> <p>Parameters:</p> Name Type Description Default <code>_file</code> <code>Path</code> <p>Music file name.</p> required <p>Returns:</p> Type Description <code>Path</code> <p>Cleaned up music file name.</p> Source code in <code>src/djtools/utils/url_download.py</code> <pre><code>@make_path\ndef fix_up(_file: Path) -&gt; Path:\n    \"\"\"Removes digits appended to file name by youtube-dl.\n\n    Args:\n        _file: Music file name.\n\n    Returns:\n        Cleaned up music file name.\n    \"\"\"\n    ext = _file.suffix\n    exp = rf\"(\\-\\d{{1,}}(?={ext}))\"\n    stripped = Path(re.split(exp, _file.as_posix())[0]).stem\n    name = Path(\" - \".join(stripped.split(\" - \")[-1::-1]))\n\n    return name.with_suffix(ext)\n</code></pre>"},{"location":"reference/utils/#djtools.utils.url_download.url_download","title":"<code>url_download(config)</code>","text":"<p>Downloads music files from a provided URL using the youtube-dl package.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>BaseConfig</code> <p>Configuration object.</p> required Source code in <code>src/djtools/utils/url_download.py</code> <pre><code>def url_download(config: BaseConfig):\n    \"\"\"Downloads music files from a provided URL using the youtube-dl package.\n\n    Args:\n        config: Configuration object.\n    \"\"\"\n    dl_loc = config.utils.audio_destination or Path(\".\")\n    dl_loc.mkdir(parents=True, exist_ok=True)\n\n    ydl_opts = {\n        \"postprocessors\": [\n            {\n                \"key\": \"FFmpegExtractAudio\",\n                \"preferredcodec\": config.utils.audio_format.value,\n                \"preferredquality\": config.utils.audio_bitrate,\n            }\n        ],\n        \"outtmpl\": (dl_loc / \"%(title)s.tmp\").as_posix(),\n    }\n\n    with ytdl.YoutubeDL(ydl_opts) as ydl:\n        logger.info(f\"Downloading {config.utils.url_download} to {dl_loc}\")\n        ydl.download([config.utils.url_download])\n\n    for _file in dl_loc.iterdir():\n        (dl_loc / _file).rename(dl_loc / fix_up(_file))\n</code></pre>"},{"location":"reference/utils/#djtools.utils.helpers.compute_distance","title":"<code>compute_distance(spotify_playlist, spotify_track, beatcloud_track, threshold)</code>","text":"<p>Qualifies a match between a Spotify track and a beatcloud track using     Levenshtein similarity.</p> <p>Parameters:</p> Name Type Description Default <code>spotify_playlist</code> <code>str</code> <p>Playlist that Spotify track belongs to.</p> required <code>spotify_track</code> <code>str</code> <p>Spotify track title and artist name.</p> required <code>beatcloud_track</code> <code>str</code> <p>Beatcloud track title and artist name</p> required <code>threshold</code> <code>float</code> <p>Levenshtein similarity threshold for acceptance.</p> required <p>Returns:</p> Type Description <code>Tuple[str, float]</code> <p>Tuple of Spotify playlist, Spotify \"TRACK TITLE - ARTIST NAME\", beatcloud \"TRACK TITLE - ARTIST NAME\", Levenshtein similarity.</p> Source code in <code>src/djtools/utils/helpers.py</code> <pre><code>def compute_distance(\n    spotify_playlist: str,\n    spotify_track: str,\n    beatcloud_track: str,\n    threshold: float,\n) -&gt; Tuple[str, float]:\n    \"\"\"Qualifies a match between a Spotify track and a beatcloud track using\n        Levenshtein similarity.\n\n    Args:\n        spotify_playlist: Playlist that Spotify track belongs to.\n        spotify_track: Spotify track title and artist name.\n        beatcloud_track: Beatcloud track title and artist name\n        threshold: Levenshtein similarity threshold for acceptance.\n\n    Returns:\n        Tuple of Spotify playlist, Spotify \"TRACK TITLE - ARTIST NAME\",\n            beatcloud \"TRACK TITLE - ARTIST NAME\", Levenshtein similarity.\n    \"\"\"\n    ret = ()\n    fuzz_ratio = fuzz.ratio(spotify_track, beatcloud_track)\n    if fuzz_ratio &gt;= threshold:\n        ret = spotify_playlist, spotify_track, beatcloud_track, fuzz_ratio\n    return ret\n</code></pre>"},{"location":"reference/utils/#djtools.utils.helpers.find_matches","title":"<code>find_matches(compare_tracks, beatcloud_tracks, config)</code>","text":"<p>Computes the Levenshtein similarity between beatcloud tracks the given     tracks to compare with and returns those that match above a threshold.</p> <p>Parameters:</p> Name Type Description Default <code>compare_tracks</code> <code>Dict[str, Set[str]]</code> <p>Dictionary with either local directory or Spotify playlist keys and filenames or title and artists values.</p> required <code>beatcloud_tracks</code> <code>List[str]</code> <p>Beatcloud track titles and artist names.</p> required <code>config</code> <code>BaseConfig</code> <p>Configuration object.</p> required <p>Returns:</p> Type Description <code>List[Tuple[str, float]]</code> <p>List of tuples of track location (directory or playlist), track name, Beatcloud track, and Levenshtein distance.</p> Source code in <code>src/djtools/utils/helpers.py</code> <pre><code>def find_matches(\n    compare_tracks: Dict[str, Set[str]],\n    beatcloud_tracks: List[str],\n    config: BaseConfig,\n) -&gt; List[Tuple[str, float]]:\n    \"\"\"Computes the Levenshtein similarity between beatcloud tracks the given\n        tracks to compare with and returns those that match above a threshold.\n\n    Args:\n        compare_tracks: Dictionary with either local directory or Spotify\n            playlist keys and filenames or title and artists values.\n        beatcloud_tracks: Beatcloud track titles and artist names.\n        config: Configuration object.\n\n    Returns:\n        List of tuples of track location (directory or playlist), track name,\n            Beatcloud track, and Levenshtein distance.\n    \"\"\"\n    playlist_tracks = [\n        (playlist, track)\n        for playlist, tracks in compare_tracks.items()\n        for track in tracks\n    ]\n    _product = list(product(playlist_tracks, beatcloud_tracks))\n    _temp, beatcloud_tracks = zip(*_product)\n    locations, tracks = zip(*_temp)\n    payload = zip(\n        locations,\n        tracks,\n        beatcloud_tracks,\n        [config.utils.check_tracks_fuzz_ratio] * len(_product),\n    )\n\n    with ThreadPoolExecutor(\n        max_workers=os.cpu_count() * 4  # pylint: disable=no-member\n    ) as executor:\n        futures = [\n            executor.submit(compute_distance, *args) for args in payload\n        ]\n\n        with tqdm(\n            total=len(futures), desc=\"Matching new tracks and Beatcloud tracks\"\n        ) as pbar:\n            matches = []\n            for future in as_completed(futures):\n                result = future.result()\n                if result:\n                    matches.append(result)\n                pbar.update(1)\n\n    return matches\n</code></pre>"},{"location":"reference/utils/#djtools.utils.helpers.get_beatcloud_tracks","title":"<code>get_beatcloud_tracks(bucket_url)</code>","text":"<p>Lists all the music files in S3 and parses out the track titles and     artist names.</p> <p>Parameters:</p> Name Type Description Default <code>bucket_url</code> <p>URL to an AWS S3 API compliant bucket.</p> required <p>Returns:</p> Type Description <code>List[str]</code> <p>Beatcloud track titles and artist names.</p> Source code in <code>src/djtools/utils/helpers.py</code> <pre><code>def get_beatcloud_tracks(bucket_url) -&gt; List[str]:\n    \"\"\"Lists all the music files in S3 and parses out the track titles and\n        artist names.\n\n    Args:\n        bucket_url: URL to an AWS S3 API compliant bucket.\n\n    Returns:\n        Beatcloud track titles and artist names.\n    \"\"\"\n    cmd = [\"aws\", \"s3\", \"ls\", \"--recursive\", f\"{bucket_url}/dj/music/\"]\n    output = check_output(cmd).decode(\"utf-8\").split(\"\\n\")\n    tracks = [Path(track) for track in output if track]\n    logger.info(f\"Got {len(tracks)} tracks from the beatcloud\")\n\n    return tracks\n</code></pre>"},{"location":"reference/utils/#djtools.utils.helpers.get_local_tracks","title":"<code>get_local_tracks(config)</code>","text":"<p>Aggregates the files from one or more local directories in a dictionary     mapped with parent directories.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>BaseConfig</code> <p>Configuration object.</p> required <p>Returns:</p> Type Description <code>Dict[str, List[str]]</code> <p>Local file names keyed by parent directory.</p> Source code in <code>src/djtools/utils/helpers.py</code> <pre><code>def get_local_tracks(config: BaseConfig) -&gt; Dict[str, List[str]]:\n    \"\"\"Aggregates the files from one or more local directories in a dictionary\n        mapped with parent directories.\n\n    Args:\n        config: Configuration object.\n\n    Returns:\n        Local file names keyed by parent directory.\n    \"\"\"\n    local_dir_tracks = {}\n    for _dir in config.utils.local_dirs:\n        if not _dir.exists():\n            logger.warning(\n                f\"{_dir} does not exist; will not be able to check its \"\n                \"contents against the beatcloud\"\n            )\n            continue\n        files = list(_dir.rglob(\"**/*.*\"))\n        if files:\n            local_dir_tracks[_dir] = files\n    local_tracks_count = sum(len(x) for x in local_dir_tracks.values())\n    logger.info(f\"Got {local_tracks_count} files under local directories\")\n\n    return local_dir_tracks\n</code></pre>"},{"location":"reference/utils/#djtools.utils.helpers.get_playlist_tracks","title":"<code>get_playlist_tracks(spotify, playlist_id)</code>","text":"<p>Queries Spotify API for a playlist and pulls tracks from it.</p> <p>Parameters:</p> Name Type Description Default <code>spotify</code> <code>Spotify</code> <p>Spotify client.</p> required <code>playlist_id</code> <code>str</code> <p>Playlist ID of Spotify playlist to pull tracks from.</p> required <p>Raises:</p> Type Description <code>RuntimeError</code> <p>Playlist_id must correspond with a valid Spotify playlist.</p> <p>Returns:</p> Type Description <code>List[Dict]</code> <p>List of Spotify track results.</p> Source code in <code>src/djtools/utils/helpers.py</code> <pre><code>def get_playlist_tracks(\n    spotify: spotipy.Spotify, playlist_id: str\n) -&gt; List[Dict]:\n    \"\"\"Queries Spotify API for a playlist and pulls tracks from it.\n\n    Args:\n        spotify: Spotify client.\n        playlist_id: Playlist ID of Spotify playlist to pull tracks from.\n\n    Raises:\n        RuntimeError: Playlist_id must correspond with a valid Spotify playlist.\n\n    Returns:\n        List of Spotify track results.\n    \"\"\"\n    try:\n        playlist = spotify.playlist(playlist_id)\n    except Exception:\n        raise RuntimeError(\n            f\"Failed to get playlist with ID {playlist_id}\"\n        ) from Exception\n\n    result = playlist[\"tracks\"]\n    tracks = list(result[\"items\"])\n    while result[\"next\"]:\n        result = spotify.next(result)\n        tracks.extend(list(result[\"items\"]))\n\n    return tracks\n</code></pre>"},{"location":"reference/utils/#djtools.utils.helpers.get_spotify_tracks","title":"<code>get_spotify_tracks(config, playlists)</code>","text":"<p>Aggregates the tracks from one or more Spotify playlists into a     dictionary mapped with playlist names.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>BaseConfig</code> <p>Configuration object.</p> required <code>playlists</code> <code>List[str]</code> <p>List of Spotify playlist name.</p> required <p>Returns:</p> Type Description <code>Dict[str, List[Dict]]</code> <p>Spotify tracks keyed by playlist name.</p> Source code in <code>src/djtools/utils/helpers.py</code> <pre><code>def get_spotify_tracks(\n    config: BaseConfig, playlists: List[str]\n) -&gt; Dict[str, List[Dict]]:\n    \"\"\"Aggregates the tracks from one or more Spotify playlists into a\n        dictionary mapped with playlist names.\n\n    Args:\n        config: Configuration object.\n        playlists: List of Spotify playlist name.\n\n    Returns:\n        Spotify tracks keyed by playlist name.\n    \"\"\"\n    spotify = get_spotify_client(config)\n    playlist_ids = get_playlist_ids()\n\n    playlist_tracks = {}\n    _sum = 0\n    for playlist in playlists:\n        playlist_id = playlist_ids.get(playlist)\n        if not playlist_id:\n            logger.error(f\"{playlist} not in spotify_playlists.yaml\")\n            continue\n        playlist_tracks[playlist] = get_playlist_tracks(spotify, playlist_id)\n        length = len(playlist_tracks[playlist])\n        logger.info(\n            f'Got {length} track{\"\" if length == 1 else \"s\"} from Spotify '\n            f'playlist \"{playlist}\"'\n        )\n        _sum += length\n\n        if config.verbosity &gt; 0:\n            for track in playlist_tracks[playlist]:\n                logger.info(f\"\\t{track}\")\n    logger.info(\n        f'Got {_sum} track{\"\" if _sum == 1 else \"s\"} from Spotify in total'\n    )\n\n    return playlist_tracks\n</code></pre>"},{"location":"reference/utils/#djtools.utils.helpers.initialize_logger","title":"<code>initialize_logger()</code>","text":"<p>Initializes logger from configuration.</p> <p>Returns:</p> Type Description <code>Tuple[Logger, str]</code> <p>Tuple containing Logger and associated log file.</p> Source code in <code>src/djtools/utils/helpers.py</code> <pre><code>def initialize_logger() -&gt; Tuple[logging.Logger, str]:\n    \"\"\"Initializes logger from configuration.\n\n    Returns:\n        Tuple containing Logger and associated log file.\n    \"\"\"\n    log_file = (\n        Path(__file__).parent.parent\n        / \"logs\"\n        / f'{datetime.now().strftime(\"%Y-%m-%d\")}.log'\n    )\n    logging_config = {\n        \"version\": 1,\n        \"disable_existing_loggers\": False,\n        \"formatters\": {\n            \"baseFormatter\": {\n                \"format\": \"%(asctime)s - %(name)s:%(lineno)s - %(levelname)s - %(message)s\",\n                \"datefmt\": \"%Y-%m-%d %H:%M:%S\",\n            },\n        },\n        \"handlers\": {\n            \"fileHandler\": {\n                \"class\": \"logging.FileHandler\",\n                \"level\": \"DEBUG\",\n                \"formatter\": \"baseFormatter\",\n                \"filename\": log_file.as_posix(),\n            },\n            \"streamHandler\": {\n                \"class\": \"logging.StreamHandler\",\n                \"level\": \"DEBUG\",\n                \"formatter\": \"baseFormatter\",\n                \"stream\": \"ext://sys.stdout\",\n            },\n        },\n        \"loggers\": {\n            \"\": {  # root logger\n                \"handlers\": [\"fileHandler\", \"streamHandler\"],\n                \"level\": \"DEBUG\",\n                \"propagate\": False,\n            },\n        },\n    }\n    logging.config.dictConfig(logging_config)\n\n    return logging.getLogger(__name__), log_file\n</code></pre>"},{"location":"reference/utils/#djtools.utils.helpers.make_path","title":"<code>make_path(func)</code>","text":"<p>Decorator for converting Path-typed args to Paths.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable</code> <p>Callable being decorated with this function.</p> required <p>Raises:</p> Type Description <code>RuntimeError</code> <p>args annotated with a pathlib.Path need to be able to have Paths created from them.</p> <code>RuntimeError</code> <p>kwargs annotated with a pathlib.Path need to be able to have Paths created from them.</p> <p>Returns:</p> Type Description <code>Callable</code> <p>The Callable being wrapped by this decorator.</p> Source code in <code>src/djtools/utils/helpers.py</code> <pre><code>def make_path(func: Callable) -&gt; Callable:\n    \"\"\"Decorator for converting Path-typed args to Paths.\n\n    Args:\n        func: Callable being decorated with this function.\n\n    Raises:\n        RuntimeError: args annotated with a pathlib.Path need to be able to\n            have Paths created from them.\n        RuntimeError: kwargs annotated with a pathlib.Path need to be able to\n            have Paths created from them.\n\n    Returns:\n        The Callable being wrapped by this decorator.\n    \"\"\"\n\n    @wraps(make_path)\n    def str_to_path(*args, **kwargs):\n        \"\"\"Converts non-Path type args into Paths if annotated as Paths.\n\n        Raises:\n            RuntimeError: args annotated with a pathlib.Path need to be able to\n                have Paths created from them.\n            RuntimeError: kwargs annotated with a pathlib.Path need to be able\n                to have Paths created from them.\n        \"\"\"\n        # Get the function's type annotations and partition them by args and\n        # kwargs.\n        path_types = (pathlib.Path, typing.Union[pathlib.Path, None])\n        num_args = 0\n        num_kwargs = 0\n        type_hints = list(typing.get_type_hints(func).values())\n        sig = inspect.signature(func)\n        for parameter in sig.parameters.values():\n            if parameter.name == \"self\":\n                type_hints.insert(0, \"self\")\n            if parameter.name in kwargs:\n                num_kwargs += 1\n            else:\n                num_args += 1\n        arg_type_hints = type_hints[:num_args]\n        kwarg_type_hints = type_hints[:num_kwargs]\n\n        # Convert each arg to a Path if the annotation type is pathlib.Path.\n        args = list(args)\n        for index, (arg, arg_type) in enumerate(zip(args, arg_type_hints)):\n            # Skip if the arg shouldn't be a path or it should be a Path but\n            # already is.\n            if arg_type not in path_types or (\n                arg_type in path_types and isinstance(arg, Path)\n            ):\n                continue\n\n            try:\n                args[index] = Path(arg)\n            except Exception as exc:\n                raise RuntimeError(\n                    \"Error creating Path in function \"\n                    f'\"{func.__name__}\" from positional arg \"{arg}\" annotated '\n                    f'with type \"{arg_type}\": {exc}'\n                ) from Exception\n        args = tuple(args)\n\n        # Convert each kwarg to a Path if the annotation type is pathlib.Path.\n        for (key, value), arg_type in zip(kwargs.items(), kwarg_type_hints):\n            # Skip if the arg value shouldn't be a path or it should be a Path\n            # but already is.\n            if arg_type not in path_types or (\n                arg_type in path_types and isinstance(value, Path)\n            ):\n                continue\n\n            try:\n                kwargs[key] = Path(value)\n            except Exception as exc:\n                raise RuntimeError(\n                    \"Error creating Path in function \"\n                    f'\"{func.__name__}\" from keyword arg \"{key}={value}\" '\n                    f'annotated with type \"{arg_type}\": {exc}'\n                ) from Exception\n\n        return func(*args, **kwargs)\n\n    return str_to_path\n</code></pre>"},{"location":"reference/utils/#djtools.utils.helpers.process_parallel","title":"<code>process_parallel(config, audio, track, write_path)</code>","text":"<p>Normalize and export track with tags.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>BaseConfig</code> <p>Configuration object.</p> required <code>audio</code> <code>AudioSegment</code> <p>Audio for a track.</p> required <code>track</code> <code>Dict</code> <p>Metadata for track audio.</p> required <code>write_path</code> <code>Path</code> <p>Destination for exported audio.</p> required <p>Returns:</p> Type Description <code>Path</code> <p>Path that the file was written to.</p> Source code in <code>src/djtools/utils/helpers.py</code> <pre><code>def process_parallel(\n    config: BaseConfig, audio: AudioSegment, track: Dict, write_path: Path\n) -&gt; Path:\n    \"\"\"Normalize and export track with tags.\n\n    Args:\n        config: Configuration object.\n        audio: Audio for a track.\n        track: Metadata for track audio.\n        write_path: Destination for exported audio.\n\n    Returns:\n        Path that the file was written to.\n    \"\"\"\n    # Normalize the audio such that the headroom is\n    # audio_headroom dB.\n    if abs(audio.max_dBFS + config.utils.audio_headroom) &gt; 0.001:\n        audio = effects.normalize(audio, headroom=config.utils.audio_headroom)\n\n    # Build the filename using the title, artist(s) and configured format.\n    filename = (\n        f'{track[\"artist\"]} - {track[\"title\"]}'\n        if config.sync.artist_first\n        else f'{track[\"title\"]} - {track[\"artist\"]}'\n    )\n    filename = write_path / f\"{filename}.{config.utils.audio_format.value}\"\n\n    # Warn users about malformed filenames that could break other features\n    # of djtools.\n    if str(filename).count(\" - \") &gt; 1:\n        logger.warning(\n            f'{filename} has more than one occurrence of \" - \"! '\n            \"Because djtools splits on this sequence of characters to \"\n            \"separate track title and artist(s), you might get unexpected \"\n            'behavior while using features like \"--check-tracks\".'\n        )\n\n    # Export the audio with the configured format and bit rate with the tag\n    # data collected from the Spotify response.\n    audio.export(\n        filename,\n        format=config.utils.audio_format.value,\n        bitrate=f\"{config.utils.audio_bitrate}k\",\n        tags={key: value for key, value in track.items() if key != \"duration\"},\n    )\n\n    return filename\n</code></pre>"},{"location":"reference/utils/#djtools.utils.helpers.reverse_title_and_artist","title":"<code>reverse_title_and_artist(path_lookup)</code>","text":"<p>Reverses the title and artist parts of the filename.</p> <p>Parameters:</p> Name Type Description Default <code>path_lookup</code> <code>Dict[str, str]</code> <p>Mapping of filenames to file paths.</p> required <p>Returns:</p> Type Description <code>Dict[str, str]</code> <p>Mapping with the title and artist in the filenames reversed.</p> Source code in <code>src/djtools/utils/helpers.py</code> <pre><code>def reverse_title_and_artist(path_lookup: Dict[str, str]) -&gt; Dict[str, str]:\n    \"\"\"Reverses the title and artist parts of the filename.\n\n    Args:\n        path_lookup: Mapping of filenames to file paths.\n\n    Returns:\n        Mapping with the title and artist in the filenames reversed.\n    \"\"\"\n    new_path_lookup = {}\n    for key, value in path_lookup.items():\n        split = key.split(\" - \")\n        title = \" - \".join(split[:-1])\n        artist = split[-1]\n        new_path_lookup[f\"{artist} - {title}\"] = value\n\n    return new_path_lookup\n</code></pre>"},{"location":"reference/utils/#djtools.utils.helpers.trim_initial_silence","title":"<code>trim_initial_silence(audio, track_durations, trim_amount, silence_thresh=-50, min_silence_ms=5, step_size=100)</code>","text":"<p>Heuristic for determining the amount of leading silence to trim.</p> <p>Parameters:</p> Name Type Description Default <code>audio</code> <code>AudioSegment</code> <p>Audio with leading silence.</p> required <code>track_durations</code> <code>List[int]</code> <p>List of track durations.</p> required <code>trim_amount</code> <code>Union[int, TrimInitialSilenceMode]</code> <p>Number of milliseconds to trim off the beginning.</p> required <code>silence_thresh</code> <code>Optional[float]</code> <p>Maximum decibel level that's still considered silence.</p> <code>-50</code> <code>min_silence_ms</code> <code>Optional[int]</code> <p>Surrounding milliseconds of each track to check for silence.</p> <code>5</code> <code>step_size</code> <code>Optional[int]</code> <p>Initial step size when checking for leading silences.</p> <code>100</code> <p>Returns:</p> Name Type Description <code>AudioSegment</code> <code>AudioSegment</code> <p>Audio with the beginning silence trimmed off.</p> Source code in <code>src/djtools/utils/helpers.py</code> <pre><code>def trim_initial_silence(\n    audio: AudioSegment,\n    track_durations: List[int],\n    trim_amount: Union[int, TrimInitialSilenceMode],\n    silence_thresh: Optional[float] = -50,\n    min_silence_ms: Optional[int] = 5,\n    step_size: Optional[int] = 100,\n) -&gt; AudioSegment:\n    \"\"\"Heuristic for determining the amount of leading silence to trim.\n\n    Args:\n        audio: Audio with leading silence.\n        track_durations: List of track durations.\n        trim_amount: Number of milliseconds to trim off the beginning.\n        silence_thresh: Maximum decibel level that's still considered silence.\n        min_silence_ms: Surrounding milliseconds of each track to check for\n            silence.\n        step_size: Initial step size when checking for leading silences.\n\n    Returns:\n        AudioSegment: Audio with the beginning silence trimmed off.\n    \"\"\"\n    # If trim_amount is an integer, then it's the number of milliseconds to\n    # trim off the beginning of the recording. If a negative integer is\n    # provided, then insert that many milliseconds of silence at the beginning\n    # of the recording.\n    if isinstance(trim_amount, int):\n        if trim_amount &gt;= 0:\n            return audio[trim_amount:]\n        return AudioSegment.silent(duration=abs(trim_amount)) + audio\n\n    # Get the number of milliseconds of silence at the beginning of the\n    # recording.\n    leading_silence = silence.detect_leading_silence(\n        audio, silence_threshold=silence_thresh, chunk_size=1\n    )\n\n    # If trim_amount is \"auto\", simply trim off the detected leading silence.\n    if trim_amount == TrimInitialSilenceMode.AUTO:\n        return audio[leading_silence:]\n\n    # Use the track durations to infer the points in the recording where each\n    # track should begin.\n    start_points = []\n    index = 0\n    for track_duration in track_durations:\n        index += track_duration\n        start_points.append(index)\n\n    # With a logarithmically decreasing step size, step through the potential\n    # offsets to trim off the beginning of the recording.\n    step_size = max(step_size, 1)\n    offsets = [0, leading_silence]\n    while step_size &gt;= 1:\n        scores = []\n        for offset in range(*offsets, step_size):\n            score = 0\n            # For each track in the recording, build up a score based on the\n            # number of surrounding milliseconds of silence.\n            for point in start_points:\n                for millisecond in range(1, min_silence_ms + 1):\n                    if (\n                        audio[offset + point + millisecond].dBFS\n                        &lt;= silence_thresh\n                    ):\n                        score += 1\n                    if (\n                        audio[offset + point - millisecond].dBFS\n                        &lt;= silence_thresh\n                    ):\n                        score += 1\n            scores.append((score, offset))\n\n        # Sort scores in decreasing order.\n        scores = sorted(scores, key=itemgetter(0), reverse=True)\n        # Get the offsets for the highest two scores.\n        _, offsets = zip(*sorted(scores[:2], key=itemgetter(1)))\n        step_size //= 2\n\n    # Trim off the start of the recording using the best offset.\n    best_offset = max(scores, key=itemgetter(0))[1]\n    audio = audio[best_offset:]\n\n    return audio\n</code></pre>"},{"location":"tutorials/getting_started/","title":"Getting Started","text":"<ul> <li>Overview</li> <li>Setup</li> <li>Usage </li> <li>Configuration</li> </ul>"},{"location":"tutorials/getting_started/configuration/","title":"Configuration","text":"<p>When the <code>djtools</code> command is run, <code>build_config</code> looks for a <code>config.yaml</code> in the package's <code>config</code> directory and creates a <code>BaseConfig</code> object using its values.  If <code>djtools</code> was run with any CLI options, those values override whatever was set in the <code>BaseConfig</code> using the values in <code>config.yaml</code>.</p> <p>If <code>config.yaml</code> doesn't exist, it will be generated when running <code>djtools</code>. If <code>config.yaml</code>, or any of the values it might contain, is missing then the default values in the Python object are used instead. If <code>config.yaml</code> contains any unsupported options, <code>djtools</code> will fail as extra keys are forbidden.</p>"},{"location":"tutorials/getting_started/configuration/#base-config","title":"Base config","text":"<ul> <li><code>artist_first</code>: used to indicate that your Beatcloud tracks adhere to the <code>Artist1, Artist2 - Title (Artist2 Remix)</code> format rather than the <code>Title (Artist2 Remix) - Artist1, Artist2</code> format expected by default </li> <li><code>log_level</code>: logger log level</li> <li><code>verbosity</code>: verbosity level for logging messages</li> </ul>"},{"location":"tutorials/getting_started/configuration/#collection-config","title":"Collection config","text":"<ul> <li><code>collection_path</code>: the full path to your collection...the parent directory where this points to is also where all other collections generated or utilized by this library will exist</li> <li><code>collection_playlists</code>: boolean flag to trigger the generation of a playlist structure (as informed by <code>collection_playlists.yaml</code>) using the tags in <code>collection_path</code>...the resulting collection is the file at <code>collection_path</code></li> <li><code>collection_playlists_remainder</code>: whether tracks of remainder tags (those not specified in <code>collection_playlists.yaml</code>) will be placed in a <code>folder</code> called \"Unused Tags\" with individual tag playlists or a <code>playlist</code> called \"Unused Tags\"</li> <li><code>collection_playlist_filters</code>: list of <code>PlaylistFilter</code> classes used to apply special filtering logic to tag playlists</li> <li><code>copy_playlists</code>: list of playlists in <code>collection_path</code> to (a) have audio files copied and (b) have track data written to a new collection with updated locations</li> <li><code>copy_playlists_destination</code>: path to copy audio files to</li> <li><code>platform</code>: DJ platform used (e.g. <code>rekordbox</code>)</li> <li><code>shuffle_playlists</code>: list of playlists that will have their tracks shuffled</li> </ul>"},{"location":"tutorials/getting_started/configuration/#spotify-config","title":"Spotify config","text":"<ul> <li><code>reddit_client_id</code>: client ID for registered Reddit API application</li> <li><code>reddit_client_secret</code>: client secret for registered Reddit API application</li> <li><code>reddit_user_agent</code>: user-agent for registered Reddit API application</li> <li><code>spotify_client_id</code>: client ID for registered Spotify API application</li> <li><code>spotify_client_secret</code>: client secret for registered Spotify API application</li> <li><code>spotify_playlists</code>: boolean flag to trigger the automatic generation or updating of Spotify playlists from subreddits</li> <li><code>spotify_playlist_default_limit</code>: default number of tracks for a Spotify playlist</li> <li><code>spotify_playlist_default_period</code>: default subreddit period for a Spotify playlist</li> <li><code>spotify_playlist_default_type</code>: default subreddit filter type for a Spotify playlist</li> <li><code>spotify_playlist_from_upload</code>: boolean flag to trigger automatic generation of updating of a Spotify playlist from the Discord webhook output of a user's music upload (output must be copied to the system clipboard)</li> <li><code>spotify_playlist_fuzz_ratio</code>: the minimum Levenshtein similarity between a Spotify API track search result and a subreddit post title (if post is not directly a Spotify URL) to trigger the addition of that track to the corresponding Spotify auto-playlist</li> <li><code>spotify_playlist_post_limit</code>: the maximum number of posts to retrieve from a subreddit</li> <li><code>spotify_playlist_subreddits</code>: list of <code>SubredditConfig</code> objects from which tracks should be added to Spotify auto-playlist; each element is a dictionary with keys for a subreddit's \"name\", \"type\", \"period\", and \"limit\"</li> <li><code>spotify_redirect_uri</code>: redirect URI for registered Spotify API application</li> <li><code>spotify_username</code>: Spotify username that will keep playlists automatically generated</li> </ul>"},{"location":"tutorials/getting_started/configuration/#sync-config","title":"Sync config","text":"<ul> <li><code>aws_profile</code>: the name of the profile used when running <code>aws configure --profile</code></li> <li><code>aws_use_date_modified</code>: up/download files that already exist at the destination if the date modified field at the source is after that of the destination...BE SURE THAT ALL USERS OF YOUR <code>BEATCLOUD</code> INSTANCE ARE ON BOARD BEFORE UPLOADING WITH THIS FLAG SET!</li> <li><code>bucket_url</code>: URL for an AWS S3 API compliant storage location</li> <li><code>discord_url</code>: webhook URL for messaging a Discord server's channel when new music has been uploaded to the <code>beatcloud</code></li> <li><code>download_collection</code>: sync the collection of <code>import_user</code> from the <code>beatcloud</code> to the directory that <code>collection_path</code> is in</li> <li><code>download_exclude_dirs</code>: the list of paths (relative to the <code>DJ Music</code> folder on your <code>usb_path</code>) that should NOT be downloaded from the <code>beatcloud</code> when running the <code>download_music</code> sync operation</li> <li><code>download_include_dirs</code>: the list of paths (relative to the <code>DJ Music</code> folder on your <code>usb_path</code>) that should exclusively be downloaded from the <code>beatcloud</code> when running the <code>download_music</code> sync operation</li> <li><code>download_music</code>: sync beatcloud to \"DJ Music\" folder</li> <li><code>download_spotify_playlist</code>: if this is set to the name of a playlist (present in <code>spotify_playlists.yaml</code>), then only the Beatcloud tracks present in this playlist will be downloaded</li> <li><code>dryrun</code>: show <code>aws s3 sync</code> command output without running</li> <li><code>import_user</code>: the username of a fellow <code>beatcloud</code> user whose collection you want to download</li> <li><code>upload_collection</code>: sync <code>collection_path</code> to the beatcloud</li> <li><code>upload_exclude_dirs</code>: the list of paths (relative to the <code>DJ Music</code> folder on your <code>usb_path</code>) that should NOT be uploaded to the <code>beatcloud</code> when running the <code>upload_music</code> sync operation</li> <li><code>upload_include_dirs</code>: the list of paths (relative to the <code>DJ Music</code> folder on your <code>usb_path</code>) that should exclusively be uploaded to the <code>beatcloud</code> when running the <code>upload_music</code> sync operation</li> <li><code>upload_music</code>: sync \"DJ Music\" folder to the beatcloud</li> <li><code>usb_path</code>: the full path to the USB drive which contains all your music files</li> <li><code>user</code>: this is the username of the current user...if left as an empty string, then your operating system username will be used...it's recommended that you only override this if your username changes from what other users of your <code>beatcloud</code> instance are expecting (to ensure consistency...i.e. when you get a new computer with a different username)</li> </ul>"},{"location":"tutorials/getting_started/configuration/#utils-config","title":"Utils config","text":"<ul> <li><code>audio_bitrate</code>: string representing the integer in the range [<code>36</code>, <code>320</code>] for the bitrate to write audio at e.g. <code>\"320\"</code></li> <li><code>audio_destination</code>: path to where downloaded and / or exported files go to</li> <li><code>audio_format</code>: string representing the file format write audio in e.g. <code>\"mp3\"</code></li> <li><code>audio_headroom</code>: non-negative float representing the amount of headroom in decibels to leave when normalizing audio</li> <li><code>check_tracks</code>: boolean flag to trigger checking the contents of the <code>beatcloud</code> (to identify redundancies)</li> <li><code>check_tracks_fuzz_ratio</code>: the minimum Levenshtein similarity for indicating potential redundancies between Spotify playlists / local directories and the <code>beatcloud</code></li> <li><code>check_tracks_spotify_playlists</code>: list of Spotify playlists to use with <code>check_tracks</code> (must exist in <code>spotify_playlists.yaml</code>)</li> <li><code>local_dirs</code>: list of local directories to use with <code>check_tracks</code></li> <li><code>normalize_audio</code>: boolean flag to trigger normalizing audio files at <code>local_dirs</code>,</li> <li><code>process_recording</code>: boolean flag to trigger processing an audio recording using a Spotify playlist</li> <li><code>recording_file</code>: Audio recording to pair with <code>recording_playlist</code></li> <li><code>recording_playlist</code>: Spotify playlist to pair with <code>recording_file</code></li> <li><code>trim_initial_silence</code>: Milliseconds of initial silence to trim off <code>recording_file</code>. Can also be a negative integer to prepend silence. Can also be \"auto\" or \"smart\" for automatic silence detection or a home-brewed algorithm for finding the optimal offset.</li> <li><code>url_download</code>: URL from which music files should be downloaded (i.e. a Soundcloud playlist)</li> </ul>"},{"location":"tutorials/getting_started/overview/","title":"Overview","text":"<p>DJ Tools is a Python library with many features for streamlining the processes around collecting, curating, and sharing a music collection. Users of the library may have different needs and, therefore, only require some of the features provided. Let's briefly go over what DJ Tools offers so you can determine what's relevant to you.</p> <p>If you want to learn more about how to use DJ Tools to achieve any of the following, please visit the How-to Guides.</p>"},{"location":"tutorials/getting_started/overview/#collection","title":"Collection","text":"<p>This package reads and writes a collection of tracks and playlists. Operations can be performed on this collection such as shuffling and creating backups of playlists and the files that they're comprised of.</p> <p>Perhaps the most useful feature in the <code>collection</code> package is the playlist builder. The playlist builder automatically builds playlists using the metadata associated with tracks in your collection and a <code>collection_playlists.yaml</code> configuration file.</p> <p>The <code>tags</code> key in your <code>collection_playlists.yaml</code> specifies a desired playlist structure using singular tags (genre tags and \"other\" tags). The <code>combiner</code> key specifies playlists using powerful boolean algebra expressions that apply operations on a variety of operands including, but not limited to: tags, playlists, BPM, rating, release year, date added, comments, artists, labels, etc.</p> <p>For more information on the playlist builder, see the How-to Guides for tag and combiner playlists.</p>"},{"location":"tutorials/getting_started/overview/#spotify","title":"Spotify","text":"<p>This package uses the Spotify and Reddit APIs to automatically generate playlists from Reddit submissions and the uploads of other users of your Beatcloud instance.</p> <p>By configuring particular subreddits, you can ensure that you're getting a steady stream of focused music discovery that caters to your interests.</p> <p>Being able to generate Spotify playlists from other users' uploads gives you an opportunity to preview tracks before you decide whether or not you want to sync them (and it goes hand-in-hand with a sister feature of the <code>sync</code> package that makes it easy to sync tracks from this playlist).</p>"},{"location":"tutorials/getting_started/overview/#sync","title":"Sync","text":"<p>This package is essentially a wrapper around an AWS S3 API compliant object storage solution. Throughout the code and documentation, this cloud storage instance is referred to as the \"Beatcloud\".</p> <p>The core of the <code>sync</code> package is the music uploading and downloading features that the progenitor version of DJ Tools was constructed for. This lets you backup your collection for safe keeping and, furthermore, allows you to share your collection amongst your DJ friends. It also can be used to upload your DJ platform's database as well as download databases that other users have uploaded.</p> <p>If you're downloading another user's database, this package will doctor it so the track locations point to where they exist for you (assuming you're all syncing with the same Beatcloud instance). This allows you to import tracks from another user's collection inheriting all their tags, hot cues, etc.</p> <p>As mentioned under the Spotify section above, the <code>sync</code> package offers a sister feature for syncing just the tracks that appear in a playlist generated from another user's upload. This allows you to (a) preview and filter the tracks another user uploads in Spotify and (b) automatically format the <code>download_exclude_dirs</code> configuration option on-the-fly based on the remaining tracks of the playlist.</p>"},{"location":"tutorials/getting_started/overview/#utils","title":"Utils","text":"<p>The <code>utils</code> package has the following miscellaneous features:</p> <ul> <li><code>check_tracks</code> which will compare the filenames of tracks in the Beatcloud with both / either tracks in <code>check_tracks_spotify_playlists</code> and / or filenames globbed from <code>local_dirs</code>. This is very useful for predetermining if you're about to sync duplicate tracks to the Beatcloud.</li> <li><code>normalize_audio</code> which will transform the files globbed from <code>local_dirs</code> such that their peak amplitude leaves <code>audio_headroom</code> and exports them in <code>audio_format</code> at <code>audio_bitrate</code>. This is very useful for ensuring all the tracks you add to the Beatcloud are standardized; say <code>320k</code> <code>mp3</code> files with a peak amplitude of <code>0.0</code> decibels.</li> <li><code>process_recording</code>: given a recording file and Spotify playlist, chunk the recording into individual tracks, name the files, and export with tags using data from the Spotify API. Tracks are normalized with <code>audio_headroom</code> and exported in <code>audio_format</code> at <code>audio_bitrate</code>.</li> <li><code>url_download</code> which is a simple wrapper around the youtube-dl package for extracting audio files from URLs.</li> </ul>"},{"location":"tutorials/getting_started/setup/","title":"Setup","text":""},{"location":"tutorials/getting_started/setup/#python","title":"Python","text":"<p>The DJ Tools library requires a minimum version of Python 3.9. As always, when working with a Python project, you're going to want to create a virtual environment; Pyenv is really nice but if you insist on doing a system-wide Python installation then proceed with the following instructions:</p> <ul> <li>Mac installation: <code>brew install python@3.9</code></li> <li>Linux installation: <code>sudo apt install python3.9</code></li> <li>Windows installation: Windows releases</li> </ul>"},{"location":"tutorials/getting_started/setup/#dj-tools","title":"DJ Tools","text":"<ol> <li>Run <code>pip install \"djtools[accelerated]\"</code> to install the DJ Tools library<ul> <li>To install DJ Tools without the accelerated computation for Levenshtein distance (might be difficult to install the binaries for non-technical users), run <code>pip install djtools</code></li> <li>You can install the pre-release version with <code>pip install djtools --pre</code></li> <li>If you want to restrict the version being installed to not include, say, the next minor version's beta release then you can do so like <code>pip install djtools&lt;2.5.0 --pre</code></li> <li>Note that installing with the <code>--pre</code> flag will also install pre-release versions for all dependencies which may cause breakage, in that case you can target specific pre-release versions like this <code>pip install djtools==2.4.1-rc9</code></li> </ul> </li> <li>Confirm your installation works by running <code>djtools</code></li> <li>[Optional] link the <code>configs</code> directory of the installation to a user-friendly location for easy editing of your config files: <code>djtools --link-configs path/to/new/location/</code></li> <li>Edit your configuration files to support your usage needs (see here for more details)</li> </ol>"},{"location":"tutorials/getting_started/setup/#aws-s3-api-compliant-object-store","title":"AWS S3 API compliant object store","text":"<p>If you are using any of the following features, you are required to have an AWS S3 API compliant cloud storage account setup (see this guide for more details):</p> <ul> <li>Sync files with the Beatcloud</li> <li>Sync tracks from Spotify playlists</li> <li>Check the Beatcloud for tracks in Spotify playlists or local directories</li> </ul>"},{"location":"tutorials/getting_started/setup/#spotify-user-account","title":"Spotify user account","text":"<p>If you are using any of the following features, you are required to have a Spotify account to add playlists to:</p> <ul> <li>Create Spotify playlists from Reddit posts</li> <li>Create Spotify playlists from other users' uploads</li> </ul>"},{"location":"tutorials/getting_started/setup/#spotify-and-reddit-apis","title":"Spotify and Reddit APIs","text":"<p>If you are using any of the following features, you are required to have a registered Spotify API application (see this guide for more details):</p> <ul> <li>Create Spotify playlists from other users' uploads</li> <li>Sync tracks from Spotify playlists</li> <li>Check the Beatcloud for tracks in Spotify playlists or local directories (if Spotify playlists are configured)</li> </ul> <p>Additionally, if you're using any of the following features, you are required to have a registered Reddit API application (see this guide for more details):</p> <ul> <li>Create Spotify playlists from Reddit posts</li> </ul>"},{"location":"tutorials/getting_started/setup/#discord-webhook","title":"Discord webhook","text":"<p>If you are using any of the following features, you are required to have a Discord server with a registered webhook integration (see this guide for more details):</p> <ul> <li>Create Spotify playlists from other users' uploads</li> <li>Sync files with the Beatcloud<ul> <li><code>NOTE</code>: this isn't strictly required but:<ol> <li>Create Spotify playlists from other users' uploads isn't possible without it </li> <li>It's really useful to automatically notify other users when and what tracks are uploaded</li> </ol> </li> </ul> </li> </ul>"},{"location":"tutorials/getting_started/setup/#ffmpeg","title":"FFmpeg","text":"<p>If you're using any of the features which leverage the <code>pydub</code> package (<code>normalize_audio</code>, <code>process_recording</code>, etc.), and you're exporting in any format other than <code>wav</code> or <code>raw</code>, you'll need to install FFmpeg to support those codecs. For more info about installing FFmpeg, you can look at the note about it on the <code>pydub</code> README.</p>"},{"location":"tutorials/getting_started/setup/#rekordbox-settings","title":"Rekordbox settings","text":""},{"location":"tutorials/getting_started/setup/#writing-my-tag-data-to-the-comments-field","title":"Writing \"My Tag\" data to the Comments field","text":"<p>In order for \"My Tag\" data to be accessible to the Build Playlists From Tags and Combine Playlists With Boolean Algebra features, that data must be written to the Comments field. There's no need to clear pre-existing data from the Comments; just ensure that this option is checked in the settings:</p> <p></p>"},{"location":"tutorials/getting_started/setup/#importing-tracks-from-xml","title":"Importing tracks from XML","text":"<p>Make sure you have made the <code>rekordbox.xml</code> database visible under <code>Preferences &gt; View &gt; Layout</code>: </p> <p>Also ensure you have the proper XML file (whichever XML has data you're wanting to import) selected under <code>Preferences &gt; Advanced &gt; Database &gt; rekordbox xml</code>: </p>"},{"location":"tutorials/getting_started/usage/","title":"Usage","text":"<p>What follows is a basic introduction to using DJ Tools. For detailed usage of the different features provided, please see the How-to Guides.</p> <p>DJ Tools is a command-line interface (CLI) tool so it must be run from the command-line! The command <code>djtools</code> should be available to you from any directory, however, Windows users may need to add their Python installation to their PATH environment variable depending on how they installed Python.</p> <p>Upon a fresh installation, running <code>djtools</code> without any options will do nothing. All of the configuration options will take on the default values defined in the configuration objects. Upon your first run of <code>djtools</code> a default <code>config.yaml</code> will be generated in the package directory (see the note below about linking configs).</p> <p>You may edit the values in this <code>config.yaml</code> to override the default values. For example, if you want the <code>collection_playlists</code> function to run every time you run <code>djtools</code>, this can be done by setting <code>collection_playlists: true</code>. If you want to configure the location of your music, this can be done by setting <code>usb_path: /path/to/your/music</code>. If any unsupported keys are added to <code>config.yaml</code>, <code>djtools</code> will fail because extra keys are forbidden. If any keys are missing from <code>config.yaml</code>, the defaults will be assumed.</p> <p>All options can be overridden from the CLI by providing the equivalent lowercase and dash-delimited option. For example, activating the <code>collection_playlists</code> function can be done by running <code>djtools --collection-playlists</code>. If you want to set your <code>usb_path</code> from the CLI during, say, a download music operation, this can be done by running <code>djtools sync --download-music --usb-path /path/to/your/music</code>. </p> <p>To reiterate, the order of option precedence is <code>CLI arguments &gt; config.yaml &gt; defaults</code>.</p> <p>Many of the configuration options are intended to be set only when first installing DJ Tools. Below are some example options that fit this category:</p> <ul> <li><code>aws_profile</code></li> <li><code>collection_path</code></li> <li><code>spotify_client_id</code></li> <li><code>discord_url</code></li> <li><code>usb_path</code></li> </ul> <p>For some other options, you will likely want to set them on a case-by-case basis and keep them configured at their default value, overriding them with the associated CLI option as needed. Some examples for this category include:</p> <ul> <li><code>collection_playlists</code></li> <li><code>spotify_playlist_from_upload</code></li> <li><code>upload_collection</code></li> <li><code>download_music</code></li> <li><code>check_tracks</code></li> <li><code>import_user</code></li> </ul> <p>Other options may change on occasion but are too difficult to format using the CLI, meaning you'll want to handle setting those options in <code>config.yaml</code>. Some example options that fit this category are:</p> <ul> <li><code>spotify_playlist_subreddits</code></li> <li><code>download_exclude_dirs</code></li> <li><code>check_tracks_spotify_playlists</code></li> </ul>"},{"location":"tutorials/getting_started/usage/#linking-your-configs","title":"Linking your configs","text":"<p>Although it's not necessary to do so, it's recommended that users run <code>djtools --link-configs path/to/new/folder</code> in order to create a symbolic link from the <code>configs</code> directory where DJ Tools is installed to a more user-friendly location.</p> <p>For example, whenever I install the newest version of DJ Tools, I remove my linked location (after making sure I backup important changes):</p> <p><code>rm -rf ~/Desktop/dj-tools-configs/live/</code></p> <p>install djtools:</p> <p><code>pip install djtools</code></p> <p>run the following command to link the installed configs directory:</p> <p><code>djtools --link-configs ~/Desktop/dj-tools-configs/live/</code></p> <p>and then I run this command to restore my configuration options from backups that I save whenever a new version of DJ Tools is released:</p> <p><code>cp ~/Desktop/dj-tools-configs/backups/2.4.0/* ~/Desktop/dj-tools-configs/live/</code></p> <p><code>NOTE</code>: these are Unix shell commands and will not work on Windows.</p>"},{"location":"tutorials/getting_started/usage/#backup-your-configs","title":"Backup your configs","text":"<p>Because your configs are stored alongside your <code>djtools</code> installation, reinstalling <code>djtools</code> will delete your config files! Please keep a backup of your config files and, upon reinstalling <code>djtools</code>, you can copy them into either your installation folder or the symbolically linked folder of your choosing.</p>"}]}